import { defineComponent as ae, ref as m, computed as y, watch as ue, nextTick as se, openBlock as g, createElementBlock as re, normalizeClass as ce, createBlock as C, resolveDynamicComponent as I, mergeProps as A, withCtx as D, normalizeProps as fe, guardReactiveProps as de, createElementVNode as me, createCommentVNode as pe } from "vue";
import { useUi as ye, useI18n as ge } from "@fast-crud/fast-crud";
import w from "lodash-es";
import { u as we, _ as ve } from "./index-e3d54c21.mjs";
const be = ae({
  name: "FsFileUploader",
  inheritAttrs: !1,
  props: {
    /**
     * value
     */
    modelValue: {},
    /**
     * 限制文件数量
     * 当限制数量>1时，返回值为数组
     */
    limit: {
      type: Number
    },
    /**
     * 文件大小限制，单位：字节
     * 可以直接传一个数字，也可以传 `{limit:number,tip:'自定义提示文本'}`
     */
    sizeLimit: {
      type: [Number, Object]
    },
    /**
     * 构建url的方法
     * 后台返回key之后，将其build成一个可访问的url，用于反显
     */
    buildUrl: {
      default() {
        return (n) => n;
      }
    },
    /**
     * 多个value值构建多个url
     */
    buildUrls: {},
    /**
     * 上传按钮配置，参考FsButton参数
     */
    button: {
      type: Object
    },
    /**
     * 展示模式，对应[x]-uploader组件的 listType参数
     */
    listType: {
      type: String
    },
    /**
     * 上传前的判断操作
     */
    beforeUpload: {
      type: Function
    },
    /**
     * 上传请求前的操作，可以压缩图片等
     * type: `async (context)=>{}`
     */
    beforeUploadRequest: {
      type: Function
    },
    /**
     * fs-uploader的配置
     * 可以覆盖全局配置里各个上传类型对应的配置
     * 例如: `{action:'xxx',bucket:'xxx',...}`
     */
    uploader: {
      type: Object
    },
    /**
     * 预览配置
     */
    preview: {
      type: Object
    },
    /**
     * 上传成功后从结果中取值类型
     * 支持：`[object,url,key,其他（successHandle返回的object内要有该字段，不要用'id'）]`
     * 如果配置了非url，则需要配置buildUrl用于反显
     */
    valueType: {
      type: String,
      // url ,key, object
      default: "url"
    },
    /**
     * 根据value获取文件名，用于显示在fileList里面
     */
    getFileName: {}
  },
  emits: ["change", "update:modelValue", "success", "exceed"],
  setup(n, u) {
    const { ui: o } = ye(), { t: p } = ge(), s = m([]), v = m(), c = m(), M = y(() => n.getFileName || ((e) => {
      if (typeof e != "string")
        return console.warn("获取文件名失败，请配置getFileName"), e;
      const t = e.substring(e.lastIndexOf("/") + 1), i = t.indexOf("?");
      return i >= 0 ? t.substring(0, i) : t;
    }));
    function b(e) {
      return n.valueType === "object" ? e : e[n.valueType];
    }
    function $(e) {
      const t = [];
      for (let i of e)
        t.push(b(i));
      return t;
    }
    async function _(e) {
      const t = [];
      for (let i of e) {
        let l;
        typeof i == "string" || typeof i == "number" || typeof i == "boolean" || i instanceof Date ? (l = {
          url: void 0,
          key: i,
          value: i
        }, n.valueType !== "object" && (l[n.valueType] = i)) : l = i, l[o.upload.id] || (l[o.upload.id] = Math.random() + ""), l.status || (l.status = o.upload.status.success), t.push(l);
      }
      await B(t);
      for (const i of t)
        if (!i.name) {
          const l = i.url || i.value;
          i.name = M.value(l);
        }
      return t;
    }
    async function z(e) {
      const t = [];
      for (let i of e) {
        const l = i.response || i.fsRes, a = {
          size: i.size,
          name: i.name,
          uid: i.uid,
          ...l ?? i
        };
        t.push(a);
      }
      return await B(t), $(t);
    }
    async function h(e) {
      const t = [];
      if (e == null || e.length === 0) {
        s.value = t;
        return;
      }
      if (e instanceof Array)
        for (let l of e)
          t.push(l);
      else
        t.push(e);
      const i = await _(t);
      N(i);
    }
    async function G() {
      await E.onChange(), await E.onBlur();
    }
    async function K(e) {
      let t = await H(e);
      R(t), se(async () => {
        await G();
      });
    }
    async function H(e) {
      if (e == null || e.length === 0)
        return n.limit === 1 ? null : [];
      if (n.limit === 1)
        return (await z(e))[0];
      const t = [];
      for (let i of e)
        o.upload.isSuccess(i) && t.push(i);
      return await z(t);
    }
    async function B(e) {
      let t = e.filter((i) => i.url == null);
      if (n.buildUrls) {
        const i = t.map((a) => b(a)), l = await n.buildUrls(i);
        for (let a = 0; a < t.length; a++)
          t[a].url = l[a];
      } else if (n.buildUrl)
        for (let i of t)
          i.url = await n.buildUrl(b(i));
      else
        for (let i of t)
          i.url = i.value || i.key;
    }
    function P(e) {
      u.emit("change", e);
    }
    function R(e) {
      v.value = e, u.emit("update:modelValue", e);
    }
    const E = o.formItem.injectFormItemContext();
    ue(
      () => n.modelValue,
      async (e) => {
        P(e), e !== v.value && await h(e);
      }
    ), h(n.modelValue);
    function J() {
      return s.value.filter((t) => t.status === o.upload.status.uploading).length > 0;
    }
    function f(e, t) {
      N(t), K(t);
    }
    function S(e, t, i) {
      u.emit("success", { res: e, file: t, fileList: i }), f(t, i);
    }
    function k(e) {
      let t;
      return e > 1024 * 1024 * 1024 ? t = (e / (1024 * 1024 * 1024)).toFixed(2) + "G" : e > 1024 * 1024 ? t = (e / (1024 * 1024)).toFixed(2) + "M" : t = Math.round(e / 1024) + "K", t;
    }
    const j = (e = !1) => {
      const t = e ? o.upload.limitAdd : 0;
      return n.limit > 0 && s.value.length >= n.limit + t;
    };
    function Q() {
      o.message.warn(p("fs.extends.fileUploader.limitTip", [n.limit]));
    }
    function U() {
      if (j(!0))
        throw Q(), new Error("文件数量超限");
    }
    function W(e) {
      if (n.sizeLimit != null) {
        let t = n.sizeLimit, i = null;
        if (typeof n.sizeLimit == "number" ? i = (l, a) => {
          const d = k(a), r = k(e.size);
          o.message.warn(p("fs.extends.fileUploader.sizeLimitTip", [d, r]));
        } : (t = n.sizeLimit.limit, i = n.sizeLimit.tip), e.size > t)
          throw console.log("文件大小超过限制：", e.size), i(e.size, t), new Error("文件大小超过限制：" + e.size);
      }
    }
    const F = async (e, t = s.value) => {
      if (!(n.beforeUpload && await n.beforeUpload({ file: e, fileList: s.value }) === !1))
        try {
          U(), W(e);
        } catch {
          return !1;
        }
    };
    function N(e) {
      s.value = e;
    }
    async function X(e) {
      e.options = n.uploader || {};
      const { getUploaderImpl: t } = we();
      let i = await t(e.options.type);
      if (i == null)
        throw o.message.warn("Sorry，The uploader component is not ready yet"), new Error("Sorry，The component is not ready yet");
      return await (i == null ? void 0 : i.upload(e));
    }
    async function T(e) {
      n.beforeUploadRequest && await n.beforeUploadRequest(e);
      const { file: t, onProgress: i, onSuccess: l, onError: a } = e, d = {
        file: t,
        fileName: t.name,
        onProgress: i
      };
      try {
        const r = await X(d);
        l(r);
      } catch (r) {
        console.error("上传失败", r), a(r);
      }
    }
    const Y = y(() => te() ? {
      is: "FsIcon",
      icon: o.icons.plus
    } : {
      is: "FsButton",
      icon: o.icons.upload,
      text: p("fs.extends.fileUploader.text"),
      ...n.button
    }), O = m(!1), q = m(), Z = y(() => ({
      ...o.dialog.footer(),
      ...n.preview
    }));
    function ee(e) {
      return new Promise((t, i) => {
        const l = new FileReader();
        l.readAsDataURL(e), l.onload = () => t(l.result), l.onerror = (a) => i(a);
      });
    }
    function x() {
      return n.listType === o.upload.typeImageCard || n.listType === o.upload.typeImage;
    }
    function te() {
      return n.listType === o.upload.typeImageCard;
    }
    const L = async (e) => {
      var t, i;
      if (!x()) {
        let l;
        e.url ? l = e.url : o.type === "antdv" ? l = (t = e.response) == null ? void 0 : t.url : o.type === "element" ? l = (i = e.fsRes) == null ? void 0 : i.url : l = e.url, window.open(l, "_blank");
      }
      !e.url && !e.preview && e.originFileObj && (e.preview = await ee(e.originFileObj)), q.value = e.url || e.preview, O.value = !0;
    };
    function ie() {
      const e = {
        customRequest: T,
        beforeUpload: F,
        listType: n.listType,
        onChange: (t) => {
          const { file: i, fileList: l } = t;
          f(i, l);
        },
        onPreview: L
      };
      return n.limit != null && u.attrs.maxCount == null && (e.maxCount = n.limit), e;
    }
    function ne() {
      return {
        action: "",
        listType: n.listType,
        beforeUpload: F,
        httpRequest: T,
        onExceed: () => {
          U(), u.emit("exceed", { fileList: s.value });
        },
        onRemove: (e, t) => {
          f(e, t);
        },
        onChange: (e, t) => {
          f(e, t);
        },
        onSuccess: (e, t, i) => {
          e != null && (t.response = e, t.fsRes = e, S(e, t, i));
        },
        // "on-error": "handleUploadFileError",
        // "on-progress": "handleUploadProgress"
        onPreview: L
      };
    }
    const V = {};
    function le() {
      function e(t) {
        let i = t.value || t;
        i = w.cloneDeep(i);
        for (let l of i) {
          const a = V[l.id];
          a && w.merge(l, a);
        }
        return i;
      }
      return {
        action: "",
        listType: n.listType,
        onBeforeUpload: async ({ file: t, fileList: i }) => F(t, i),
        customRequest: (t) => {
          const i = t.file;
          T({
            ...t,
            file: i.file,
            onSuccess: async (l) => {
              const a = n.valueType === "object" ? l : l[n.valueType];
              l.url = await n.buildUrl(a), w.merge(i, l), V[i.id] = {
                ...l,
                fsRes: l
              }, t.onFinish(i);
            },
            onProgress: (l) => {
              t.onProgress(l);
            }
          });
        },
        onExceed: () => {
          U(), u.emit("exceed", { fileList: s.value });
        },
        onRemove: (t) => {
        },
        onChange: (t) => {
          const { event: i, file: l, fileList: a } = t, d = e(a);
          f(l, [...d]);
        },
        onFinish: (t) => {
          const i = V[t.id];
          i && w.merge(t, i);
          const l = e(s);
          S(i, t, l);
        },
        onPreview: L
      };
    }
    const oe = y(() => {
      let e = null;
      return o.type === "antdv" ? e = ie() : o.type === "element" ? e = ne() : e = le(), {
        ...e,
        ...u.attrs
      };
    });
    return {
      ui: o,
      fileList: s,
      fileUploaderRef: c,
      initValue: h,
      onChange: P,
      onInput: R,
      hasUploading: J,
      isPicture: x,
      computedFileSelectBtn: Y,
      previewVisible: O,
      previewImage: q,
      computedPreview: Z,
      computedOnLimit: j,
      computedBinding: oe
    };
  }
});
const he = ["src"];
function Ue(n, u, o, p, s, v) {
  return g(), re("div", {
    class: ce(["fs-file-uploader", { "fs-file-uploader-limit": n.computedOnLimit() }])
  }, [
    (g(), C(I(n.ui.upload.name), A({
      ref: "fileUploaderRef",
      fileList: n.fileList,
      "onUpdate:fileList": u[0] || (u[0] = (c) => n.fileList = c)
    }, n.computedBinding), {
      default: D(() => [
        (g(), C(I(n.computedFileSelectBtn.is), fe(de(n.computedFileSelectBtn)), null, 16))
      ]),
      _: 1
    }, 16, ["fileList"])),
    n.isPicture() ? (g(), C(I(n.ui.dialog.name), A({
      key: 0,
      [n.ui.dialog.visible]: n.previewVisible,
      ["onUpdate:" + n.ui.dialog.visible]: u[1] || (u[1] = (c) => n.previewVisible = c)
    }, n.computedPreview), {
      default: D(() => [
        me("img", {
          style: { "max-width": "100%", "max-height": "100%" },
          src: n.previewImage
        }, null, 8, he)
      ]),
      _: 1
    }, 16)) : pe("", !0)
  ], 2);
}
const Ce = /* @__PURE__ */ ve(be, [["render", Ue]]);
export {
  Ce as default
};
//# sourceMappingURL=fs-file-uploader-771d3c4d.mjs.map
