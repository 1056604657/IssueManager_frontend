import { defineComponent as G, ref as d, watch as q, getCurrentInstance as J, reactive as K, resolveComponent as I, openBlock as r, createElementBlock as c, normalizeClass as E, createElementVNode as m, createBlock as h, resolveDynamicComponent as N, withCtx as P, Fragment as M, renderList as Q, mergeProps as X, createVNode as f, createCommentVNode as w } from "vue";
import { useUi as Y } from "@fast-crud/fast-crud";
import { u as Z, _ as x } from "./index-e3d54c21.mjs";
import "lodash-es";
const ee = G({
  name: "FsCropperUploader",
  props: {
    disabled: {},
    // 初始图片url,或者是数组
    modelValue: {
      type: [String, Array]
    },
    img: {},
    // 上传后端类型，[form, cos, qiniu , alioss]
    type: {
      type: String
    },
    // 上传提示
    uploadTip: {
      type: String
    },
    // 对话框标题
    title: String,
    // cropper的高度，默认为浏览器可视窗口高度的40%，最小270
    cropperHeight: {
      type: [String, Number]
    },
    // 对话框宽度，默认50%
    dialogWidth: {
      type: [String, Number],
      default: "50%"
    },
    // 图片大小限制，单位MB
    maxSize: {
      type: Number,
      default: 5
    },
    // 图片数量限制,0为不限制
    limit: {
      type: Number,
      default: 1
    },
    // 可接收的文件后缀
    accept: {
      type: String,
      default: ".jpg, .jpeg, .png, .gif, .webp"
    },
    // [cropperjs的参数](https://github.com/fengyuanchen/cropperjs)
    cropper: {
      type: Object
    },
    // 上传参数，会临时覆盖全局上传配置参数[d2p-uploader](/guide/extends/uploader.html)
    uploader: {
      type: Object
    },
    // 构建下载url方法,不影响提交的value
    buildUrl: {
      type: Function,
      default: async function(e) {
        return typeof e == "object" ? e.url : e;
      }
    },
    /**
     * 返回值类型
     * 支持：`[url,key,object]`
     */
    valueType: {
      type: String,
      // url ,key, object
      default: "url"
    }
  },
  emits: ["update:modelValue", "change", "ready"],
  setup(e, s) {
    const { ui: b } = Y(), g = d(), R = d(), C = d(), l = d([]), u = b.formItem.injectFormItemContext();
    let v = e.modelValue;
    n(e.modelValue);
    async function n(o) {
      const t = [];
      if (o == null || o === "") {
        l.value = t;
        return;
      }
      if (typeof o == "string")
        t.push({ url: await e.buildUrl(o), value: o, status: "done" });
      else
        for (const i of o)
          t.push({ url: await e.buildUrl(i), value: i, status: "done" });
      l.value = t;
    }
    function y() {
      e.disabled || (C.value = void 0, g.value.clear(), g.value.open());
    }
    function U(o) {
      l.value.splice(o, 1), T();
    }
    function B() {
      const o = l.value;
      if (o && o.length > 0) {
        for (const t of o)
          if (t.status === "uploading")
            return !0;
      }
      return !1;
    }
    async function F(o) {
      const t = o.blob, i = o.dataUrl, O = o.file, p = K({
        url: void 0,
        dataUrl: i,
        status: "uploading",
        progress: 0
      }), W = (a) => {
        p.progress = a.percent;
      }, z = (a) => {
        p.status = "error", p.message = "文件上传出错:" + a.message, console.error(a);
      }, A = {
        file: t,
        fileName: O.name,
        onProgress: W,
        onError: z
      };
      l.value.push(p);
      try {
        const a = await j(A);
        let S = a;
        e.valueType !== "object" && (S = a[e.valueType]), p.url = await e.buildUrl(S), p.value = S, p.status = "done", T();
      } catch (a) {
        z(a);
      }
    }
    async function j(o) {
      o.options = e.uploader || {};
      const { getUploaderImpl: t } = Z();
      let i = await t(o.options.type);
      if (i == null)
        throw new Error("Sorry，The component is not ready yet");
      return await (i == null ? void 0 : i.upload(o));
    }
    async function T() {
      const o = [];
      for (const i of l.value)
        typeof i == "string" ? o.push(i) : o.push(i.value);
      let t = o;
      e.limit === 1 && (t = o && o.length > 0 ? o[0] : void 0), v = t, s.emit("update:modelValue", t), await u.onChange(), await u.onBlur();
    }
    function $(o) {
      return o.dataUrl ? o.dataUrl : o.url;
    }
    const k = d(!1), V = d();
    function _(o) {
      k.value = !0, V.value = $(o);
    }
    function D() {
      k.value = !1, V.value = null;
    }
    q(
      () => e.modelValue,
      async (o) => {
        s.emit("change", o), o !== v && await n(o);
      }
    );
    const H = J();
    function L(o) {
      s.emit("ready", {
        uploaderRef: H,
        ...o
      });
    }
    return {
      ui: b,
      cropperRef: g,
      uploaderImplRef: R,
      indexRef: C,
      listRef: l,
      addNewImage: y,
      hasUploading: B,
      cropComplete: F,
      doUpload: j,
      removeImage: U,
      getImageSrc: $,
      previewUrl: V,
      previewVisible: k,
      preview: _,
      closePreview: D,
      doReady: L
    };
  }
});
const oe = { class: "image-list" }, te = { class: "image-slot" }, ie = { class: "delete" }, ne = {
  key: 0,
  class: "status-uploading"
}, re = {
  key: 1,
  class: "status-done"
}, le = { class: "fs-cropper-preview-content" }, ae = ["src"];
function se(e, s, b, g, R, C) {
  const l = I("fs-loading"), u = I("fs-icon"), v = I("fs-cropper");
  return r(), c("div", {
    class: E(["fs-cropper-uploader", { "is-disabled": e.disabled }])
  }, [
    m("div", oe, [
      (r(), h(N(e.ui.imageGroup.name), null, {
        default: P(() => [
          (r(!0), c(M, null, Q(e.listRef, (n, y) => (r(), c("div", {
            key: y,
            class: "image-item"
          }, [
            (r(), h(N(e.ui.image.name), X({
              class: "image",
              src: e.getImageSrc(n)
            }, e.img), {
              placeholder: P(() => [
                m("div", te, [
                  f(l, { loading: !0 })
                ])
              ]),
              _: 2
            }, 1040, ["src"])),
            m("div", ie, [
              e.disabled ? w("", !0) : (r(), h(u, {
                key: 0,
                icon: e.ui.icons.remove,
                onClick: (U) => e.removeImage(y)
              }, null, 8, ["icon", "onClick"])),
              f(u, {
                icon: e.ui.icons.search,
                onClick: (U) => e.preview(n)
              }, null, 8, ["icon", "onClick"])
            ]),
            n.status === "uploading" ? (r(), c("div", ne, [
              (r(), h(N(e.ui.progress.name), {
                type: "circle",
                percentage: n.progress,
                width: 70
              }, null, 8, ["percentage"]))
            ])) : n.status === "done" ? (r(), c("div", re, [
              f(u, {
                icon: e.ui.icons.check,
                class: "status-down-icon"
              }, null, 8, ["icon"])
            ])) : w("", !0)
          ]))), 128)),
          e.limit <= 0 || e.limit > e.listRef.length ? (r(), c("div", {
            key: 0,
            class: "image-item image-plus",
            onClick: s[0] || (s[0] = (...n) => e.addNewImage && e.addNewImage(...n))
          }, [
            f(u, {
              icon: e.ui.icons.plus,
              class: "cropper-uploader-icon"
            }, null, 8, ["icon"])
          ])) : w("", !0)
        ]),
        _: 1
      }))
    ]),
    f(v, {
      ref: "cropperRef",
      title: e.title,
      "cropper-height": e.cropperHeight,
      "dialog-width": e.dialogWidth,
      accept: e.accept,
      "upload-tip": e.uploadTip,
      "max-size": e.maxSize,
      cropper: e.cropper,
      output: "all",
      onDone: e.cropComplete,
      onReady: e.doReady
    }, null, 8, ["title", "cropper-height", "dialog-width", "accept", "upload-tip", "max-size", "cropper", "onDone", "onReady"]),
    m("div", {
      class: E(["fs-cropper-preview", { open: e.previewVisible }]),
      onClick: s[1] || (s[1] = (...n) => e.closePreview && e.closePreview(...n))
    }, [
      m("div", le, [
        e.previewUrl ? (r(), c("img", {
          key: 0,
          src: e.previewUrl,
          class: "preview-image"
        }, null, 8, ae)) : w("", !0)
      ])
    ], 2)
  ], 2);
}
const me = /* @__PURE__ */ x(ee, [["render", se]]);
export {
  me as default
};
//# sourceMappingURL=fs-cropper-uploader-7c221ccc.mjs.map
