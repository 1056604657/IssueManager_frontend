import {
  useRoute
} from "./chunk-RT6XIFAZ.js";
import {
  l,
  w
} from "./chunk-TMD4VLGD.js";
import {
  require_dayjs_min
} from "./chunk-OBCII6EX.js";
import {
  isArray_default,
  lodash_default_default
} from "./chunk-6KFXODJP.js";
import {
  Fragment,
  TransitionGroup,
  computed2 as computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  isShallow,
  isVNode,
  markRaw,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onMounted,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  shallowReactive,
  toDisplayString,
  toRaw,
  toRef,
  unref,
  useAttrs,
  useSlots,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withModifiers
} from "./chunk-7Q7JYBSX.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@fast-crud/fast-crud/dist/index-bae3872a.mjs
var import_dayjs = __toESM(require_dayjs_min(), 1);
var li = Object.defineProperty;
var ui = (e, t, n) => t in e ? li(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var te = (e, t, n) => (ui(e, typeof t != "symbol" ? t + "" : t, n), n);
var Po = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var g = (e, t, n) => (Po(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var ve = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
};
var le = (e, t, n, o) => (Po(e, t, "write to private field"), o ? o.call(e, n) : t.set(e, n), n);
var Jn = (e, t, n, o) => ({
  set _(a) {
    le(e, t, a, n);
  },
  get _() {
    return g(e, t, o);
  }
});
var oe = (e, t, n) => (Po(e, t, "access private method"), n);
var Nn = {
  commonOptions(e) {
    return {};
  },
  defaultOptions(e) {
    const { t } = e, n = l.get();
    return {
      mode: {},
      status: {},
      search: {
        container: {
          is: "fs-search-layout-default",
          collapse: true,
          col: {
            span: 4
          }
        },
        options: {
          ...n.form.inlineLayout,
          // n-form 是否显示校验反馈
          showFeedback: false
        },
        onValidateError({ trigger: o }) {
          o === "search" && n.notification.error({ message: t("fs.search.error.message") });
        },
        collapse: true,
        show: true,
        buttons: {
          search: {
            icon: n.icons.search
          },
          reset: {
            icon: n.icons.refresh
          }
        }
      },
      form: {
        labelPlacement: "left",
        labelPosition: "right",
        labelWidth: "80px",
        style: {
          "grid-template-columns": "50% 50%"
          // grid布局，默认两列
        },
        row: {
          gutter: 10
        },
        col: { span: 12 },
        labelAlign: "right",
        labelCol: { span: 4 },
        wrapperCol: { span: 18 },
        wrapper: {
          is: n.dialog.name,
          ...n.formWrapper.buildWidthBind(n.dialog.name, "960px"),
          ...n.formWrapper.buildInitBind(n.dialog.name),
          draggable: true,
          destroyOnClose: true,
          ...n.dialog.footer()
          // antdv
        }
      },
      addForm: {
        wrapper: {
          title: t("fs.addForm.title")
        }
      },
      editForm: {
        wrapper: {
          title: t("fs.editForm.title")
        }
      },
      viewForm: {
        wrapper: {
          title: t("fs.viewForm.title")
        }
      },
      rowHandle: {
        width: "250px",
        title: t("fs.rowHandle.title"),
        order: 1e3,
        dropdown: {
          // 操作列折叠
          more: {
            text: null,
            type: "primary",
            icon: n.icons.more
          }
        }
      },
      pagination: {
        background: true,
        pageSize: 20,
        [n.pagination.currentPage]: 1,
        [n.pagination.total]: 1,
        pageSizes: [5, 10, 20, 50],
        layout: "total, sizes, prev, pager, next, jumper",
        showSizeChanger: true,
        showQuickJumper: true,
        showSizePicker: true,
        showTotal: (o) => t("fs.pagination.showTotal", [o])
        //antdv
      },
      table: {
        show: true,
        height: "100%",
        rowKey: n.table.defaultRowKey,
        stripe: true,
        border: true,
        bordered: true,
        singleLine: false,
        editable: { enabled: false, rowKey: "$editable_id" },
        pagination: false
        //antdv 关闭默认分页
      },
      toolbar: {
        compact: true
      },
      actionbar: {
        buttons: {
          add: {
            type: "primary",
            text: t("fs.actionbar.add")
          }
        }
      }
    };
  }
};
function yi() {
  var t;
  return (t = new Error().stack) == null ? void 0 : t.split(`
`)[3];
}
var Rt = (...e) => {
};
function Qo(...e) {
  console.log.apply(this, arguments);
}
function wi(...e) {
  console.warn.apply(this, arguments);
}
function _i(...e) {
  console.error.apply(this, arguments);
}
var Ci = (...e) => {
  _i("%c [error]", "font-weight: 600;", ...e);
};
var Fi = (...e) => {
  wi("%c [warn]", "font-weight: 600;", ...e);
};
var Ir = (...e) => {
  Qo("%c [info]", "font-weight: 600;", ...e);
};
var Si = (...e) => {
  if (!console.log)
    return;
  const t = yi();
  {
    const n = ["%c [debug]", "font-weight: 600;", ...e];
    Qo(...n);
    const o = ["%c " + t, "color:#999"];
    Qo(...o);
  }
};
var ue = {
  debug: Rt,
  info: Rt,
  warn: Rt,
  error: Rt,
  log: Rt
};
function Ei(e = {}) {
  const t = (e == null ? void 0 : e.level) || "info";
  switch (ue.debug = Rt, ue.info = Rt, ue.warn = Rt, ue.error = Rt, ue.log = Rt, t) {
    case "debug":
      ue.debug = Si;
    case "info":
      ue.info = Ir, ue.log = Ir;
    case "warn":
      ue.warn = Fi;
    case "error":
      ue.error = Ci;
      break;
  }
}
Ei();
function Di(e) {
  return e == null || e === "";
}
function Ri(...e) {
  for (const t of e)
    if (!(t == null || t === ""))
      return false;
  return false;
}
function ki(...e) {
  for (const t of e)
    if (t == null || t === "")
      return true;
  return false;
}
var wr = {
  isEmpty: Di,
  isAllEmpty: Ri,
  hasEmpty: ki
};
var Oi = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,no-unused-vars
  trace(e) {
  }
};
function _r(e) {
  return defineAsyncComponent({
    loader: e,
    onError(t, n, o, a) {
      console.error("load error", t), t.message.match(/fetch/) && a <= 3 ? n() : o();
    }
  });
}
function $i(e, t, n, o) {
  const a = _r(n);
  e.component(t, a, o);
}
function Ti(e, t, n, o, a) {
  const r = Kn(t, o, a);
  lodash_default_default.forEach(r, (i, s) => {
    n && n.indexOf(s) != -1 || $i(e, s, i, null);
  });
}
function Ai(e, t, n, o, a) {
  const r = Kn(t, o, a);
  lodash_default_default.forEach(r, (i, s) => {
    n && n.indexOf(s) || e.component(s, i.default);
  });
}
function Kn(e, t, n) {
  const o = {};
  return t == null && (t = /.*\/(.+).(vue|jsx|tsx)/), lodash_default_default.forEach(e, (a, r) => {
    const i = r.match(t);
    if ((i == null ? void 0 : i.length) <= 1) {
      console.error(`"${r}" can't pick a component name,this component can't register`);
      return;
    }
    let s = i[1];
    s = lodash_default_default.camelCase(s), s = lodash_default_default.upperFirst(s), n && (a = n(a)), o[s] = a;
  }), o;
}
function Ii(e) {
  const t = Kn(e), n = {};
  return lodash_default_default.forEach(t, (o, a) => {
    n[a] = _r(o);
  }), n;
}
function Pi(e) {
  const t = Kn(e), n = {};
  return lodash_default_default.forEach(t, (o, a) => {
    n[a] = o.default;
  }), n;
}
var Vi = {
  transformFromGlob: Kn,
  installAsyncComponents: Ti,
  installSyncComponents: Ai,
  createAsyncComponent: _r,
  loadAsyncComponentFromGlob: Ii,
  loadComponentFromGlob: Pi
};
var fa = class {
  constructor(t) {
    te(this, "key");
    te(this, "tableId");
    const { $router: n, tableName: o, keyType: a } = t;
    this.key = this.getItemKey(n, a), this.tableId = this.getTableId(o);
  }
  getTableId(t) {
    const n = "fs-crud";
    return t && typeof t == "string" ? n + "." + t : n;
  }
  getTable() {
    const t = localStorage.getItem(this.tableId);
    if (t != null)
      return JSON.parse(t);
  }
  saveTable(t) {
    localStorage.setItem(this.tableId, JSON.stringify(t));
  }
  clearTable() {
    localStorage.removeItem(this.tableId);
  }
  updateTableValue(t, n = this.key) {
    let o = this.getTable();
    o == null && (o = {}), o[n] = t, this.saveTable(o);
  }
  getItemKey(t, n) {
    let o = location.href;
    return t && (o = t.path), n == null || typeof n != "string" ? o : o + "." + n;
  }
  getTableValue(t) {
    const n = this.getTable();
    return n == null ? null : (t == null && (t = this.key), n[t]);
  }
  clearTableValue(t) {
    const n = this.getTable();
    n != null && (t == null && (t = this.key), delete n[t], this.saveTable(n));
  }
};
var Mi = /\D/;
var ji = /^[a-zA-Z_$]+([\w_$]*)$/;
var Bi = /"/g;
function Pr(...e) {
  return e.reduce((t, n) => t ? !n || n.startsWith("[") ? `${t}${n}` : `${t}.${n}` : n, "");
}
function ha(e) {
  function t(n, ...o) {
    if (o = o.filter((a) => a !== void 0), e.isString(n))
      return Pr(...o, n);
    if (Array.isArray(n))
      return o = Pr(...o), n.reduce((a, r) => {
        const i = typeof r;
        return i === "number" ? r < 0 || r % 1 !== 0 ? `${a}["${r}"]` : `${a}[${r}]` : i !== "string" ? `${a}["${r}"]` : r ? Mi.test(r) ? ji.test(r) ? a ? `${a}.${r}` : `${a}${r}` : `${a}["${r.replace(Bi, '\\"')}"]` : `${a}[${r}]` : `${a}[""]`;
      }, o);
  }
  return t;
}
ha.notChainable = true;
var Ni = /^[a-zA-Z_$]+([\w_$]*)$/;
var Li = /"/g;
var ma = Object.prototype.hasOwnProperty;
function qi(e) {
  const t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function Hi(e) {
  const t = ha(e);
  function n(r) {
    const { options: i, obj: s, callback: u } = r;
    i.pathFormatArray = i.pathFormat == "array", r.depth = 0;
    let l2 = false;
    const c = () => (l2 = true, false);
    for (; r && !l2; ) {
      if (!r.inited) {
        if (r.inited = true, r.info = Mr(r.value, i.ownPropertiesOnly), i.checkCircular && (r.circularParentIndex = -1, r.circularParent = null, r.isCircular = false, r.info.isObject && !r.info.isEmpty)) {
          let d = r.parent;
          for (; d; ) {
            if (d.value === r.value) {
              r.isCircular = true, r.circularParent = d, r.circularParentIndex = r.depth - d.depth - 1;
              break;
            }
            d = d.parent;
          }
        }
        if (r.children = [], i.childrenPath && i.childrenPath.forEach((d, f) => {
          const h2 = e.get(r.value, d), v = Mr(h2, i.ownPropertiesOnly);
          v.isEmpty || r.children.push([d, i.strChildrenPath[f], h2, v]);
        }), r.isLeaf = r.isCircular || i.childrenPath !== void 0 && !r.children.length || !r.info.isObject || r.info.isEmpty, r.needCallback = (r.depth || i.includeRoot) && (!i.leavesOnly || r.isLeaf), r.needCallback) {
          const d = new Vr(s, i, c);
          d.setItem(r, false);
          try {
            r.res = u(r.value, r.key, r.parent && r.parent.value, d);
          } catch (f) {
            throw f.message && (f.message += `
callback failed before deep iterate at:
` + t(r.path)), f;
          }
        }
        if (l2)
          break;
        r.res !== false && !l2 && !r.isCircular && r.info.isObject && (i.childrenPath !== void 0 && (r.depth || !i.rootIsChildren) ? (r.childrenItems = [], r.children.length && r.children.forEach(([d, f, h2, v]) => {
          r.childrenItems = [
            ...r.childrenItems,
            ...v.isArray ? o(r, h2, i, d, f) : a(r, h2, i, d, f)
          ];
        })) : r.childrenItems = r.info.isArray ? o(r, r.value, i, [], "") : a(r, r.value, i, [], "")), r.currentChildIndex = -1;
      }
      if (r.childrenItems && r.currentChildIndex < r.childrenItems.length - 1) {
        r.currentChildIndex++, r.childrenItems[r.currentChildIndex].parentItem = r, r = r.childrenItems[r.currentChildIndex];
        continue;
      }
      if (r.needCallback && i.callbackAfterIterate) {
        const d = new Vr(s, i, c);
        d.setItem(r, true);
        try {
          u(r.value, r.key, r.parent && r.parent.value, d);
        } catch (f) {
          throw f.message && (f.message += `
callback failed after deep iterate at:
` + t(r.path)), f;
        }
      }
      r = r.parentItem;
    }
  }
  return n;
  function o(r, i, s, u, l2) {
    let c;
    s.pathFormatArray || (c = r.strPath || "", l2 && c && !l2.startsWith("[") && (c += "."), c += l2 || "");
    const d = [];
    for (let f = 0; f < i.length; f++) {
      const h2 = i[f];
      if (h2 === void 0 && !(f in i))
        continue;
      let v;
      const p = !s.pathFormatArray;
      p && (v = `${c}[${f}]`), d.push({
        value: h2,
        key: f + "",
        path: [...r.path || [], ...u, f + ""],
        strPath: v,
        depth: r.depth + 1,
        parent: {
          value: r.value,
          key: r.key,
          path: p ? r.strPath : r.path,
          parent: r.parent,
          depth: r.depth,
          info: r.info
        },
        childrenPath: u.length && u || void 0,
        strChildrenPath: l2 || void 0
      });
    }
    return d;
  }
  function a(r, i, s, u, l2) {
    let c;
    s.pathFormatArray || (c = r.strPath || "", l2 && c && !l2.startsWith("[") && (c += "."), c += l2 || "");
    const d = [], f = !s.pathFormatArray;
    for (const h2 in i) {
      if (s.ownPropertiesOnly && !ma.call(i, h2))
        continue;
      let v;
      f && (Ni.test(h2) ? c ? v = `${c}.${h2}` : v = `${h2}` : v = `${c}["${h2.replace(Li, '\\"')}"]`), d.push({
        value: i[h2],
        key: h2,
        path: [...r.path || [], ...u, h2],
        strPath: v,
        depth: r.depth + 1,
        parent: {
          value: r.value,
          key: r.key,
          path: f ? r.strPath : r.path,
          parent: r.parent,
          depth: r.depth,
          info: r.info
        },
        childrenPath: u.length && u || void 0,
        strChildrenPath: l2 || void 0
      });
    }
    return d;
  }
}
var Vr = class {
  constructor(t, n, o) {
    te(this, "_item");
    te(this, "obj");
    te(this, "_options");
    te(this, "afterIterate");
    this.obj = t, this._options = n, this.break = o;
  }
  setItem(t, n) {
    this._item = t, this.afterIterate = n;
  }
  get path() {
    return this._options.pathFormatArray ? this._item.path : this._item.strPath;
  }
  get parent() {
    return this._item.parent;
  }
  get parents() {
    if (!this._item._parents) {
      this._item._parents = [];
      let t = this._item.parent;
      for (; t; )
        this._item._parents[t.depth] = t, t = t.parent;
    }
    return this._item._parents;
  }
  get depth() {
    return this._item.depth;
  }
  get isLeaf() {
    return this._item.isLeaf;
  }
  get isCircular() {
    return this._item.isCircular;
  }
  get circularParentIndex() {
    return this._item.circularParentIndex;
  }
  get circularParent() {
    return this._item.circularParent;
  }
  get childrenPath() {
    return this._options.childrenPath !== void 0 && (this._options.pathFormatArray ? this._item.childrenPath : this._item.strChildrenPath) || void 0;
  }
  get info() {
    return this._item.info;
  }
};
function Wi(e, t) {
  for (const n in e)
    if (!t || ma.call(e, n))
      return false;
  return true;
}
function Mr(e, t) {
  const n = { isObject: qi(e) };
  return n.isArray = n.isObject && Array.isArray(e), n.isEmpty = n.isArray ? !e.length : n.isObject ? Wi(e, t) : true, n;
}
function xi(e) {
  const t = Hi(e);
  function n(o, a, r) {
    if (a === void 0 && (a = e.identity), r = e.merge({
      includeRoot: !Array.isArray(o),
      pathFormat: "string",
      checkCircular: false,
      leavesOnly: false,
      ownPropertiesOnly: true
      //
    }, r || {}), r.childrenPath !== void 0) {
      if (!r.includeRoot && r.rootIsChildren === void 0 && (r.rootIsChildren = Array.isArray(o)), !e.isString(r.childrenPath) && !Array.isArray(r.childrenPath))
        throw Error("childrenPath can be string or array");
      e.isString(r.childrenPath) && (r.childrenPath = [r.childrenPath]), r.strChildrenPath = r.childrenPath, r.childrenPath = [];
      for (let i = r.strChildrenPath.length - 1; i >= 0; i--)
        r.childrenPath[i] = e.toPath(r.strChildrenPath[i]);
    }
    return t({
      value: o,
      callback: a,
      options: r,
      obj: o
    }), o;
  }
  return n;
}
var zi = xi(lodash_default_default);
var pa = {
  forEachDeep: zi
};
var Ui = {
  /**
   * 重构object，但忽略某些字段
   * @param ref
   * @param skips
   */
  omit(e, ...t) {
    const n = Object.keys(e.value), o = {};
    for (const a of n)
      a !== "loading" && (t.indexOf(a) >= 0 || (o[a] = e.value[a]));
    return o;
  }
};
var ko = {
  logger: ue,
  strings: wr,
  trace: Oi,
  vite: Vi,
  store: fa,
  deepdash: pa,
  dash: Ui
};
function Vo(e, t) {
  return e.type !== "antdv" ? {} : { labelCol: { span: t }, wrapperCol: { span: 23 - t } };
}
function Yi() {
  const { ui: e } = w();
  return {
    colspan: {
      //跨列
      form: {
        col: { span: 24 },
        ...Vo(e, 2)
      }
    },
    colspan3: {
      //跨列
      form: {
        col: { span: 24 },
        ...Vo(e, 3)
      }
    },
    colspan4: {
      //跨列
      form: {
        col: { span: 24 },
        ...Vo(e, 4)
      }
    }
  };
}
var Ki = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Yi
}, Symbol.toStringTag, { value: "Module" }));
function Gi() {
  const e = l.get();
  return {
    button: {
      form: {
        component: {
          name: e.input.name,
          vModel: e.input.modelValue,
          [e.input.clearable]: true
        }
      },
      column: {
        component: {
          name: "fs-button",
          vModel: "text"
        }
      }
    },
    link: {
      form: {
        component: {
          name: e.input.name,
          vModel: e.input.modelValue,
          [e.input.clearable]: true
        }
      },
      column: {
        component: {
          name: "fs-button",
          vModel: "text",
          ...e.button.linkType
        }
      }
    }
  };
}
var Xi = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Gi
}, Symbol.toStringTag, { value: "Module" }));
function Qi() {
  const e = l.get();
  return {
    "dict-cascader": {
      search: {
        component: {
          clearable: true
        }
      },
      form: {
        component: {
          name: "fs-dict-cascader",
          vModel: e.cascader.modelValue,
          [e.cascader.clearable]: true
        }
      },
      column: {
        component: { name: "fs-dict-cascader-format" }
      }
    }
  };
}
var Ji = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Qi
}, Symbol.toStringTag, { value: "Module" }));
var ga = {
  name: "zh-cn",
  fs: {
    component: {
      select: {
        placeholder: "请选择"
      }
    },
    addForm: { title: "添加" },
    editForm: { title: "编辑" },
    viewForm: { title: "查看" },
    rowHandle: {
      title: "操作",
      remove: {
        text: "删除",
        confirmTitle: "删除提示",
        confirmMessage: "您确定要删除该记录吗?",
        success: "删除成功!"
      },
      edit: {
        text: "编辑"
      },
      view: {
        text: "查看"
      }
    },
    form: {
      cancel: "取消",
      ok: "确定",
      reset: "重置"
    },
    actionbar: { add: "添加" },
    toolbar: {
      columnFilter: {
        title: "列设置",
        fixed: "固定",
        order: "排序",
        reset: "还原",
        confirm: "确定",
        unnamed: "未命名"
      },
      search: { title: "查询显示" },
      refresh: { title: "刷新" },
      compact: { title: "紧凑模式" },
      export: { title: "导出" },
      columns: { title: "列设置" }
    },
    search: {
      container: {
        collapseButton: {
          text: {
            collapse: "收起",
            expand: "展开"
          }
        }
      },
      search: { text: "查询" },
      reset: { text: "重置" },
      error: {
        message: "查询表单校验失败"
      }
    },
    pagination: {
      showTotal: "共 {0} 条"
    },
    date: {
      formatter: { to: "至" }
    },
    extends: {
      cropper: {
        reChoose: "重新选择",
        flipX: "上下翻转",
        flipY: "左右翻转",
        reset: "重置"
      },
      fileUploader: {
        text: "文件上传",
        limitTip: "文件数量不能超过 {0}",
        sizeLimitTip: "文件大小不能超过 {0},当前大小：{1}",
        hasUploading: "还有文件正在上传，请等待上传完成，或删除它"
      }
    }
  }
};
var Zi = {
  name: "en",
  fs: {
    component: {
      select: {
        placeholder: "please select"
      }
    },
    addForm: { title: "add" },
    editForm: { title: "edit" },
    viewForm: { title: "view" },
    rowHandle: {
      title: "handle",
      remove: {
        text: "remove",
        confirmTitle: "remove tip",
        confirmMessage: "Are you sure you want to delete this record?",
        success: "delete success!"
      },
      edit: {
        text: "edit"
      },
      view: {
        text: "view"
      }
    },
    form: {
      cancel: "cancel",
      ok: "ok",
      reset: "reset"
    },
    actionbar: { add: "add" },
    toolbar: {
      columnFilter: {
        title: "columns set",
        fixed: "fixed",
        order: "sort",
        reset: "reset",
        confirm: "ok",
        unnamed: "unnamed"
      },
      search: { title: "show search bar" },
      refresh: { title: "refresh" },
      compact: { title: "compact mode" },
      export: { title: "export" },
      columns: { title: "columns set" }
    },
    search: {
      container: {
        collapseButton: {
          text: {
            collapse: "collapse",
            expand: "expand"
          }
        }
      },
      search: { text: "search" },
      reset: { text: "reset" },
      error: {
        message: "form valid error"
      }
    },
    pagination: {
      showTotal: "Total {0} items"
    },
    date: { formatter: { to: "to" } },
    extends: {
      cropper: {
        reChoose: "reChoose",
        flipX: "flipX",
        flipY: "flipY",
        reset: "reset"
      }
    }
  }
};
function es(e, t) {
  let n = lodash_default_default.get(ga, e);
  return n == null ? e : t instanceof Array ? (lodash_default_default.forEach(t, (o, a) => {
    n = n.replace("{" + a + "}", o);
  }), n) : n.replace("{n}", t);
}
var ts = class {
  constructor() {
    te(this, "vueI18nInstance", null);
  }
  t(t, n) {
    return es(t, n);
  }
  setVueI18n(t) {
    if (!t)
      return;
    t.global && (t = t.global);
    const n = t.availableLocales;
    for (const o of n) {
      if (o.startsWith("zh")) {
        const a = t.getLocaleMessage(o), r = lodash_default_default.cloneDeep(a.fs || {});
        t.mergeLocaleMessage(o, { fs: ga.fs }), t.mergeLocaleMessage(o, { fs: r });
      } else if (o.startsWith("en")) {
        const a = t.getLocaleMessage(o), r = lodash_default_default.cloneDeep(a.fs || {});
        t.mergeLocaleMessage(o, { fs: Zi.fs }), t.mergeLocaleMessage(o, { fs: r });
      }
      ue.debug("i18n", t.getLocaleMessage(o));
    }
    this.vueI18nInstance = t;
  }
};
var io = new ts();
function tt() {
  return io.vueI18nInstance != null ? {
    // @ts-ignore
    t: io.vueI18nInstance.t
  } : { t: io.t };
}
var Oo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $o(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var va = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Oo, function() {
    return function(n, o) {
      var a = o.prototype, r = a.format;
      a.format = function(i) {
        var s = this, u = this.$locale();
        if (!this.isValid())
          return r.bind(this)(i);
        var l2 = this.$utils(), c = (i || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((s.$M + 1) / 3);
            case "Do":
              return u.ordinal(s.$D);
            case "gggg":
              return s.weekYear();
            case "GGGG":
              return s.isoWeekYear();
            case "wo":
              return u.ordinal(s.week(), "W");
            case "w":
            case "ww":
              return l2.s(s.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return l2.s(s.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return l2.s(String(s.$H === 0 ? 24 : s.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(s.$d.getTime() / 1e3);
            case "x":
              return s.$d.getTime();
            case "z":
              return "[" + s.offsetName() + "]";
            case "zzz":
              return "[" + s.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return r.bind(this)(c);
      };
    };
  });
})(va);
var ns = va.exports;
var os = $o(ns);
import_dayjs.default.extend(os);
function Mo(e, t) {
  if (!wr.isEmpty(e))
    return (0, import_dayjs.default)(e).format(t);
}
function ba(e, t = "YYYY-MM-DD HH:mm:ss") {
  if (e != null && e instanceof Array && e.length > 1) {
    if (wr.hasEmpty(e))
      return;
    const { t: n } = tt();
    return `${Mo(e[0], t)} ${n("fs.date.formatter.to")} ${Mo(e[1], t)}`;
  }
  return Mo(e, t);
}
function rs(e) {
  const { value: t } = e;
  return ba(t, "YYYY-MM-DD");
}
function as(e) {
  const { value: t } = e;
  return ba(t, "YYYY-MM-DD HH:mm:ss");
}
var ya = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Oo, function() {
    var n = "week", o = "year";
    return function(a, r, i) {
      var s = r.prototype;
      s.week = function(u) {
        if (u === void 0 && (u = null), u !== null)
          return this.add(7 * (u - this.week()), "day");
        var l2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var c = i(this).startOf(o).add(1, o).date(l2), d = i(this).endOf(n);
          if (c.isBefore(d))
            return 1;
        }
        var f = i(this).startOf(o).date(l2).startOf(n).subtract(1, "millisecond"), h2 = this.diff(f, n, true);
        return h2 < 0 ? i(this).startOf("week").week() : Math.ceil(h2);
      }, s.weeks = function(u) {
        return u === void 0 && (u = null), this.week(u);
      };
    };
  });
})(ya);
var is = ya.exports;
var ss = $o(is);
var wa = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Oo, function() {
    return function(n, o) {
      o.prototype.weekday = function(a) {
        var r = this.$locale().weekStart || 0, i = this.$W, s = (i < r ? i + 7 : i) - r;
        return this.$utils().u(a) ? s : this.subtract(s, "day").add(a, "day");
      };
    };
  });
})(wa);
var ls = wa.exports;
var us = $o(ls);
var _a = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Oo, function() {
    return function(n, o, a) {
      var r = o.prototype, i = function(d) {
        return d && (d.indexOf ? d : d.s);
      }, s = function(d, f, h2, v, p) {
        var F = d.name ? d : d.$locale(), _ = i(F[f]), D = i(F[h2]), k = _ || D.map(function(E) {
          return E.slice(0, v);
        });
        if (!p)
          return k;
        var A = F.weekStart;
        return k.map(function(E, $) {
          return k[($ + (A || 0)) % 7];
        });
      }, u = function() {
        return a.Ls[a.locale()];
      }, l2 = function(d, f) {
        return d.formats[f] || function(h2) {
          return h2.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(v, p, F) {
            return p || F.slice(1);
          });
        }(d.formats[f.toUpperCase()]);
      }, c = function() {
        var d = this;
        return { months: function(f) {
          return f ? f.format("MMMM") : s(d, "months");
        }, monthsShort: function(f) {
          return f ? f.format("MMM") : s(d, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return d.$locale().weekStart || 0;
        }, weekdays: function(f) {
          return f ? f.format("dddd") : s(d, "weekdays");
        }, weekdaysMin: function(f) {
          return f ? f.format("dd") : s(d, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(f) {
          return f ? f.format("ddd") : s(d, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(f) {
          return l2(d.$locale(), f);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return c.bind(this)();
      }, a.localeData = function() {
        var d = u();
        return { firstDayOfWeek: function() {
          return d.weekStart || 0;
        }, weekdays: function() {
          return a.weekdays();
        }, weekdaysShort: function() {
          return a.weekdaysShort();
        }, weekdaysMin: function() {
          return a.weekdaysMin();
        }, months: function() {
          return a.months();
        }, monthsShort: function() {
          return a.monthsShort();
        }, longDateFormat: function(f) {
          return l2(d, f);
        }, meridiem: d.meridiem, ordinal: d.ordinal };
      }, a.months = function() {
        return s(u(), "months");
      }, a.monthsShort = function() {
        return s(u(), "monthsShort", "months", 3);
      }, a.weekdays = function(d) {
        return s(u(), "weekdays", null, null, d);
      }, a.weekdaysShort = function(d) {
        return s(u(), "weekdaysShort", "weekdays", 3, d);
      }, a.weekdaysMin = function(d) {
        return s(u(), "weekdaysMin", "weekdays", 2, d);
      };
    };
  });
})(_a);
var cs = _a.exports;
var ds = $o(cs);
import_dayjs.default.extend(us);
import_dayjs.default.extend(ds);
import_dayjs.default.extend(ss);
function fs() {
  const e = l.get();
  function t(o) {
    const { row: a, key: r, value: i } = o;
    i != null && (e.type === "naive" ? a[r] = (0, import_dayjs.default)(i).valueOf() : e.type === "antdv" && e.version === "4" || (a[r] = (0, import_dayjs.default)(i)));
  }
  return {
    datetime: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("datetime"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        width: "170px",
        component: { name: "fs-date-format" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    date: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("date"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-MM-DD" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    daterange: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("daterange"),
          vModel: e.datePicker.modelValue
        }
      },
      column: { width: 210, formatter: rs },
      valueBuilder({ row: o, key: a, value: r }) {
        r != null && Array.isArray(r) && r.length === 2 && r != null && (e.type === "naive" ? o[a] = [(0, import_dayjs.default)(r[0]).valueOf(), (0, import_dayjs.default)(r[1]).valueOf()] : o[a] = [(0, import_dayjs.default)(r[0]), (0, import_dayjs.default)(r[1])]);
      }
    },
    datetimerange: {
      form: {
        component: {
          ...e.datePicker.buildDateType("datetimerange"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        width: 340,
        formatter: as
      },
      valueBuilder({ row: o, key: a, value: r }) {
        r != null && Array.isArray(r) && r.length === 2 && (e.type === "naive" ? o[a] = [(0, import_dayjs.default)(r[0]).valueOf(), (0, import_dayjs.default)(r[1]).valueOf()] : o[a] = [(0, import_dayjs.default)(r[0]), (0, import_dayjs.default)(r[1])]);
      }
    },
    time: {
      form: {
        component: {
          //el-time-picker,a-time-picker
          name: e.timePicker.name,
          vModel: e.timePicker.modelValue
        }
      },
      column: {
        width: 100,
        align: "center",
        component: { name: "fs-date-format", format: "HH:mm:ss" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    month: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("month"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-MM" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    week: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("week"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-ww[周]" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    quarter: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("quarter"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-[Q]Q" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    year: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("year"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY" }
      },
      valueBuilder(o) {
        t(o);
      }
    }
  };
}
var hs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: fs
}, Symbol.toStringTag, { value: "Module" }));
function ms() {
  return {
    number: {
      form: { component: { name: "el-input-number", props: {} } },
      align: "center"
    },
    switch: {
      form: { component: { name: "el-switch", props: {} } },
      component: { name: "el-switch", props: {} },
      align: "center"
    },
    slider: {
      form: { component: { name: "el-slider", props: {} } },
      align: "center"
    },
    rate: {
      form: { component: { name: "el-rate", props: {} } },
      align: "center"
    },
    "color-picker": {
      form: { component: { name: "el-color-picker", props: {} } },
      align: "center"
    },
    transfer: {
      form: { component: { name: "el-transfer", props: {} } },
      align: "center"
    },
    autocomplete: {
      form: { component: { name: "el-autocomplete", props: {} } }
    }
  };
}
var ps = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ms
}, Symbol.toStringTag, { value: "Module" }));
function gs() {
  const e = l.get();
  return {
    number: {
      form: {
        component: {
          // el-input-number,a-input-number
          name: e.number.name,
          vModel: e.modelValue
        }
      }
    }
  };
}
var vs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: gs
}, Symbol.toStringTag, { value: "Module" }));
function bs() {
  return {
    "phone-number": {
      form: {
        component: {
          name: "el-phone-number-input"
        }
      },
      column: {
        formatter(e, t, n) {
          let o = "";
          return n != null && (n.callingCode != null ? o += "(+" + n.callingCode + ")" : n.countryCode != null && (o += "(" + n.countryCode + ")"), n.phoneNumber != null && (o += n.phoneNumber)), o;
        }
      }
    }
  };
}
var ys = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: bs
}, Symbol.toStringTag, { value: "Module" }));
function ws() {
  const e = l.get();
  return {
    select: {
      search: { autoSearchTrigger: "change" },
      form: {
        component: {
          name: e.select.name,
          [e.select.clearable]: true
        }
      }
    },
    "dict-select": {
      search: { autoSearchTrigger: "change" },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-dict-select",
          vModel: e.select.modelValue,
          [e.select.clearable]: true
        }
      }
    },
    "table-select": {
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-table-select"
        }
      }
    },
    "dict-radio": {
      search: {
        component: {
          name: "fs-dict-select",
          vModel: e.select.modelValue,
          autoSearchTrigger: "change"
        }
      },
      form: {
        component: {
          name: "fs-dict-radio",
          vModel: e.radioGroup.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    },
    "dict-checkbox": {
      search: {
        component: { name: "fs-dict-select" },
        autoSearchTrigger: "change"
      },
      form: {
        component: {
          name: "fs-dict-checkbox",
          vModel: e.radioGroup.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    },
    "dict-switch": {
      search: {
        component: { name: "fs-dict-select", vModel: e.select.modelValue },
        autoSearchTrigger: "change"
      },
      form: {
        component: {
          name: "fs-dict-switch",
          vModel: e.switch.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    }
  };
}
var _s = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ws
}, Symbol.toStringTag, { value: "Module" }));
function Cs() {
  const e = l.get();
  return {
    text: {
      form: {
        component: {
          // el-input, a-input
          name: e.input.name,
          vModel: e.textArea.modelValue,
          [e.input.clearable]: true
        }
      },
      search: {
        autoSearchTrigger: "enter"
      }
    },
    password: {
      form: {
        component: {
          // el-input / a-input-password
          name: e.inputPassword.name,
          vModel: e.inputPassword.modelValue,
          ...e.inputPassword.passwordType
        }
      },
      search: {
        autoSearchTrigger: "enter"
      }
    },
    textarea: {
      search: {
        component: {
          // el-input / a-input
          name: e.input.name,
          type: "text",
          [e.input.clearable]: true
        },
        autoSearchTrigger: "enter"
      },
      form: {
        component: {
          // el-input / a-textarea
          name: e.textArea.name,
          type: e.textArea.type,
          vModel: e.textArea.modelValue,
          [e.input.clearable]: true
        }
      }
    }
  };
}
var Fs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Cs
}, Symbol.toStringTag, { value: "Module" }));
function Ss() {
  const e = l.get();
  return {
    "dict-tree": {
      search: { autoSearchTrigger: "change" },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-dict-tree",
          vModel: e.treeSelect.modelValue,
          [e.treeSelect.clearable]: true
        }
      }
    }
  };
}
var Es = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ss
}, Symbol.toStringTag, { value: "Module" }));
var Ds = Object.assign({ "./list/assist.ts": Ki, "./list/button.ts": Xi, "./list/cascader.ts": Ji, "./list/date.ts": hs, "./list/el.ts": ps, "./list/number.ts": vs, "./list/phone.ts": ys, "./list/select.ts": _s, "./list/text.ts": Fs, "./list/tree.ts": Es });
var Ca = [];
lodash_default_default.forEach(Ds, (e) => {
  Ca.push(e.default);
});
var Ln = {};
function Rs() {
  return Ln;
}
function ks(e) {
  return Ln[e];
}
function Os(e) {
  for (const t in e)
    Ln[t] = e[t];
}
var dn = {
  getType: ks,
  addTypes: Os,
  getTypes: Rs,
  install() {
    for (const e of Ca)
      lodash_default_default.forEach(e(), (t, n) => {
        Ln[n] = t;
      });
    ue.debug("types installed:", Ln);
  }
};
var $s = defineComponent({
  name: "FsPage",
  setup() {
    const e = ref();
    return onMounted(() => {
      window.getComputedStyle(e.value.parentNode).getPropertyValue("position") !== "relative" && ko.logger.warn(
        "fs-page父节点的position建议为relative,因为fs-page为相对定位（position:absolute），如果样式没有异常，你可以忽略此警告"
      );
    }), {
      pageRef: e
    };
  }
});
var Se = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, a] of t)
    n[o] = a;
  return n;
};
var Ts = {
  ref: "pageRef",
  class: "fs-page"
};
var As = {
  key: 0,
  class: "fs-page-header"
};
var Is = { class: "fs-page-content" };
var Ps = {
  key: 1,
  class: "fs-page-footer"
};
function Vs(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("div", Ts, [
    e.$slots.header != null ? (openBlock(), createElementBlock("div", As, [
      renderSlot(e.$slots, "header")
    ])) : createCommentVNode("", true),
    createBaseVNode("div", Is, [
      renderSlot(e.$slots, "default")
    ]),
    e.$slots.footer != null ? (openBlock(), createElementBlock("div", Ps, [
      renderSlot(e.$slots, "footer")
    ])) : createCommentVNode("", true)
  ], 512);
}
var Ms = Se($s, [["render", Vs]]);
function Jo(e) {
  return e != null && (e instanceof Fa || isRef(e));
}
function jr(e) {
  return Jo(e) && !e.cloneable;
}
function js(e, ...t) {
  function n(a, r) {
    if (r != null && (lodash_default_default.isArray(a) || Jo(r)))
      return r;
  }
  let o = null;
  for (const a of t)
    Jo(a) && (o = a);
  return o || lodash_default_default.mergeWith(e, ...t, n);
}
function Bs(e) {
  if (jr(e))
    return e;
  function t(n) {
    if (jr(n))
      return n;
  }
  return lodash_default_default.cloneDeepWith(e, t);
}
var Fa = class {
  constructor() {
    te(this, "cloneable", false);
  }
  setCloneable(t) {
    this.cloneable = t;
  }
};
function Fe() {
  return {
    merge: js,
    cloneDeep: Bs,
    UnMergeable: Fa
  };
}
var { cloneDeep: Ns } = Fe();
function Ls(e) {
  return e instanceof Cr;
}
function qs(e) {
  return e instanceof To;
}
function Br(e, t, n) {
  const o = {};
  if (e == null)
    return o;
  const a = n ? Ls : qs;
  return pa.forEachDeep(e, (r, i, s, u) => {
    if (a(r)) {
      const l2 = u.path;
      if (t) {
        for (const c of t)
          if (typeof c == "string") {
            if (l2.startsWith(c))
              return false;
          } else if (c instanceof RegExp && c.test(l2))
            return true;
      }
      return o[l2] = r, false;
    }
    return !isShallow(r);
  }, {
    // https://deepdash.io/#eachdeep-foreachdeep
    checkCircular: true
  }), o;
}
function Hs(e, t) {
  if (e == null || Object.keys(e).length <= 0)
    return null;
  const n = {};
  return lodash_default_default.forEach(e, (o, a) => {
    n[a] = o.buildAsyncRef(t);
  }), n;
}
function Ws(e, t) {
  t == null || Object.keys(t).length <= 0 || lodash_default_default.forEach(t, (n, o) => {
    lodash_default_default.set(e, o, n.value == null ? null : n.value);
  });
}
function xs(e, t, n, o) {
  const a = computed(() => {
    const s = e();
    return Br(s, n, false);
  }), r = computed(() => {
    const s = e();
    return Br(s, n, true);
  }), i = Hs(r.value, t);
  return computed(() => {
    let s = e();
    const u = Object.keys(r.value).length, l2 = Object.keys(a.value).length;
    if (u > 0 || l2 > 0) {
      if (s = Ns(s), l2 > 0) {
        const c = t ? t() : {};
        lodash_default_default.forEach(a.value, (d, f) => {
          lodash_default_default.set(s, f, d.computeFn(c));
        });
      }
      u > 0 && Ws(s, i);
    }
    return o ? o(s) : s;
  });
}
var To = class {
  constructor(t) {
    te(this, "computeFn");
    this.computeFn = t;
  }
};
function zs(e) {
  return new To(e);
}
var Cr = class {
  constructor(t) {
    te(this, "watch");
    te(this, "asyncFn");
    te(this, "defaultValue");
    const { asyncFn: n, defaultValue: o } = t;
    this.watch = t.watch, this.asyncFn = n, this.defaultValue = o;
  }
  buildAsyncRef(t) {
    t = t || function() {
    };
    const n = ref(this.defaultValue), o = computed(() => this.watch ? this.watch(t()) : null);
    return watch(() => o.value, async (a) => {
      n.value = await this.asyncFn(a, t());
    }, { immediate: true }), n;
  }
};
function Us(e) {
  return new Cr(e);
}
function an() {
  return {
    ComputeValue: To,
    compute: zs,
    AsyncComputeValue: Cr,
    asyncCompute: Us,
    doComputed: xs
  };
}
var Kt = {
  orderDefault: 1
};
var {
  merge: _t,
  cloneDeep: It
} = Fe();
var En = [];
function Ao(e) {
  lodash_default_default.remove(En, (t) => t.name === e.name), En.push(e), En.sort((t, n) => t.order - n.order), ue.debug("mergeColumnPlugin register success: current:", e, "registered:", En);
}
function Ys(e) {
  var t, n;
  if (e.dict) {
    if ((t = e.column) != null && t.component) {
      const o = It(e.dict);
      e.column.component.dict = _t(o, e.column.component.dict);
    }
    if ((n = e.form) != null && n.component) {
      const o = It(e.dict);
      e.form.component.dict = _t(o, e.form.component.dict);
    }
  }
  return e;
}
function Ks(e) {
  if (!e.type)
    return e;
  let t = [];
  typeof e.type == "string" ? t = [e.type] : e.type instanceof Array && (t = e.type);
  const n = {};
  for (const o of t) {
    const a = dn.getType(o);
    a && _t(n, a);
  }
  return e = _t(n, e), e;
}
var Gs = {
  name: "type",
  handle: Ks,
  order: -2
};
var Xs = {
  name: "dict",
  handle: Ys,
  order: -1
};
var Qs = {
  name: "viewFormUseCellComponent",
  order: 10,
  handle: (e = {}, t = {}) => {
    var a, r;
    if (!((a = t.settings) != null && a.viewFormUseCellComponent))
      return e;
    const o = {
      component: ((r = e.column) == null ? void 0 : r.component) || {}
    };
    return e.type === "text" && (o.render = (i) => {
      const {
        value: s
      } = i;
      return createVNode("span", null, [s]);
    }), _t(e, {
      viewForm: o
    }), e;
  }
};
Ao(Gs);
Ao(Xs);
Ao(Qs);
function Fr(e, t) {
  const n = {};
  return lodash_default_default.forEach(e, (o, a) => {
    if (o.key = a, o.children)
      o.children = Fr(o.children, t);
    else
      for (const r of En)
        o = r.handle(o, t);
    n[a] = o;
  }), n;
}
function Sr(e = {}, t) {
  return lodash_default_default.forEach(t, (n, o) => {
    n.children ? Sr(e, n.children) : e[o] = n;
  }), e;
}
function Er(e = {}, t) {
  return lodash_default_default.forEach(t, (n, o) => {
    n.children ? Er(e, n.children) : e[o] = n;
  }), e;
}
function Js(e) {
  const t = e, n = t.column || {};
  return n.title == null && (n.title = t.title), n.key = t.key, t.children && (n.children = Sa(t.children)), reactive(n);
}
function Sa(e) {
  let t = {};
  return lodash_default_default.forEach(e, (n, o) => {
    t[o] = Js(n);
  }), t = Ea(t), t;
}
function Zs(e) {
  return lodash_default_default.sortBy(e, (t) => t.order ?? Kt.orderDefault);
}
function Ea(e) {
  const t = [];
  for (const a in e) {
    const r = e[a];
    r.key = a, r.children && lodash_default_default.size(r.children) > 0 && (r.children = Ea(r.children)), t.push(r);
  }
  const n = Zs(t), o = {};
  for (const a of n)
    o[a.key] = a;
  return o;
}
function Da(e, t) {
  const n = {};
  return lodash_default_default.forEach(e, (o) => {
    const a = It(o[t]) || {};
    t === "form" && a.title == null && (a.title = o.title), a.key = o.key, n[o.key] = a;
  }), n;
}
function Dn(e, t, n, o) {
  const a = Da(n, t), r = _t(It(e.form), e[t], {
    columns: a
  });
  return o && o(r), r;
}
function el(e, t = "search", n) {
  var s;
  const o = Da(n, t), a = {}, r = ((s = e.settings) == null ? void 0 : s.searchCopyFormProps) ?? ["component", "valueChange", "title", "key", "label", "render"];
  function i(u, l2, c) {
    if (lodash_default_default.includes(r, c) && e.columns[l2]) {
      const f = e.columns[l2][c];
      f && (u[c] = f);
    }
  }
  return lodash_default_default.forEach(It(e.form.columns), (u, l2) => {
    const c = {};
    i(c, l2, "valueResolve"), i(c, l2, "valueBuilder"), a[l2] = _t(c, lodash_default_default.pick(u, r));
  }), _t({
    columns: a
  }, {
    columns: o
  }, e.search);
}
function tl(e, t) {
  const {
    t: n
  } = tt(), {
    merge: o
  } = Fe();
  t = t || {};
  const a = o(Nn.defaultOptions({
    t: n
  }), Nn.commonOptions({
    crudOptions: e,
    context: t,
    crudExpose: null
  }), e), r = Fr(It(a.columns), a), i = Sr({}, r);
  return Dn(a, "form", i);
}
function nl(e) {
  lodash_default_default.forEach(e.columns, (o, a) => {
    o.key = a;
  });
  const t = Fr(It(e.columns), e);
  e.columns = t;
  const n = Sr({}, t);
  return e.table.columns = Sa(It(t)), e.table.columnsMap = Er({}, e.table.columns), _t(e.toolbar, {
    columnsFilter: {
      originalColumns: It(e.table.columns)
    }
  }), e.form = Dn(e, "form", n), e.addForm = Dn(e, "addForm", n), e.editForm = Dn(e, "editForm", n), e.viewForm = Dn(e, "viewForm", n, (o) => {
    lodash_default_default.forEach(o.columns, (a) => {
      a.component || (a.component = {}), a.component.disabled = true;
    });
  }), e.search = el(e, "search", n), e.table.editable && (e.table.editable.addForm = _t(e.addForm.columns, e.table.editable.addForm), e.table.editable.editForm = _t(e.editForm.columns, e.table.editable.editForm)), e;
}
function Zo(e, t) {
  lodash_default_default.forEach(e, (n, o) => {
    n.key || (n.key = o), n.children ? Zo(n.children, t) : t(n, o);
  });
}
function vo(e, t) {
  lodash_default_default.forEach(e, (n, o) => {
    n.key || (n.key = o), n.children ? vo(n.children, t) : t(n, o);
  });
}
function ol() {
  return {
    buildFormOptions: tl,
    buildColumns: nl,
    registerMergeColumnPlugin: Ao,
    forEachColumns: vo
  };
}
var rl = 0;
var jo = {};
async function al(e) {
  const t = e.id || `${rl++}`, n = document.createElement("div");
  return new Promise((o, a) => {
    let r = jo[t];
    r != null && (r.vm.exposed.open(e), o(r));
    const i = createVNode(qn, {
      id: t,
      onClosed() {
        e.id || delete jo[t];
      }
    });
    i.appContext = qn._context, render(i, n), document.body.appendChild(n);
    const u = i.component;
    r = {
      id: t,
      vNode: i,
      vm: u,
      props: i.component.props
    }, jo[t] = r, r.vm.exposed.open(e), o(r.vm.exposed);
  });
}
function il() {
  let e = null;
  try {
    e = inject("use:form:wrapper", () => {
    })();
  } catch (n) {
    ue.warn("cant inject use:form:wrapper，建议在App.vue中使用<fs-form-provider>组件包裹<router-view/>", n);
  }
  let t = null;
  return e == null ? t = async (n) => await al(n) : t = async (n) => await e.open(n), {
    openDialog: t
  };
}
var { merge: Ra } = Fe();
var sl = Ra;
function ll(e) {
  const { crudExpose: t } = e, { crudBinding: n } = t;
  w(), tt();
  const { merge: o } = Fe();
  watch(() => {
    var r, i, s;
    return (s = (i = (r = n.value) == null ? void 0 : r.table) == null ? void 0 : i.editable) == null ? void 0 : s.enabled;
  }, (r) => {
    r ? n.value.table.editable.mode === "row" ? n.value.rowHandle.active = "editRow" : n.value.rowHandle.active = "editable" : n.value.rowHandle.active = "default";
  });
  const a = {
    /**
     * 启用编辑
     * @param opts
     */
    async enable(r, i) {
      const s = n.value.table.editable;
      o(s, { enabled: true }, r), i && i({ editable: s });
    },
    /**
     * 禁用编辑
     */
    disable() {
      var r;
      (r = t.getTableRef()) == null || r.editable.resume(), n.value.table.editable.enabled = false, n.value.rowHandle.active = "default";
    },
    /**
     * 激活所有编辑
     */
    active(r) {
      t.getTableRef().editable.active(r);
    },
    /**
     * 退出编辑
     */
    inactive() {
      t.getTableRef().editable.inactive();
    },
    /**
     * 添加行
     */
    addRow(r) {
      t.getTableRef().editable.addRow(r);
    },
    activeCols(r) {
      t.getTableRef().editable.activeCols(r);
    },
    /**
     * 还原，取消编辑
     */
    resume() {
      t.getTableRef().editable.resume();
    },
    /**
     * 还原，取消编辑,同resume
     */
    cancel() {
      t.getTableRef().editable.cancelAll();
    },
    /**
     * 本地保存，不提交到后台
     */
    persist() {
      t.getTableRef().editable.persist();
    },
    removeRow(r) {
      t.getTableRef().editable.removeRow(r);
    },
    getEditableRow(r) {
      var i, s;
      return (s = (i = t.getTableRef()) == null ? void 0 : i.editable) == null ? void 0 : s.getEditableRow(r);
    },
    async doSaveRow(r) {
      let i = r.editableId;
      i || (i = r.row[n.value.table.editable.rowKey]);
      const s = a.getEditableRow(i);
      await s.save({
        async doSave(u) {
          var h2, v;
          const { isAdd: l2, row: c, setData: d } = u, f = c;
          if (((v = (h2 = n.value) == null ? void 0 : h2.mode) == null ? void 0 : v.name) !== "local")
            try {
              if (s.loading = true, l2) {
                const p = await n.value.request.addRequest({ form: f });
                d(p);
              } else
                await n.value.request.editRequest({ form: f, row: f });
            } finally {
              s.loading = false;
            }
        }
      });
    },
    async doCancelRow(r) {
      let i = r.editableId;
      i || (i = r.row[n.value.table.editable.rowKey]), a.getEditableRow(i).cancel();
    },
    async doRemoveRow(r) {
      let i = r.editableId;
      i || (i = r.row[n.value.table.editable.rowKey]);
      const s = a.getEditableRow(i), u = s.rowData;
      await t.doRemove(r, {
        async handle() {
          s.isAdd || n.value.mode.name === "local" ? a.removeRow(i) : await n.value.request.delRequest({ row: u });
        }
      });
    },
    getInstance() {
      t.getTableRef().editable;
    },
    eachCells(r) {
      var i;
      (i = t.getTableRef().editable) == null || i.eachCells(r);
    },
    eachRows(r) {
      var i;
      (i = t.getTableRef().editable) == null || i.eachRows(r);
    },
    async validate() {
      var r;
      return await ((r = t.getTableRef().editable) == null ? void 0 : r.validate());
    },
    getTableData(r) {
      var i;
      return (i = t.getTableRef().editable) == null ? void 0 : i.getCleanTableData(r);
    },
    getCleanTableData(r) {
      var i;
      return (i = t.getTableRef().editable) == null ? void 0 : i.getCleanTableData(r);
    }
  };
  return a;
}
function ul(e) {
  const { crudRef: t, crudBinding: n } = e, { ui: o } = w(), { t: a } = tt(), r = il();
  function i() {
    t.value == null && ue.warn("crudRef还未初始化，请在onMounted之后调用");
  }
  function s() {
    n.value == null && ue.warn("crudBinding还未初始化，请在useFs或useCrud之后调用");
  }
  const u = {
    crudRef: t,
    crudBinding: n,
    getFormWrapperRef() {
      return t.value.formWrapperRef;
    },
    getFormRef: () => {
      const l2 = u.getFormWrapperRef();
      if (l2 == null || (l2 == null ? void 0 : l2.formRef) == null) {
        ue.error("当前无法获取FormRef，请在编辑对话框已打开的状态下调用此方法，如果是在打开对话框时调用，可以尝试先nextTick");
        return;
      }
      return l2 == null ? void 0 : l2.formRef;
    },
    getFormData: () => {
      const l2 = u.getFormRef();
      return l2 == null ? void 0 : l2.getFormData();
    },
    setFormData: (l2, c) => {
      var d;
      (d = u.getFormRef()) == null || d.setFormData(l2, c);
    },
    getFormComponentRef(l2, c = false) {
      const d = u.getFormRef();
      return d == null ? void 0 : d.getComponentRef(l2, c);
    },
    doValueBuilder(l2, c) {
      c == null && (c = toRaw(n.value.columns)), ue.debug("doValueBuilder ,columns=", c);
      const d = [];
      vo(c, (f) => {
        f.valueBuilder != null && d.push(f);
      }), d.length !== 0 && (lodash_default_default.forEach(l2, (f, h2) => {
        lodash_default_default.forEach(d, (v) => {
          v.valueBuilder({
            value: f[v.key],
            row: f,
            index: h2,
            key: v.key,
            column: v
          });
        }), f.children && isArray_default(f.children) && u.doValueBuilder(f.children, c);
      }), ue.debug("valueBuilder success:", l2));
    },
    doValueResolve({ form: l2 }, c) {
      c == null && (c = toRaw(n.value.columns));
      const d = [];
      vo(c, (f) => {
        f.valueResolve != null && d.push(f);
      }), d.length !== 0 && (ue.debug("doValueResolve ,columns=", c), lodash_default_default.forEach(d, (f) => {
        const h2 = f.key;
        f.valueResolve({
          value: l2[h2],
          row: l2,
          form: l2,
          key: h2,
          column: f
        });
      }), ue.debug("valueResolve success:", l2));
    },
    doSearchValidate() {
      u.getSearchRef().doValidate();
    },
    getSearchFormData() {
      return n.value.search.validatedForm;
    },
    getSearchValidatedFormData() {
      return n.value.search.validatedForm;
    },
    /**
     * {form,mergeForm}
     */
    setSearchFormData(l2) {
      if (l2.mergeForm === false)
        for (const d in n.value.search.validatedForm)
          delete n.value.search.validatedForm[d];
      const { merge: c } = Fe();
      c(n.value.search.validatedForm, l2.form), l2.triggerSearch && u.doRefresh();
    },
    /**
     * 获取search组件ref
     */
    getSearchRef() {
      var l2;
      return i(), (l2 = t.value) == null ? void 0 : l2.getSearchRef();
    },
    buildPageQuery(l2) {
      var p, F;
      const c = l2.page;
      let d = l2.form;
      d == null && (d = lodash_default_default.cloneDeep(u.getSearchValidatedFormData()), (F = (p = n.value) == null ? void 0 : p.search) != null && F.columns && u.doValueResolve({ form: d }, toRaw(n.value.search.columns)));
      let f = l2.sort;
      f == null && (f = n.value.table.sort || {});
      const h2 = { page: c, form: d, sort: f };
      let v = h2;
      return n.value.request.transformQuery && (v = n.value.request.transformQuery(h2)), v;
    },
    async search(l2, c = {}) {
      const d = u.buildPageQuery(l2);
      let f;
      try {
        c.silence !== true && (n.value.table.loading = true), ue.debug("pageRequest", d), f = await n.value.request.pageRequest(d);
      } finally {
        c.silence !== true && (n.value.table.loading = false);
      }
      if (f == null) {
        ue.warn("pageRequest返回结果不能为空");
        return;
      }
      let h2 = f;
      return n.value.request.transformRes && (h2 = n.value.request.transformRes({
        res: f,
        query: d
      })), h2.records && u.doValueBuilder(h2.records), h2;
    },
    getPage() {
      let l2 = {
        currentPage: 1,
        pageSize: 10
      };
      return n.value.pagination && (l2 = {
        currentPage: n.value.pagination[o.pagination.currentPage],
        pageSize: n.value.pagination.pageSize
      }), l2;
    },
    async doRefresh(l2) {
      var F, _;
      if (n.value.request.pageRequest == null)
        return;
      ue.debug("do refresh:", l2), n.value.pagination && l2 != null && l2.goFirstPage && (n.value.pagination[o.pagination.currentPage] = 1);
      const c = u.getPage(), d = await u.search({ page: c }, { silence: l2 == null ? void 0 : l2.silence });
      if (d == null) {
        ue.error("pageRequest返回结构不正确，请配置正确的request.transformRes，期望：{currentPage>0, pageSize>0, total, records:[]},实际返回：", d);
        return;
      }
      const { currentPage: f = c.currentPage || 1, pageSize: h2 = c.pageSize, total: v } = d, { records: p } = d;
      if (p == null || !(p instanceof Array) || v == null || f == null || f <= 0 || isNaN(f) || h2 == null || h2 <= 0 || isNaN(h2)) {
        ue.error("pageRequest返回结构不正确，请配置正确的request.transformRes，期望：{currentPage>0, pageSize>0, total, records:[]},实际返回：", d), ue.info("如果你的不需要分页，也需要按照上面的格式返回，可以让pageSize=99999，然后配置crudOptions.pagination.show=false来隐藏分页组件");
        return;
      }
      n.value.data = p, n.value.pagination && (n.value.pagination[o.pagination.currentPage] = f, n.value.pagination.pageSize = h2, n.value.pagination[o.pagination.total] = v || p.length), (_ = (F = n.value) == null ? void 0 : F.table) != null && _.onRefreshed && n.value.table.onRefreshed({
        data: p
      });
    },
    /**
     * 获取toolbar组件Ref
     */
    getToolbarRef: () => t.value.toolbarRef,
    /**
     * 获取列设置组件Ref
     */
    getColumnsFilterRef: () => u.getToolbarRef().columnsFilterRef,
    /**
     * 获取列设置的原始列配置Ref
     * 可以修改列设置的原始配置
     */
    getColumnsFilterOriginalColumnsRef: () => u.getColumnsFilterRef().original,
    /**
     * 获取列设置的列配置Ref
     * 可以动态修改列设置每列的配置
     */
    getColumnsFilterColumnsRef: () => u.getColumnsFilterRef().columns,
    doPageTurn(l2) {
      n.value.pagination[o.pagination.currentPage] = l2;
    },
    /**
     *
     * @param opts = {
     *   form
     *   goFirstPage =true
     *   mergeForm=false
     * }
     */
    async doSearch(l2) {
      ue.debug("do search:", l2), l2 = Ra({ goFirstPage: true }, l2), l2.goFirstPage && u.doPageTurn(1), l2.form && t.value && (t.value.setSearchFormData(l2), u.setSearchFormData({ form: l2.form, mergeForm: l2.mergeForm, refWarning: false })), await u.doRefresh();
    },
    /**
     * 获取FsTable实例
     */
    getTableRef() {
      var l2;
      return i(), (l2 = t.value) == null ? void 0 : l2.tableRef;
    },
    /**
     * 获取x-Table实例
     */
    getBaseTableRef() {
      const l2 = this.getTableRef();
      if (l2 == null) {
        ue.warn("fs-table还未挂载");
        return;
      }
      return l2.tableRef;
    },
    /**
     * 获取表格数据
     */
    getTableData() {
      return s(), n.value.data;
    },
    setTableData(l2) {
      s(), n.value.data = l2;
    },
    insertTableRow(l2, c) {
      s(), n.value.data.splice(l2, 0, c);
    },
    updateTableRow(l2, c, d = true) {
      d ? n.value.data[l2] = sl(n.value.data[l2], c) : n.value.data[l2] = c;
    },
    removeTableRow(l2) {
      s(), n.value.data.splice(l2, 1);
    },
    removeTableRowByRowKey: (l2, c) => {
      s(), c == null && (c = n.value.data);
      for (let d = 0; d < c.length; d++) {
        const f = c[d];
        if (f[n.value.table.rowKey] === l2)
          return c.splice(d, 1), true;
        if (f.children && isArray_default(f.children) && u.removeTableRowByRowKey(l2, f.children))
          return true;
      }
    },
    getTableDataRow(l2) {
      const c = u.getTableData();
      if (c == null)
        throw new Error("table data is not init");
      if (c.length <= l2)
        throw new Error("index over array length");
      return c[l2];
    },
    /**
     * 选择某一行
     * @param index
     * @param row
     */
    doSelectCurrentRow({ row: l2 }) {
      u.getTableRef().value.setCurrentRow(l2);
    },
    /**
     * 删除行按钮
     * @param context
     * @param opts
     */
    async doRemove(l2, c) {
      var v;
      const d = n.value.table.remove ?? c ?? {};
      try {
        d.confirmFn ? await d.confirmFn(l2) : await o.messageBox.confirm({
          title: d.confirmTitle || a("fs.rowHandle.remove.confirmTitle"),
          message: d.confirmMessage || a("fs.rowHandle.remove.confirmMessage"),
          type: "warn"
        });
      } catch {
        d.onCanceled && await d.onCanceled(l2);
        return;
      }
      let f = null;
      const h2 = ((v = n.value.mode) == null ? void 0 : v.name) === "local";
      c != null && c.handle ? await c.handle(l2) : h2 ? u.removeTableRow(l2 == null ? void 0 : l2.index) : f = await n.value.request.delRequest(l2), d.showSuccessNotification !== false && o.notification.success(a("fs.rowHandle.remove.success")), h2 || d.refreshTable !== false && await u.doRefresh(), d.onRemoved && await d.onRemoved({ ...l2, res: f });
    },
    /**
     *
     * 打开表单对话框
     * @param formOpts ={mode, initialForm: row, index,...formOptions}
     */
    async openDialog(l2) {
      if (l2.newInstance === true && r)
        return await r.openDialog(l2);
      const c = this.getFormWrapperRef();
      return c.open(l2), c;
    },
    async _openDialog(l2, c, d) {
      var F, _;
      const { merge: f } = Fe();
      let h2 = c.row || c[o.tableColumn.row];
      delete c.row, h2 == null && c.index != null && (h2 = u.getTableDataRow(c.index)), (_ = (F = n.value) == null ? void 0 : F.request) != null && _.infoRequest && (h2 = await n.value.request.infoRequest({ mode: l2, row: h2 }));
      const v = {
        mode: l2
      }, p = toRaw(n.value[l2 + "Form"]);
      return f(v, p, { initialForm: h2 }, c, d), await this.openDialog(v);
    },
    async openAdd(l2, c = {}) {
      return this._openDialog("add", l2, c);
    },
    async openEdit(l2, c = {}) {
      return this._openDialog("edit", l2, c);
    },
    async openView(l2, c = {}) {
      return this._openDialog("view", l2, c);
    },
    editable: void 0
  };
  return u.editable = ll({ crudExpose: u }), { expose: u, crudExpose: u };
}
async function cl() {
  const e = await Object.assign({ "./lib/index.ts": () => import("./index-a4f12ae8-22NDRE76.js") });
  let t = null;
  return lodash_default_default.each(e, (o) => {
    t = o;
  }), (await t()).exportUtil;
}
async function dl() {
  const e = await Object.assign({ "./lib/index.ts": () => import("./index-a4f12ae8-22NDRE76.js") });
  let t = null;
  return lodash_default_default.each(e, (o) => {
    t = o;
  }), (await t()).importUtil;
}
function fl({ originalRow: e, row: t, key: n, col: o }) {
  var i;
  const a = e[n], r = (i = o.component) == null ? void 0 : i.dict;
  if (r && a != null) {
    const s = r.getNodesFromDataMap(a);
    if (s != null && s.length > 0) {
      const u = lodash_default_default.map(s, (l2) => r.getLabel(l2) || r.getValue(l2)).join("|");
      u != null && u !== "" && (t[n] = u);
    }
  }
  return t;
}
async function hl(e, t = {}) {
  if (t.server) {
    const l2 = e.getPage(), c = e.buildPageQuery({ page: l2 });
    await t.server(c);
    return;
  }
  const n = e.crudBinding;
  let o = t.columns;
  o == null && (o = [], lodash_default_default.each(n.value.table.columnsMap, (l2) => {
    if (!(t.columnFilter && t.columnFilter(l2) === false) && !(t.onlyShow && unref(l2.show) === false) && l2.exportable !== false && l2.key !== "_index") {
      const c = {
        key: l2.key,
        title: l2.title
      };
      o.push(c);
    }
  }));
  for (const l2 of o) {
    const c = n.value.table.columnsMap[l2.key];
    l2.columnProps = c || {}, t.columnBuilder && t.columnBuilder({ col: l2 });
  }
  const { merge: a } = Fe(), r = await cl(), i = [];
  let s = n.value.data;
  if (t.dataFrom === "search") {
    const l2 = a({
      page: {
        currentPage: 1,
        pageSize: 99999999
      }
    }, n.value.toolbar.export.searchParams);
    s = (await e.search(l2, { silence: true })).records;
  }
  for (const l2 of s) {
    const c = lodash_default_default.cloneDeep(l2);
    lodash_default_default.each(o, (d) => {
      const f = d.columnProps, h2 = {
        row: c,
        originalRow: l2,
        key: d.key,
        col: f,
        exportCol: d
      };
      t.autoUseDictLabel !== false && fl(h2), t.dataFormatter && t.dataFormatter(h2);
    }), i.push(c);
  }
  const u = lodash_default_default.merge({
    columns: o,
    data: i,
    filename: "table",
    noHeader: false,
    separator: ",",
    quoted: false
    //每项数据是否加引号
  }, {
    ...t
  });
  t.fileType === "excel" ? await r.excel(u) : await r.csv(u);
}
async function Bh(e, t) {
  const o = await (await dl()).csv(t.file), a = e.crudBinding;
  t.append === false && (a.value.data.length = 0);
  const r = a.value.table.editable.enabled;
  for (const i of o.data)
    r ? e.editable.addRow({ row: i, active: false }) : a.value.data.push(i);
}
var ka = {};
function ml(e, t) {
  ka[e] = t;
}
function pl(e) {
  return ka[e];
}
ml("rowSelection", (e, t) => {
  const o = t.crudExpose.crudBinding;
  function a() {
    return o.value.table.rowKey || "id";
  }
  const { ui: r } = w();
  if (!e) {
    ue.warn("请配置settings.plugins.rowSelection.props参数");
    return;
  }
  return r.table.buildSelectionCrudOptions({
    crossPage: e.crossPage,
    getRowKey: a,
    getPageData() {
      return o.value.data;
    },
    multiple: e.multiple,
    selectedRowKeys: e.selectedRowKeys,
    onSelectedKeysChanged: async (i) => {
      e.selectedRowKeys.value = [...i], await nextTick(), e.onSelectedChanged && e.onSelectedChanged(e.selectedRowKeys.value);
    }
  });
});
var { merge: jt } = Fe();
function gl(e) {
  e.context == null && (e.context = {});
  const t = l.get(), { t: n } = tt();
  let o = e.crudOptions;
  const a = e.expose || e.crudExpose;
  if (!a)
    throw new Error("crudExpose不能为空，请给useCrud传入{crudExpose}参数");
  const r = a, { crudBinding: i } = r, { doRefresh: s, doValueResolve: u } = r;
  function l2() {
    return {
      pagination: {
        ...t.pagination.onChange({
          setCurrentPage(O) {
            i.value.pagination[t.pagination.currentPage] = O;
          },
          setPageSize(O) {
            i.value.pagination.pageSize = O, i.value.pagination[t.pagination.currentPage] = 1;
          },
          async doAfterChange() {
            return await s();
          }
        })
      }
    };
  }
  function c() {
    return {
      form: {
        async doSubmit(S) {
          var O, B;
          if (S.mode === "edit")
            if (u(S), ((O = o.mode) == null ? void 0 : O.name) === "local")
              r.updateTableRow(S.index, S.form, o.mode.isMergeWhenUpdate);
            else
              return await i.value.request.editRequest(S);
          else if (S.mode === "add")
            if (u(S), ((B = o.mode) == null ? void 0 : B.name) === "local") {
              const x = o.mode.isAppendWhenAdd ? r.getTableData().length : 0;
              r.insertTableRow(x, S.form);
            } else
              return await i.value.request.addRequest(S);
        },
        async onSuccess() {
          s();
        }
      }
    };
  }
  function d() {
    return {
      rowHandle: {
        buttons: {
          remove: {
            click: async (S) => {
              S.row = S[t.tableColumn.row], await r.doRemove(S);
            }
          },
          edit: {
            click: async (S) => {
              S.row = S[t.tableColumn.row], await r.openEdit({
                row: S.row,
                index: S.index
              });
            }
          },
          view: {
            click: async (S) => {
              S.row = S[t.tableColumn.row], await r.openView({
                row: S.row,
                index: S.index
              });
            }
          }
        }
      }
    };
  }
  function f() {
    return {
      search: {
        buttons: {
          search: {
            loading: computed(() => {
              var S, O;
              return (O = (S = i.value) == null ? void 0 : S.table) == null ? void 0 : O.loading;
            })
          }
        },
        on_reset() {
          i.value.table.sort = {}, Zo(i.value.table.columns, (O) => {
            O.sortOrder = false;
          });
          const S = a.getBaseTableRef();
          S != null && S.clearSort && S.clearSort();
        },
        onSearch() {
          a.doRefresh({ goFirstPage: true });
        },
        "onUpdate:form": (S) => {
          i.value.search.form = S;
        },
        "onUpdate:validatedForm": (S) => {
          i.value.search.validatedForm = S;
        },
        "onUpdate:collapse": (S) => {
          i.value.search.collapse = S;
        },
        container: {
          collapse: true,
          "onUpdate:collapse": (S) => {
            i.value.search.container.collapse = S;
          }
        }
      }
    };
  }
  function h2() {
    return {
      tabs: {},
      onTabChange(S) {
        a.setSearchFormData({ form: S }), s();
      }
    };
  }
  function v() {
    const S = ref(false);
    return {
      toolbar: {
        buttons: {
          refresh: {
            type: "primary",
            icon: t.icons.refresh,
            title: n("fs.toolbar.refresh.title"),
            order: 1,
            circle: true,
            click: async () => {
              await a.doRefresh();
            }
          },
          search: {
            type: computed(() => i.value.search.show !== false ? "primary" : "default"),
            icon: t.icons.search,
            title: n("fs.toolbar.search.title"),
            order: 2,
            circle: true,
            click: () => {
              i.value.search.show = !i.value.search.show;
            }
          },
          compact: {
            type: computed(() => i.value.toolbar.compact ? "primary" : "default"),
            icon: t.icons.compact,
            title: n("fs.toolbar.compact.title"),
            order: 3,
            circle: true,
            click: () => {
              i.value.toolbar.compact = !i.value.toolbar.compact;
            }
          },
          export: {
            show: true,
            type: "primary",
            icon: t.icons.export,
            order: 4,
            loading: S,
            title: n("fs.toolbar.export.title"),
            circle: true,
            click: async () => {
              S.value = true;
              try {
                await hl(a, i.value.toolbar.export);
              } finally {
                S.value = false;
              }
            }
          },
          columns: {
            type: "primary",
            icon: t.icons.columnsFilter,
            title: n("fs.toolbar.columns.title"),
            circle: true,
            order: 5
          }
        },
        "onUpdate:columns"(O) {
          const B = i.value.table.columns, x = {};
          lodash_default_default.forEach(O, (Q) => {
            for (const I in B) {
              const M = B[I];
              if (M.key === Q.key) {
                delete M.order, jt(M, Q), x[I] = M;
                return;
              }
            }
          }), i.value.table.columns = x, i.value.table.columnsMap = Er({}, x);
        }
      }
    };
  }
  function p() {
    return {
      table: {
        onSortChange(S) {
          const { isServerSort: O, prop: B, asc: x, order: Q } = S;
          Zo(i.value.table.columns, (M) => {
            M.key === B ? M.sortOrder = Q : M.sortOrder = false;
          });
          const I = i.value.table.sort;
          i.value.table.sort = O ? { prop: B, order: Q, asc: x } : null, (O || I != null) && r.doRefresh();
        }
      }
    };
  }
  function F() {
    return {
      actionbar: {
        buttons: {
          add: {
            click() {
              r.openAdd({});
            }
          }
        }
      }
    };
  }
  function _() {
    const { compute: S } = an();
    return {
      actionbar: {
        buttons: {
          addRow: {
            show: false,
            text: n("fs.actionbar.add"),
            type: "primary",
            click: () => {
              r.editable.addRow();
            }
          }
        }
      },
      rowHandle: {
        group: {
          editable: {
            remove: {
              text: "删除",
              ...t.button.colors("danger"),
              click: async (O) => {
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey];
                await r.editable.doRemoveRow({ editableId: Q, row: x });
              }
            }
          },
          editRow: {
            edit: {
              text: "编辑",
              loading: S((O) => {
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey], I = r.editable.getEditableRow(Q);
                return !!(I != null && I.loading);
              }),
              click: (O) => {
                var I;
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey];
                (I = r.editable.getEditableRow(Q)) == null || I.active();
              },
              show: S((O) => {
                var I, M;
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey];
                return !((M = (I = r.editable) == null ? void 0 : I.getEditableRow(Q)) != null && M.isEditing);
              })
            },
            save: {
              text: "保存",
              loading: false,
              click: async (O) => {
                const { index: B, row: x } = O;
                await r.editable.doSaveRow({ row: x });
              },
              show: S((O) => {
                var I, M;
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey];
                return !!((M = (I = r.editable) == null ? void 0 : I.getEditableRow(Q)) != null && M.isEditing);
              })
            },
            cancel: {
              text: "取消",
              click: async (O) => {
                var Q;
                const { index: B, row: x } = O;
                await ((Q = r.editable) == null ? void 0 : Q.doCancelRow({ row: x }));
              },
              show: S((O) => {
                var I, M;
                const { index: B, row: x } = O, Q = x[i.value.table.editable.rowKey];
                return !!((M = (I = r.editable) == null ? void 0 : I.getEditableRow(Q)) != null && M.isEditing);
              })
            },
            remove: {
              text: "删除",
              ...t.button.colors("danger"),
              click: async (O) => {
                var Q;
                const { index: B, row: x } = O;
                await ((Q = r.editable) == null ? void 0 : Q.doRemoveRow({ row: x }));
              }
            }
          }
        }
      }
    };
  }
  function D(S) {
    S.search.validatedForm = lodash_default_default.cloneDeep(S.search.initialForm);
  }
  function k(S) {
    S = jt(Nn.commonOptions(e), S);
    const O = unref(S.settings);
    if (O) {
      const I = unref(O.plugins);
      lodash_default_default.forEach(I, (M, N) => {
        if (M.enabled === false)
          return;
        let J = M.handle;
        if (J == null && (J = pl(N)), J == null)
          return;
        const Z = M.before, ge = J(M.props, e);
        Z !== false ? S = jt(ge, S) : jt(S, ge);
      });
    }
    const B = jt(Nn.defaultOptions({ t: n }), l2(), c(), d(), f(), h2(), v(), p(), F(), _(), S), { buildColumns: x } = ol(), Q = x(B);
    return D(Q), Q;
  }
  function A(S) {
    i.value = k(S), ue.info("fast-crud inited, crudBinding=", i.value);
  }
  function E(S) {
    const O = jt({}, o, S);
    return A(O), o = O, O;
  }
  A(o);
  function $(S) {
    jt(i.value, S);
  }
  return {
    appendCrudOptions: E,
    resetCrudOptions: A,
    appendCrudBinding: $
  };
}
function Oa(e) {
  const { createCrudOptions: t, crudExposeRef: n } = e, o = e.crudRef || ref(), a = e.crudBinding || ref({}), { crudExpose: r } = ul({ crudRef: o, crudBinding: a });
  n && !n.value && (n.value = r), e.context == null && (e.context = {});
  const i = e.context;
  e.onExpose && e.onExpose({ crudRef: o, crudBinding: a, crudExpose: r, context: i });
  const s = t({
    ...e,
    crudExpose: r,
    expose: r,
    context: i
  });
  function u(l2) {
    const c = { crudExpose: r, ...l2, context: i };
    jt(l2.crudOptions, e.crudOptionsOverride);
    const d = gl(c);
    return {
      ...l2,
      ...d,
      crudRef: o,
      crudExpose: r,
      crudBinding: a,
      context: i
    };
  }
  return s instanceof Promise ? s.then((l2) => u(l2)) : u(s);
}
function vl(e) {
  return Oa(e);
}
function Nh(e) {
  return Oa(e);
}
function Gt(e, t, n = "modelValue") {
  const o = l.get();
  let a = e.dict;
  a && a.prototype && (a.clear(), a = shallowReactive(lodash_default_default.cloneDeep(e.dict)), a.clear());
  function r() {
    return computed(() => {
      let $ = [];
      if (e.options ? $ = e.options : a && a.data != null && (a.data instanceof Array || ko.logger.warn("dict.data类型错误，期望为数组，实际：" + a.data), $ = a.data, e.transformDictData && ($ = e.transformDictData(lodash_default_default.cloneDeep(a.data)))), o.type === "naive") {
        const S = [];
        for (const O of $)
          S.push({
            ...O,
            value: D(O),
            label: A(O)
          });
        return S;
      }
      return $;
    });
  }
  function i() {
    return a;
  }
  const s = inject("get:scope", function() {
  });
  function u() {
    const $ = e[n] || t.attrs[n];
    return {
      ...s(),
      componentRef: l2,
      value: $
    };
  }
  const { proxy: l2 } = getCurrentInstance(), c = async ($ = false) => {
    if (!a)
      return;
    if (a.getNodesByValues) {
      const O = u();
      if (O.value == null)
        return;
      let B = O.value;
      Array.isArray(O.value) || (B = [O.value]), await a.appendByValues(B);
      return;
    }
    if (a.loading)
      return;
    const S = u();
    if ($) {
      await a.reloadDict(S);
      return;
    }
    await a.loadDict(S);
  };
  c();
  const d = async () => {
    await c(true);
  }, f = () => {
    a && a.clear();
  }, h2 = () => {
    a != null && (!a.prototype && !a.cloneable || watch(() => e[n], () => {
      d();
    }));
  };
  (() => {
    watch(() => a == null ? void 0 : a.data, () => {
      const $ = u();
      t.attrs.onDictChange, t.emit("dict-change", { dict: a, ...$ });
    }, {
      immediate: true
    });
  })();
  const p = () => {
    var $;
    return ($ = i()) == null ? void 0 : $.data;
  }, F = ($, S) => {
    let O = S;
    return i() && (O = i()[S]), $[O];
  }, _ = ($, S) => {
    let O = S;
    i() && (O = i()[S]), delete $[O];
  }, D = ($) => F($, "value"), k = ($) => F($, "children"), A = ($) => {
    if (e.labelFormatter)
      return e.labelFormatter($);
    const S = F($, "label");
    return S == null ? "" : String(S);
  };
  return {
    createComputedOptions: r,
    loadDict: c,
    reloadDict: d,
    clearDict: f,
    getDictData: p,
    getDict: i,
    watchValue: h2,
    getValue: D,
    getLabel: A,
    getChildren: k,
    getColor: ($) => F($, "color"),
    removePropValue: _,
    curDict: a
  };
}
var Fn = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date;
var $a = /* @__PURE__ */ new Set();
var er = typeof process == "object" && process ? process : {};
var Ta = (e, t, n, o) => {
  typeof er.emitWarning == "function" ? er.emitWarning(e, t, n, o) : console.error(`[${n}] ${t}: ${e}`);
};
var bo = globalThis.AbortController;
var Nr = globalThis.AbortSignal;
var sa;
if (typeof bo > "u") {
  Nr = class {
    constructor() {
      te(this, "onabort");
      te(this, "_onabort", []);
      te(this, "reason");
      te(this, "aborted", false);
    }
    addEventListener(o, a) {
      this._onabort.push(a);
    }
  }, bo = class {
    constructor() {
      te(this, "signal", new Nr());
      t();
    }
    abort(o) {
      var a, r;
      if (!this.signal.aborted) {
        this.signal.reason = o, this.signal.aborted = true;
        for (const i of this.signal._onabort)
          i(o);
        (r = (a = this.signal).onabort) == null || r.call(a, o);
      }
    }
  };
  let e = ((sa = er.env) == null ? void 0 : sa.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const t = () => {
    e && (e = false, Ta("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
  };
}
var bl = (e) => !$a.has(e);
var Bt = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e);
var Aa = (e) => Bt(e) ? e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? so : null : null;
var so = class extends Array {
  constructor(t) {
    super(t), this.fill(0);
  }
};
var mn;
var Zt = class Zt2 {
  constructor(t, n) {
    te(this, "heap");
    te(this, "length");
    if (!g(Zt2, mn))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new n(t), this.length = 0;
  }
  static create(t) {
    const n = Aa(t);
    if (!n)
      return [];
    le(Zt2, mn, true);
    const o = new Zt2(t, n);
    return le(Zt2, mn, false), o;
  }
  push(t) {
    this.heap[this.length++] = t;
  }
  pop() {
    return this.heap[--this.length];
  }
};
mn = /* @__PURE__ */ new WeakMap(), // private constructor
ve(Zt, mn, false);
var tr = Zt;
var ht;
var at;
var Ft;
var mt;
var pn;
var je;
var pt;
var Be;
var De;
var me;
var Qe;
var it;
var Ke;
var He;
var gt;
var xe;
var $t;
var Tt;
var vt;
var St;
var Wt;
var et;
var Wn;
var or;
var tn;
var At;
var xn;
var st;
var Eo;
var Ia;
var nn;
var gn;
var zn;
var Et;
var Nt;
var Dt;
var Lt;
var Un;
var rr;
var vn;
var lo;
var bn;
var uo;
var Ee;
var Re;
var Yn;
var ar;
var on;
var Rn;
var Or = class Or2 {
  constructor(t) {
    ve(this, Wn);
    ve(this, Eo);
    ve(this, Et);
    ve(this, Dt);
    ve(this, Un);
    ve(this, vn);
    ve(this, bn);
    ve(this, Ee);
    ve(this, Yn);
    ve(this, on);
    ve(this, ht, void 0);
    ve(this, at, void 0);
    ve(this, Ft, void 0);
    ve(this, mt, void 0);
    ve(this, pn, void 0);
    te(this, "ttl");
    te(this, "ttlResolution");
    te(this, "ttlAutopurge");
    te(this, "updateAgeOnGet");
    te(this, "updateAgeOnHas");
    te(this, "allowStale");
    te(this, "noDisposeOnSet");
    te(this, "noUpdateTTL");
    te(this, "maxEntrySize");
    te(this, "sizeCalculation");
    te(this, "noDeleteOnFetchRejection");
    te(this, "noDeleteOnStaleGet");
    te(this, "allowStaleOnFetchAbort");
    te(this, "allowStaleOnFetchRejection");
    te(this, "ignoreFetchAbort");
    ve(this, je, void 0);
    ve(this, pt, void 0);
    ve(this, Be, void 0);
    ve(this, De, void 0);
    ve(this, me, void 0);
    ve(this, Qe, void 0);
    ve(this, it, void 0);
    ve(this, Ke, void 0);
    ve(this, He, void 0);
    ve(this, gt, void 0);
    ve(this, xe, void 0);
    ve(this, $t, void 0);
    ve(this, Tt, void 0);
    ve(this, vt, void 0);
    ve(this, St, void 0);
    ve(this, Wt, void 0);
    ve(this, et, void 0);
    ve(this, tn, () => {
    });
    ve(this, At, () => {
    });
    ve(this, xn, () => {
    });
    ve(this, st, () => false);
    ve(this, nn, (t2) => {
    });
    ve(this, gn, (t2, n2, o2) => {
    });
    ve(this, zn, (t2, n2, o2, a2) => {
      if (o2 || a2)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    const { max: n = 0, ttl: o, ttlResolution: a = 1, ttlAutopurge: r, updateAgeOnGet: i, updateAgeOnHas: s, allowStale: u, dispose: l2, disposeAfter: c, noDisposeOnSet: d, noUpdateTTL: f, maxSize: h2 = 0, maxEntrySize: v = 0, sizeCalculation: p, fetchMethod: F, noDeleteOnFetchRejection: _, noDeleteOnStaleGet: D, allowStaleOnFetchRejection: k, allowStaleOnFetchAbort: A, ignoreFetchAbort: E } = t;
    if (n !== 0 && !Bt(n))
      throw new TypeError("max option must be a nonnegative integer");
    const $ = n ? Aa(n) : Array;
    if (!$)
      throw new Error("invalid max value: " + n);
    if (le(this, ht, n), le(this, at, h2), this.maxEntrySize = v || g(this, at), this.sizeCalculation = p, this.sizeCalculation) {
      if (!g(this, at) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (F !== void 0 && typeof F != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (le(this, pn, F), le(this, Wt, !!F), le(this, Be, /* @__PURE__ */ new Map()), le(this, De, new Array(n).fill(void 0)), le(this, me, new Array(n).fill(void 0)), le(this, Qe, new $(n)), le(this, it, new $(n)), le(this, Ke, 0), le(this, He, 0), le(this, gt, tr.create(n)), le(this, je, 0), le(this, pt, 0), typeof l2 == "function" && le(this, Ft, l2), typeof c == "function" ? (le(this, mt, c), le(this, xe, [])) : (le(this, mt, void 0), le(this, xe, void 0)), le(this, St, !!g(this, Ft)), le(this, et, !!g(this, mt)), this.noDisposeOnSet = !!d, this.noUpdateTTL = !!f, this.noDeleteOnFetchRejection = !!_, this.allowStaleOnFetchRejection = !!k, this.allowStaleOnFetchAbort = !!A, this.ignoreFetchAbort = !!E, this.maxEntrySize !== 0) {
      if (g(this, at) !== 0 && !Bt(g(this, at)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Bt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      oe(this, Eo, Ia).call(this);
    }
    if (this.allowStale = !!u, this.noDeleteOnStaleGet = !!D, this.updateAgeOnGet = !!i, this.updateAgeOnHas = !!s, this.ttlResolution = Bt(a) || a === 0 ? a : 1, this.ttlAutopurge = !!r, this.ttl = o || 0, this.ttl) {
      if (!Bt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      oe(this, Wn, or).call(this);
    }
    if (g(this, ht) === 0 && this.ttl === 0 && g(this, at) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !g(this, ht) && !g(this, at)) {
      const S = "LRU_CACHE_UNBOUNDED";
      bl(S) && ($a.add(S), Ta("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", S, Or2));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(t) {
    return {
      // properties
      starts: g(t, Tt),
      ttls: g(t, vt),
      sizes: g(t, $t),
      keyMap: g(t, Be),
      keyList: g(t, De),
      valList: g(t, me),
      next: g(t, Qe),
      prev: g(t, it),
      get head() {
        return g(t, Ke);
      },
      get tail() {
        return g(t, He);
      },
      free: g(t, gt),
      // methods
      isBackgroundFetch: (n) => {
        var o;
        return oe(o = t, Ee, Re).call(o, n);
      },
      backgroundFetch: (n, o, a, r) => {
        var i;
        return oe(i = t, bn, uo).call(i, n, o, a, r);
      },
      moveToTail: (n) => {
        var o;
        return oe(o = t, on, Rn).call(o, n);
      },
      indexes: (n) => {
        var o;
        return oe(o = t, Et, Nt).call(o, n);
      },
      rindexes: (n) => {
        var o;
        return oe(o = t, Dt, Lt).call(o, n);
      },
      isStale: (n) => {
        var o;
        return g(o = t, st).call(o, n);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return g(this, ht);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return g(this, at);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return g(this, pt);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return g(this, je);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return g(this, pn);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return g(this, Ft);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return g(this, mt);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(t) {
    return g(this, Be).has(t) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const t of oe(this, Et, Nt).call(this))
      g(this, me)[t] !== void 0 && g(this, De)[t] !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield [g(this, De)[t], g(this, me)[t]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const t of oe(this, Dt, Lt).call(this))
      g(this, me)[t] !== void 0 && g(this, De)[t] !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield [g(this, De)[t], g(this, me)[t]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const t of oe(this, Et, Nt).call(this)) {
      const n = g(this, De)[t];
      n !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield n);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const t of oe(this, Dt, Lt).call(this)) {
      const n = g(this, De)[t];
      n !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield n);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const t of oe(this, Et, Nt).call(this))
      g(this, me)[t] !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield g(this, me)[t]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const t of oe(this, Dt, Lt).call(this))
      g(this, me)[t] !== void 0 && !oe(this, Ee, Re).call(this, g(this, me)[t]) && (yield g(this, me)[t]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(t, n = {}) {
    for (const o of oe(this, Et, Nt).call(this)) {
      const a = g(this, me)[o], r = oe(this, Ee, Re).call(this, a) ? a.__staleWhileFetching : a;
      if (r !== void 0 && t(r, g(this, De)[o], this))
        return this.get(g(this, De)[o], n);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(t, n = this) {
    for (const o of oe(this, Et, Nt).call(this)) {
      const a = g(this, me)[o], r = oe(this, Ee, Re).call(this, a) ? a.__staleWhileFetching : a;
      r !== void 0 && t.call(n, r, g(this, De)[o], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(t, n = this) {
    for (const o of oe(this, Dt, Lt).call(this)) {
      const a = g(this, me)[o], r = oe(this, Ee, Re).call(this, a) ? a.__staleWhileFetching : a;
      r !== void 0 && t.call(n, r, g(this, De)[o], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let t = false;
    for (const n of oe(this, Dt, Lt).call(this, { allowStale: true }))
      g(this, st).call(this, n) && (this.delete(g(this, De)[n]), t = true);
    return t;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const t = [];
    for (const n of oe(this, Et, Nt).call(this, { allowStale: true })) {
      const o = g(this, De)[n], a = g(this, me)[n], r = oe(this, Ee, Re).call(this, a) ? a.__staleWhileFetching : a;
      if (r === void 0 || o === void 0)
        continue;
      const i = { value: r };
      if (g(this, vt) && g(this, Tt)) {
        i.ttl = g(this, vt)[n];
        const s = Fn.now() - g(this, Tt)[n];
        i.start = Math.floor(Date.now() - s);
      }
      g(this, $t) && (i.size = g(this, $t)[n]), t.unshift([o, i]);
    }
    return t;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(t) {
    this.clear();
    for (const [n, o] of t) {
      if (o.start) {
        const a = Date.now() - o.start;
        o.start = Fn.now() - a;
      }
      this.set(n, o.value, o);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(t, n, o = {}) {
    var f, h2, v;
    if (n === void 0)
      return this.delete(t), this;
    const { ttl: a = this.ttl, start: r, noDisposeOnSet: i = this.noDisposeOnSet, sizeCalculation: s = this.sizeCalculation, status: u } = o;
    let { noUpdateTTL: l2 = this.noUpdateTTL } = o;
    const c = g(this, zn).call(this, t, n, o.size || 0, s);
    if (this.maxEntrySize && c > this.maxEntrySize)
      return u && (u.set = "miss", u.maxEntrySizeExceeded = true), this.delete(t), this;
    let d = g(this, je) === 0 ? void 0 : g(this, Be).get(t);
    if (d === void 0)
      d = g(this, je) === 0 ? g(this, He) : g(this, gt).length !== 0 ? g(this, gt).pop() : g(this, je) === g(this, ht) ? oe(this, vn, lo).call(this, false) : g(this, je), g(this, De)[d] = t, g(this, me)[d] = n, g(this, Be).set(t, d), g(this, Qe)[g(this, He)] = d, g(this, it)[d] = g(this, He), le(this, He, d), Jn(this, je)._++, g(this, gn).call(this, d, c, u), u && (u.set = "add"), l2 = false;
    else {
      oe(this, on, Rn).call(this, d);
      const p = g(this, me)[d];
      if (n !== p) {
        if (g(this, Wt) && oe(this, Ee, Re).call(this, p) ? p.__abortController.abort(new Error("replaced")) : i || (g(this, St) && ((f = g(this, Ft)) == null || f.call(this, p, t, "set")), g(this, et) && ((h2 = g(this, xe)) == null || h2.push([p, t, "set"]))), g(this, nn).call(this, d), g(this, gn).call(this, d, c, u), g(this, me)[d] = n, u) {
          u.set = "replace";
          const F = p && oe(this, Ee, Re).call(this, p) ? p.__staleWhileFetching : p;
          F !== void 0 && (u.oldValue = F);
        }
      } else
        u && (u.set = "update");
    }
    if (a !== 0 && !g(this, vt) && oe(this, Wn, or).call(this), g(this, vt) && (l2 || g(this, xn).call(this, d, a, r), u && g(this, At).call(this, u, d)), !i && g(this, et) && g(this, xe)) {
      const p = g(this, xe);
      let F;
      for (; F = p == null ? void 0 : p.shift(); )
        (v = g(this, mt)) == null || v.call(this, ...F);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var t;
    try {
      for (; g(this, je); ) {
        const n = g(this, me)[g(this, Ke)];
        if (oe(this, vn, lo).call(this, true), oe(this, Ee, Re).call(this, n)) {
          if (n.__staleWhileFetching)
            return n.__staleWhileFetching;
        } else if (n !== void 0)
          return n;
      }
    } finally {
      if (g(this, et) && g(this, xe)) {
        const n = g(this, xe);
        let o;
        for (; o = n == null ? void 0 : n.shift(); )
          (t = g(this, mt)) == null || t.call(this, ...o);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(t, n = {}) {
    const { updateAgeOnHas: o = this.updateAgeOnHas, status: a } = n, r = g(this, Be).get(t);
    if (r !== void 0) {
      const i = g(this, me)[r];
      if (oe(this, Ee, Re).call(this, i) && i.__staleWhileFetching === void 0)
        return false;
      if (g(this, st).call(this, r))
        a && (a.has = "stale", g(this, At).call(this, a, r));
      else
        return o && g(this, tn).call(this, r), a && (a.has = "hit", g(this, At).call(this, a, r)), true;
    } else
      a && (a.has = "miss");
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(t, n = {}) {
    const { allowStale: o = this.allowStale } = n, a = g(this, Be).get(t);
    if (a !== void 0 && (o || !g(this, st).call(this, a))) {
      const r = g(this, me)[a];
      return oe(this, Ee, Re).call(this, r) ? r.__staleWhileFetching : r;
    }
  }
  async fetch(t, n = {}) {
    const {
      // get options
      allowStale: o = this.allowStale,
      updateAgeOnGet: a = this.updateAgeOnGet,
      noDeleteOnStaleGet: r = this.noDeleteOnStaleGet,
      // set options
      ttl: i = this.ttl,
      noDisposeOnSet: s = this.noDisposeOnSet,
      size: u = 0,
      sizeCalculation: l2 = this.sizeCalculation,
      noUpdateTTL: c = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: h2 = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: v = this.allowStaleOnFetchAbort,
      context: p,
      forceRefresh: F = false,
      status: _,
      signal: D
    } = n;
    if (!g(this, Wt))
      return _ && (_.fetch = "get"), this.get(t, {
        allowStale: o,
        updateAgeOnGet: a,
        noDeleteOnStaleGet: r,
        status: _
      });
    const k = {
      allowStale: o,
      updateAgeOnGet: a,
      noDeleteOnStaleGet: r,
      ttl: i,
      noDisposeOnSet: s,
      size: u,
      sizeCalculation: l2,
      noUpdateTTL: c,
      noDeleteOnFetchRejection: d,
      allowStaleOnFetchRejection: f,
      allowStaleOnFetchAbort: v,
      ignoreFetchAbort: h2,
      status: _,
      signal: D
    };
    let A = g(this, Be).get(t);
    if (A === void 0) {
      _ && (_.fetch = "miss");
      const E = oe(this, bn, uo).call(this, t, A, k, p);
      return E.__returned = E;
    } else {
      const E = g(this, me)[A];
      if (oe(this, Ee, Re).call(this, E)) {
        const x = o && E.__staleWhileFetching !== void 0;
        return _ && (_.fetch = "inflight", x && (_.returnedStale = true)), x ? E.__staleWhileFetching : E.__returned = E;
      }
      const $ = g(this, st).call(this, A);
      if (!F && !$)
        return _ && (_.fetch = "hit"), oe(this, on, Rn).call(this, A), a && g(this, tn).call(this, A), _ && g(this, At).call(this, _, A), E;
      const S = oe(this, bn, uo).call(this, t, A, k, p), B = S.__staleWhileFetching !== void 0 && o;
      return _ && (_.fetch = $ ? "stale" : "refresh", B && $ && (_.returnedStale = true)), B ? S.__staleWhileFetching : S.__returned = S;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(t, n = {}) {
    const { allowStale: o = this.allowStale, updateAgeOnGet: a = this.updateAgeOnGet, noDeleteOnStaleGet: r = this.noDeleteOnStaleGet, status: i } = n, s = g(this, Be).get(t);
    if (s !== void 0) {
      const u = g(this, me)[s], l2 = oe(this, Ee, Re).call(this, u);
      return i && g(this, At).call(this, i, s), g(this, st).call(this, s) ? (i && (i.get = "stale"), l2 ? (i && o && u.__staleWhileFetching !== void 0 && (i.returnedStale = true), o ? u.__staleWhileFetching : void 0) : (r || this.delete(t), i && o && (i.returnedStale = true), o ? u : void 0)) : (i && (i.get = "hit"), l2 ? u.__staleWhileFetching : (oe(this, on, Rn).call(this, s), a && g(this, tn).call(this, s), u));
    } else
      i && (i.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(t) {
    var o, a, r, i;
    let n = false;
    if (g(this, je) !== 0) {
      const s = g(this, Be).get(t);
      if (s !== void 0)
        if (n = true, g(this, je) === 1)
          this.clear();
        else {
          g(this, nn).call(this, s);
          const u = g(this, me)[s];
          oe(this, Ee, Re).call(this, u) ? u.__abortController.abort(new Error("deleted")) : (g(this, St) || g(this, et)) && (g(this, St) && ((o = g(this, Ft)) == null || o.call(this, u, t, "delete")), g(this, et) && ((a = g(this, xe)) == null || a.push([u, t, "delete"]))), g(this, Be).delete(t), g(this, De)[s] = void 0, g(this, me)[s] = void 0, s === g(this, He) ? le(this, He, g(this, it)[s]) : s === g(this, Ke) ? le(this, Ke, g(this, Qe)[s]) : (g(this, Qe)[g(this, it)[s]] = g(this, Qe)[s], g(this, it)[g(this, Qe)[s]] = g(this, it)[s]), Jn(this, je)._--, g(this, gt).push(s);
        }
    }
    if (g(this, et) && ((r = g(this, xe)) != null && r.length)) {
      const s = g(this, xe);
      let u;
      for (; u = s == null ? void 0 : s.shift(); )
        (i = g(this, mt)) == null || i.call(this, ...u);
    }
    return n;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var t, n, o;
    for (const a of oe(this, Dt, Lt).call(this, { allowStale: true })) {
      const r = g(this, me)[a];
      if (oe(this, Ee, Re).call(this, r))
        r.__abortController.abort(new Error("deleted"));
      else {
        const i = g(this, De)[a];
        g(this, St) && ((t = g(this, Ft)) == null || t.call(this, r, i, "delete")), g(this, et) && ((n = g(this, xe)) == null || n.push([r, i, "delete"]));
      }
    }
    if (g(this, Be).clear(), g(this, me).fill(void 0), g(this, De).fill(void 0), g(this, vt) && g(this, Tt) && (g(this, vt).fill(0), g(this, Tt).fill(0)), g(this, $t) && g(this, $t).fill(0), le(this, Ke, 0), le(this, He, 0), g(this, gt).length = 0, le(this, pt, 0), le(this, je, 0), g(this, et) && g(this, xe)) {
      const a = g(this, xe);
      let r;
      for (; r = a == null ? void 0 : a.shift(); )
        (o = g(this, mt)) == null || o.call(this, ...r);
    }
  }
};
ht = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), pn = /* @__PURE__ */ new WeakMap(), je = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), Be = /* @__PURE__ */ new WeakMap(), De = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakMap(), Qe = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), Ke = /* @__PURE__ */ new WeakMap(), He = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), xe = /* @__PURE__ */ new WeakMap(), $t = /* @__PURE__ */ new WeakMap(), Tt = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakMap(), St = /* @__PURE__ */ new WeakMap(), Wt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), Wn = /* @__PURE__ */ new WeakSet(), or = function() {
  const t = new so(g(this, ht)), n = new so(g(this, ht));
  le(this, vt, t), le(this, Tt, n), le(this, xn, (r, i, s = Fn.now()) => {
    if (n[r] = i !== 0 ? s : 0, t[r] = i, i !== 0 && this.ttlAutopurge) {
      const u = setTimeout(() => {
        g(this, st).call(this, r) && this.delete(g(this, De)[r]);
      }, i + 1);
      u.unref && u.unref();
    }
  }), le(this, tn, (r) => {
    n[r] = t[r] !== 0 ? Fn.now() : 0;
  }), le(this, At, (r, i) => {
    if (t[i]) {
      const s = t[i], u = n[i];
      r.ttl = s, r.start = u, r.now = o || a();
      const l2 = r.now - u;
      r.remainingTTL = s - l2;
    }
  });
  let o = 0;
  const a = () => {
    const r = Fn.now();
    if (this.ttlResolution > 0) {
      o = r;
      const i = setTimeout(() => o = 0, this.ttlResolution);
      i.unref && i.unref();
    }
    return r;
  };
  this.getRemainingTTL = (r) => {
    const i = g(this, Be).get(r);
    if (i === void 0)
      return 0;
    const s = t[i], u = n[i];
    if (s === 0 || u === 0)
      return 1 / 0;
    const l2 = (o || a()) - u;
    return s - l2;
  }, le(this, st, (r) => t[r] !== 0 && n[r] !== 0 && (o || a()) - n[r] > t[r]);
}, tn = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), Eo = /* @__PURE__ */ new WeakSet(), Ia = function() {
  const t = new so(g(this, ht));
  le(this, pt, 0), le(this, $t, t), le(this, nn, (n) => {
    le(this, pt, g(this, pt) - t[n]), t[n] = 0;
  }), le(this, zn, (n, o, a, r) => {
    if (oe(this, Ee, Re).call(this, o))
      return 0;
    if (!Bt(a))
      if (r) {
        if (typeof r != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (a = r(o, n), !Bt(a))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return a;
  }), le(this, gn, (n, o, a) => {
    if (t[n] = o, g(this, at)) {
      const r = g(this, at) - t[n];
      for (; g(this, pt) > r; )
        oe(this, vn, lo).call(this, true);
    }
    le(this, pt, g(this, pt) + t[n]), a && (a.entrySize = o, a.totalCalculatedSize = g(this, pt));
  });
}, nn = /* @__PURE__ */ new WeakMap(), gn = /* @__PURE__ */ new WeakMap(), zn = /* @__PURE__ */ new WeakMap(), Et = /* @__PURE__ */ new WeakSet(), Nt = function* ({ allowStale: t = this.allowStale } = {}) {
  if (g(this, je))
    for (let n = g(this, He); !(!oe(this, Un, rr).call(this, n) || ((t || !g(this, st).call(this, n)) && (yield n), n === g(this, Ke))); )
      n = g(this, it)[n];
}, Dt = /* @__PURE__ */ new WeakSet(), Lt = function* ({ allowStale: t = this.allowStale } = {}) {
  if (g(this, je))
    for (let n = g(this, Ke); !(!oe(this, Un, rr).call(this, n) || ((t || !g(this, st).call(this, n)) && (yield n), n === g(this, He))); )
      n = g(this, Qe)[n];
}, Un = /* @__PURE__ */ new WeakSet(), rr = function(t) {
  return t !== void 0 && g(this, Be).get(g(this, De)[t]) === t;
}, vn = /* @__PURE__ */ new WeakSet(), lo = function(t) {
  var r, i;
  const n = g(this, Ke), o = g(this, De)[n], a = g(this, me)[n];
  return g(this, Wt) && oe(this, Ee, Re).call(this, a) ? a.__abortController.abort(new Error("evicted")) : (g(this, St) || g(this, et)) && (g(this, St) && ((r = g(this, Ft)) == null || r.call(this, a, o, "evict")), g(this, et) && ((i = g(this, xe)) == null || i.push([a, o, "evict"]))), g(this, nn).call(this, n), t && (g(this, De)[n] = void 0, g(this, me)[n] = void 0, g(this, gt).push(n)), g(this, je) === 1 ? (le(this, Ke, le(this, He, 0)), g(this, gt).length = 0) : le(this, Ke, g(this, Qe)[n]), g(this, Be).delete(o), Jn(this, je)._--, n;
}, bn = /* @__PURE__ */ new WeakSet(), uo = function(t, n, o, a) {
  const r = n === void 0 ? void 0 : g(this, me)[n];
  if (oe(this, Ee, Re).call(this, r))
    return r;
  const i = new bo(), { signal: s } = o;
  s == null || s.addEventListener("abort", () => i.abort(s.reason), {
    signal: i.signal
  });
  const u = {
    signal: i.signal,
    options: o,
    context: a
  }, l2 = (p, F = false) => {
    const { aborted: _ } = i.signal, D = o.ignoreFetchAbort && p !== void 0;
    if (o.status && (_ && !F ? (o.status.fetchAborted = true, o.status.fetchError = i.signal.reason, D && (o.status.fetchAbortIgnored = true)) : o.status.fetchResolved = true), _ && !D && !F)
      return d(i.signal.reason);
    const k = h2;
    return g(this, me)[n] === h2 && (p === void 0 ? k.__staleWhileFetching ? g(this, me)[n] = k.__staleWhileFetching : this.delete(t) : (o.status && (o.status.fetchUpdated = true), this.set(t, p, u.options))), p;
  }, c = (p) => (o.status && (o.status.fetchRejected = true, o.status.fetchError = p), d(p)), d = (p) => {
    const { aborted: F } = i.signal, _ = F && o.allowStaleOnFetchAbort, D = _ || o.allowStaleOnFetchRejection, k = D || o.noDeleteOnFetchRejection, A = h2;
    if (g(this, me)[n] === h2 && (!k || A.__staleWhileFetching === void 0 ? this.delete(t) : _ || (g(this, me)[n] = A.__staleWhileFetching)), D)
      return o.status && A.__staleWhileFetching !== void 0 && (o.status.returnedStale = true), A.__staleWhileFetching;
    if (A.__returned === A)
      throw p;
  }, f = (p, F) => {
    var D;
    const _ = (D = g(this, pn)) == null ? void 0 : D.call(this, t, r, u);
    _ && _ instanceof Promise && _.then((k) => p(k === void 0 ? void 0 : k), F), i.signal.addEventListener("abort", () => {
      (!o.ignoreFetchAbort || o.allowStaleOnFetchAbort) && (p(void 0), o.allowStaleOnFetchAbort && (p = (k) => l2(k, true)));
    });
  };
  o.status && (o.status.fetchDispatched = true);
  const h2 = new Promise(f).then(l2, c), v = Object.assign(h2, {
    __abortController: i,
    __staleWhileFetching: r,
    __returned: void 0
  });
  return n === void 0 ? (this.set(t, v, { ...u.options, status: void 0 }), n = g(this, Be).get(t)) : g(this, me)[n] = v, v;
}, Ee = /* @__PURE__ */ new WeakSet(), Re = function(t) {
  if (!g(this, Wt))
    return false;
  const n = t;
  return !!n && n instanceof Promise && n.hasOwnProperty("__staleWhileFetching") && n.__abortController instanceof bo;
}, Yn = /* @__PURE__ */ new WeakSet(), ar = function(t, n) {
  g(this, it)[n] = t, g(this, Qe)[t] = n;
}, on = /* @__PURE__ */ new WeakSet(), Rn = function(t) {
  t !== g(this, He) && (t === g(this, Ke) ? le(this, Ke, g(this, Qe)[t]) : oe(this, Yn, ar).call(this, g(this, it)[t], g(this, Qe)[t]), oe(this, Yn, ar).call(this, g(this, He), t), le(this, He, t));
};
var nr = Or;
var Zn = new nr({
  max: 500,
  maxSize: 5e3,
  ttl: 1e3 * 60 * 30,
  sizeCalculation: (e, t) => 1
});
var { UnMergeable: yl } = Fe();
function wl(e) {
  Pa = e;
}
var Pa = async (e) => (ue.warn("请配置 app.use(FsCrud,{dictRequest:(context)=>{ 你的字典请求方法 }})"), []);
var Va = class extends yl {
  //loadDict成功后的通知
  constructor(n) {
    super();
    te(this, "cache", false);
    te(this, "prototype", false);
    te(this, "immediate", true);
    te(this, "url");
    te(this, "getData");
    te(this, "value", "value");
    te(this, "label", "label");
    te(this, "children", "children");
    te(this, "color", "color");
    te(this, "isTree", false);
    te(this, "_data", null);
    te(this, "originalData");
    te(this, "dataMap", {});
    te(this, "loading", false);
    te(this, "custom", {});
    te(this, "getNodesByValues");
    te(this, "onReady");
    te(this, "notifies", []);
    te(this, "_unfetchValues", {});
    Object.defineProperty(this, "loading", {
      value: false,
      enumerable: false
    }), Object.defineProperty(this, "notifies", {
      value: false,
      enumerable: false
    }), Object.defineProperty(this, "originalData", {
      value: null,
      enumerable: false
    }), this.loading = false, lodash_default_default.merge(this, n), n.data != null && (this.originalData = n.data, this.setData(n.data)), this.toMap();
  }
  get data() {
    return this._data;
  }
  set data(n) {
    this._data = n, this.toMap();
  }
  isDynamic() {
    return this.url instanceof Function || this.getData instanceof Function || this.prototype;
  }
  setData(n) {
    this.data = n;
  }
  /**
   * 加载字典
   */
  async _loadDict(n) {
    if (this.data && !n.reload)
      return this.data;
    if (this.loading)
      return this._registerNotify();
    let o = null;
    if (this.getNodesByValues) {
      if (n.value) {
        let a = null;
        this.cache && this.url && (a = this.url + n.value);
        let r = null;
        if (a && (r = Zn.get(a)), r)
          o = r;
        else {
          const i = Array.isArray(n.value) ? n.value : [n.value];
          if (o = await this.getNodesByValues(i, n), o != null && !(o instanceof Array)) {
            ue.error("getNodesByValues需要返回数组，请检查");
            return;
          }
          a && Zn.set(a, o);
        }
      }
    } else if (this.originalData)
      o = this.originalData;
    else {
      this.loading = true;
      try {
        o = await this.getRemoteDictData(n);
      } finally {
        this.loading = false;
      }
    }
    this.data = o, this.onReady && this.onReady({ dict: this, ...n }), this._triggerNotify();
  }
  _triggerNotify() {
    this.notifies && this.notifies.length > 0 && (lodash_default_default.forEach(this.notifies, (n) => {
      n(this.data);
    }), this.notifies.length = 0);
  }
  _registerNotify() {
    let n = null;
    const o = new Promise((a) => {
      n = (r) => {
        a(r);
      };
    });
    return this.notifies || (this.notifies = []), this.notifies.push(n), o;
  }
  /**
   * 加载字典
   * @param context 当prototype=true时会传入
   */
  async loadDict(n) {
    return await this._loadDict({ ...n });
  }
  async reloadDict(n) {
    return await this.loadDict({ ...n, reload: true });
  }
  /**
   * 根据value获取nodes 追加数据
   * @param values
   */
  async appendByValues(n) {
    if (this.getNodesByValues == null) {
      ue.warn("请配置getNodesByValues");
      return;
    }
    for (const a of n)
      this.dataMap[a] || this._unfetchValues[a] || (this._unfetchValues[a] = {
        loading: false,
        value: a
      });
    await nextTick(), await nextTick(), await nextTick();
    const o = [];
    if (lodash_default_default.forEach(this._unfetchValues, (a) => {
      a.loading || (a.loading = true, o.push(a.value));
    }), o.length > 0) {
      const a = await this.getNodesByValues(o);
      this.setData([...this.data || [], ...a]);
      for (const r of o)
        delete this._unfetchValues[r];
      return Object.keys(this._unfetchValues).length === 0 && this._triggerNotify(), this.data;
    } else
      return this._registerNotify();
  }
  clear() {
    this.originalData = null, this.setData(null);
  }
  async getRemoteDictData(n) {
    let o, a, r;
    if (this.url && (r = this.url, r instanceof Function && (r = r({ ...n, dict: this })), a = r), this.getData != null)
      o = async () => await this.getData({ url: r, dict: this, ...n });
    else if (r)
      o = async () => await Pa({ url: r, dict: this });
    else
      return [];
    if (this.cache && a) {
      let i = Zn.get(a);
      if (i == null)
        i = {
          loaded: false,
          loading: true,
          data: void 0,
          callback: []
        }, Zn.set(a, i);
      else {
        if (i.loaded)
          return i.data;
        if (i.loading)
          return new Promise((s) => {
            const u = (l2) => {
              s(l2);
            };
            i.callback.push(u);
          });
      }
      try {
        i.loaded = false, i.loading = true;
        let s = await o();
        s = s || [], s instanceof Array || ue.warn("dict data 格式有误，期望格式为数组，实际格式为：", s), i.data = s, i.loaded = true, i.loading = false;
        for (const u of i.callback)
          u(s);
        return i.callback = [], s;
      } catch (s) {
        i.loading = false, i.loaded = false, ue.error("load dict error:", s);
      }
    }
    return await o();
  }
  toMap() {
    if (this._data == null) {
      this.dataMap = {};
      return;
    }
    const n = {};
    this.data && this.buildMap(n, this.data || []), this.dataMap = n;
  }
  buildMap(n, o) {
    lodash_default_default.forEach(o, (a) => {
      n[this.getValue(a)] = a, this.isTree && this.getChildren(a) && this.buildMap(n, this.getChildren(a));
    });
  }
  getValue(n) {
    return n[this.value];
  }
  getLabel(n) {
    return n[this.label];
  }
  getChildren(n) {
    return n[this.children];
  }
  getColor(n) {
    return n[this.color];
  }
  getDictData() {
    return this.data;
  }
  getDictMap() {
    return this.dataMap;
  }
  getNodeByValue(n) {
    return this.dataMap[n];
  }
  getNodesFromDataMap(n) {
    if (n == null)
      return [];
    lodash_default_default.isArray(n) || (n = [n]);
    const o = [];
    return lodash_default_default.forEach(n, (a) => {
      const r = this.dataMap[a];
      r ? o.push(r) : o.push({ [this.value]: a });
    }), o;
  }
};
function _l(e) {
  const t = shallowReactive(new Va(e));
  return !t.prototype && t.immediate && t.loadDict(), t;
}
function Cl() {
  return {
    dict: _l,
    setDictRequest: wl,
    Dict: Va
  };
}
function Hh() {
  return {
    addTypes: dn.addTypes,
    getType: dn.getType,
    getTypes: dn.getTypes,
    install: dn.install
  };
}
async function Fl(e) {
  await nextTick();
  const t = e.getModal();
  if (t == null)
    return;
  const n = t.querySelector(".ant-modal-header");
  if (n == null)
    return;
  const o = t, r = t.style;
  n.style.cursor = "move", n.onmousedown = (i) => {
    const s = i.clientX, u = i.clientY;
    o.style.transform = "translate(0px, 0px)";
    let l2, c;
    r.left.includes("%") ? (l2 = +document.body.clientWidth * (+r.left.replace(/%/g, "") / 100), c = +document.body.clientHeight * (+r.top.replace(/%/g, "") / 100)) : (l2 = +r.left.replace(/px/g, ""), c = +r.top.replace(/px/g, ""), c = c === 0 ? 100 : c), document.onmousemove = function(d) {
      const f = d.clientX - s, h2 = d.clientY - u;
      o.style.left = `${f + l2}px`, o.style.top = `${h2 + c}px`;
    }, document.onmouseup = function(d) {
      document.onmousemove = null, document.onmouseup = null;
    };
  };
}
async function Sl(e) {
  await nextTick();
  const t = e.getModal();
  if (t == null)
    return;
  const n = t.querySelector(".n-card-header");
  if (n == null)
    return;
  const o = t, r = t.style;
  n.style.cursor = "move", n.onmousedown = (i) => {
    const s = i.clientX, u = i.clientY;
    o.style.transform = "translate(0px, 0px)";
    let l2, c;
    r.left.includes("%") ? (l2 = +document.body.clientWidth * (+r.left.replace(/%/g, "") / 100), c = +document.body.clientHeight * (+r.top.replace(/%/g, "") / 100)) : (l2 = +r.left.replace(/px/g, ""), c = +r.top.replace(/px/g, "")), document.ondrag = async function(d) {
      if (d.clientX == 0 && d.clientY == 0)
        return;
      const f = d.clientX - s, h2 = d.clientY - u;
      o.style.left = `${f + l2}px`, o.style.top = `${h2 + c}px`;
    }, document.ondragend = function(d) {
      document.ondrag = null, document.ondragend = null;
    };
  };
}
async function El(e) {
  const { ui: t } = w();
  t.type === "antdv" ? await Fl(e) : t.type === "element" || await Sl(e);
}
function Dl() {
  return {
    dragModal: El
  };
}
var Rl = {
  logger: {
    off: {
      tableColumns: false
    }
  }
};
var kl = defineComponent({
  name: "FsContainer",
  props: {
    /**
     * 是否固定高度
     */
    fixedHeight: {
      type: Boolean,
      default: true
    },
    /**
     * body的样式
     */
    bodyStyle: {
      type: Object,
      default: () => ({})
    },
    /**
     * inner的样式
     */
    innerStyle: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e, t) {
    const { merge: n } = Fe(), o = computed(() => e.fixedHeight === false ? n({ position: "relative" }, e.innerStyle) : e.innerStyle), a = computed(() => e.fixedHeight === false ? n({ flex: "unset" }, e.bodyStyle) : e.bodyStyle);
    return {
      computedInnerStyle: o,
      computedBodyStyle: a
    };
  }
});
var Ol = { class: "fs-container" };
var $l = { class: "box" };
var Tl = { class: "header" };
var Al = { class: "footer" };
function Il(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("div", Ol, [
    createBaseVNode("div", $l, [
      createBaseVNode("div", {
        class: "inner",
        style: normalizeStyle(e.computedInnerStyle)
      }, [
        createBaseVNode("div", Tl, [
          renderSlot(e.$slots, "header")
        ]),
        createBaseVNode("div", {
          class: "body",
          style: normalizeStyle(e.computedBodyStyle)
        }, [
          renderSlot(e.$slots, "default")
        ], 4),
        createBaseVNode("div", Al, [
          renderSlot(e.$slots, "footer")
        ])
      ], 4)
    ]),
    renderSlot(e.$slots, "box")
  ]);
}
var Pl = Se(kl, [["render", Il]]);
var Vl = defineComponent({
  name: "FsLayoutDefault"
});
var Ml = { class: "fs-crud-header" };
var jl = { class: "fs-header-top" };
var Bl = { class: "fs-header-middle" };
var Nl = { class: "fs-header-bottom" };
var Ll = { class: "fs-crud-footer" };
function ql(e, t, n, o, a, r) {
  const i = resolveComponent("fs-container");
  return openBlock(), createBlock(i, { class: "fs-layout-default" }, {
    header: withCtx(() => [
      createBaseVNode("div", Ml, [
        createBaseVNode("div", jl, [
          renderSlot(e.$slots, "header-top")
        ]),
        renderSlot(e.$slots, "search"),
        createBaseVNode("div", Bl, [
          renderSlot(e.$slots, "header-middle")
        ]),
        renderSlot(e.$slots, "actionbar"),
        renderSlot(e.$slots, "toolbar"),
        createBaseVNode("div", Nl, [
          renderSlot(e.$slots, "header-bottom")
        ]),
        renderSlot(e.$slots, "tabs")
      ])
    ]),
    footer: withCtx(() => [
      createBaseVNode("div", Ll, [
        renderSlot(e.$slots, "footer-top"),
        renderSlot(e.$slots, "pagination"),
        renderSlot(e.$slots, "footer-bottom")
      ])
    ]),
    default: withCtx(() => [
      renderSlot(e.$slots, "default"),
      renderSlot(e.$slots, "table"),
      renderSlot(e.$slots, "form")
    ]),
    _: 3
  });
}
var Hl = Se(Vl, [["render", ql]]);
var Wl = defineComponent({
  name: "FsLayoutCard",
  setup() {
    const e = inject("get:crudBinding"), t = computed(() => {
      var a, r;
      return e == null ? true : (r = (a = e()) == null ? void 0 : a.search) == null ? void 0 : r.show;
    }), { ui: n } = w(), o = ref(n.card.name);
    return {
      searchShow: t,
      cardComponentName: o
    };
  }
});
var xl = { class: "fs-header-top" };
var zl = { class: "fs-header-bottom" };
var Ul = { class: "top-bar" };
var Yl = { class: "top-bar" };
var Kl = { class: "fs-crud-footer" };
function Gl(e, t, n, o, a, r) {
  const i = resolveComponent("fs-container");
  return openBlock(), createBlock(i, { class: "fs-layout-card" }, createSlots({
    default: withCtx(() => [
      createVNode(i, null, {
        header: withCtx(() => [
          renderSlot(e.$slots, "tabs")
        ]),
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(e.cardComponentName), { class: "fs-layout-card-body" }, {
            title: withCtx(() => [
              createBaseVNode("div", Ul, [
                renderSlot(e.$slots, "actionbar"),
                renderSlot(e.$slots, "toolbar")
              ])
            ]),
            header: withCtx(() => [
              createBaseVNode("div", Yl, [
                renderSlot(e.$slots, "actionbar"),
                renderSlot(e.$slots, "toolbar")
              ])
            ]),
            default: withCtx(() => [
              createVNode(i, null, {
                footer: withCtx(() => [
                  createBaseVNode("div", Kl, [
                    renderSlot(e.$slots, "footer-top"),
                    renderSlot(e.$slots, "pagination"),
                    renderSlot(e.$slots, "footer-bottom")
                  ])
                ]),
                default: withCtx(() => [
                  renderSlot(e.$slots, "default"),
                  renderSlot(e.$slots, "table"),
                  renderSlot(e.$slots, "form")
                ]),
                _: 3
              })
            ]),
            _: 3
          }))
        ]),
        _: 3
      })
    ]),
    _: 2
  }, [
    e.searchShow ? {
      name: "header",
      fn: withCtx(() => [
        createBaseVNode("div", xl, [
          renderSlot(e.$slots, "header-top")
        ]),
        (openBlock(), createBlock(resolveDynamicComponent(e.cardComponentName), null, {
          default: withCtx(() => [
            renderSlot(e.$slots, "search")
          ]),
          _: 3
        })),
        createBaseVNode("div", zl, [
          renderSlot(e.$slots, "header-bottom")
        ])
      ]),
      key: "0"
    } : void 0
  ]), 1024);
}
var Xl = Se(Wl, [["render", Gl]]);
function Ql(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
var Jl = defineComponent({
  name: "FsButton",
  inheritAttrs: false,
  props: {
    /**
     * 文字
     */
    text: {
      type: String,
      default: "",
      required: false
    },
    /**
     * 图标
     */
    icon: {
      type: [String, Object, Function],
      default: "",
      required: false
    },
    /**
     * 右边的图标
     */
    iconRight: {
      type: [String, Object, Function],
      default: "",
      required: false
    },
    /**
     * 是否圆形按钮，text需配置为null
     */
    circle: {
      type: Boolean,
      default: false,
      required: false
    },
    /**
     * tooltip配置，为空不显示tooltip
     */
    tooltip: {
      type: Object,
      default: void 0
    },
    /**
     * x-button的配置，当x-button的配置与fs-button的配置有冲突时可以配置在此处
     * 比如：n-button的text
     */
    buttonProps: {
      type: Object,
      default: void 0
    }
  },
  setup(e, t) {
    const {
      ui: n
    } = w(), {
      merge: o
    } = Fe(), a = (l2, c = "fs-button-icon") => {
      if (l2 != null)
        return typeof l2 == "string" ? createVNode(resolveComponent("fs-icon"), {
          icon: l2,
          class: c
        }, null) : typeof l2 == "function" ? l2() : createVNode(resolveComponent("fs-icon"), mergeProps(l2, {
          class: c
        }), null);
    }, r = () => {
      const l2 = e.icon, c = e.iconRight, d = n.type !== "element", f = !d;
      let h2;
      const v = {
        ...t.slots
      };
      (l2 && !d && !f || t.slots.default || e.text || c) && (v.default = () => {
        const D = [];
        return l2 && !d && !f && D.push(a(l2)), t.slots.default && D.push(t.slots.default()), e.text && D.push(e.text), c && D.push(a(c, "fs-button-icon-right")), D;
      }), l2 && (d && !v.icon ? v.icon = () => a(l2) : f && !v.icon && (h2 = a(l2)));
      const p = e.circle ? n.button.circle : {}, F = resolveDynamicComponent(n.button.name), _ = o({
        ...p,
        //icon,
        class: {
          "fs-button": true,
          "is-thin": !e.text && !t.slots.default
        }
      }, {
        ...t.attrs,
        ...e.buttonProps
      });
      return h2 && (_.icon = h2), h(F, _, v);
    };
    if (!e.tooltip)
      return r;
    const i = resolveDynamicComponent(n.tooltip.name), s = computed(() => lodash_default_default.omit(e.tooltip, "slots")), u = n.tooltip.trigger;
    return () => {
      var c;
      const l2 = {
        ...(c = e.tooltip) == null ? void 0 : c.slots,
        [u]: r
      };
      return createVNode(i, s.value, Ql(l2) ? l2 : {
        default: () => [l2]
      });
    };
  }
});
var Zl = defineComponent({
  name: "FsIcon",
  inheritAttrs: false,
  props: {
    /**
     * icon名称
     */
    icon: {
      type: String,
      default: void 0,
      require: true
    }
  },
  setup(e, t) {
    const {
      ui: n
    } = w(), o = computed(() => {
      var r;
      if (e.icon && ((r = e.icon) == null ? void 0 : r.indexOf(":")) >= 0) {
        if (e.icon.startsWith("svg:")) {
          const s = resolveDynamicComponent("FsIconSvg");
          return () => {
            const u = e.icon.replace("svg:", "");
            return createVNode(s, mergeProps({
              class: "fs-icon",
              icon: u
            }, t.attrs), null);
          };
        }
        const i = resolveDynamicComponent("FsIconify");
        return () => createVNode(i, mergeProps({
          class: "fs-icon",
          icon: e.icon
        }, t.attrs), null);
      }
      const a = resolveDynamicComponent(e.icon);
      return typeof a == "string" ? () => createVNode("span", {
        title: "error icon name"
      }, [a]) : n.icon.isComponent ? () => createVNode(a, mergeProps({
        class: "fs-icon"
      }, t.attrs), null) : () => createVNode(resolveComponent("el-icon"), mergeProps({
        class: "fs-icon"
      }, t.attrs), {
        default: () => [createVNode(a, null, null)]
      });
    });
    return () => o.value();
  }
});
var eu = defineComponent({
  name: "FsIconify",
  props: {
    /**
     * 图标名称
     */
    icon: {
      type: String
    },
    /**
     * 旋转
     */
    spin: {
      type: Boolean,
      default: false
    }
  },
  setup(e, t) {
    const n = ref(null), o = async () => {
      if (!e.icon)
        return;
      const a = unref(n);
      if (!a)
        return;
      await nextTick();
      const r = document.createElement("span");
      r.className = "iconify", r.dataset.icon = e.icon, a.textContent = "", a.appendChild(r);
    };
    return watch(() => e.icon, o, { flush: "post" }), onMounted(o), { iconifyRef: n };
  }
});
function tu(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("span", {
    ref: "iconifyRef",
    class: normalizeClass(["fs-iconify", { "fs-iconify-spin": e.spin }])
  }, null, 2);
}
var nu = Se(eu, [["render", tu]]);
var ou = defineComponent({
  name: "FsSvgIcon",
  props: {
    icon: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 16
    },
    spin: {
      type: Boolean,
      default: false
    }
  },
  setup(e) {
    const t = computed(() => `#${e.icon}`), n = computed(() => {
      const { size: o } = e;
      let a = `${o}`;
      return a = `${a.replace("px", "")}px`, {
        width: a,
        height: a
      };
    });
    return { symbolId: t, getStyle: n };
  }
});
var ru = {
  class: "fs-icon-svg-content",
  "aria-hidden": "true"
};
var au = ["xlink:href"];
function iu(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(["fs-icon-svg", e.spin && "fs-icon-spin"])
  }, [
    (openBlock(), createElementBlock("svg", ru, [
      createBaseVNode("use", { "xlink:href": e.symbolId }, null, 8, au)
    ]))
  ], 2);
}
var su = Se(ou, [["render", iu]]);
var lu = defineComponent({
  name: "FsLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    labelAttrs: {
      type: Object,
      default: () => ({})
    },
    contentAttrs: {
      type: Object,
      default: () => ({})
    }
  }
});
var uu = { class: "fs-label" };
function cu(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("div", uu, [
    createBaseVNode("div", mergeProps({ class: "label" }, e.labelAttrs), [
      createTextVNode(toDisplayString(e.label) + " ", 1),
      renderSlot(e.$slots, "label")
    ], 16),
    createBaseVNode("div", mergeProps({ class: "content" }, e.contentAttrs), [
      renderSlot(e.$slots, "default")
    ], 16)
  ]);
}
var du = Se(lu, [["render", cu]]);
var fu = defineComponent({
  name: "FsLoading",
  props: {
    /**
     * 是否loading中
     */
    loading: {},
    icon: {}
  },
  setup(e) {
    const {
      ui: t
    } = w();
    return () => e.loading ? createVNode("div", {
      class: "fs-loading"
    }, [createVNode(resolveComponent("fs-icon"), {
      class: "fs-icon-spin",
      icon: t.icons.refresh
    }, null)]) : null;
  }
});
var hu = defineComponent({
  name: "FsBox"
});
var mu = { class: "fs-box" };
function pu(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("div", mu, [
    renderSlot(e.$slots, "default")
  ]);
}
var gu = Se(hu, [["render", pu]]);
function vu(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
function Lr(e, t) {
  if (e[t] instanceof Array) {
    const n = e[t];
    e[t] = (o) => {
      for (const a of n)
        a(o);
    };
  }
}
var bu = ["div", "span", "a", "p", "pre", "li", "ol", "ul"];
var yu = defineComponent({
  name: "FsComponentRender",
  inheritAttrs: false,
  props: {
    /**
     * modelValue
     */
    modelValue: {},
    /**
     * 组件名称
     */
    name: {},
    /**
     * 插槽
     */
    slots: {
      type: Object
    },
    /**
     * 子元素，同slots
     */
    children: {
      type: Object
    },
    /**
     * 事件监听
     */
    on: {
      type: Object
    },
    /**
     * 同 on
     */
    events: {
      type: Object
    },
    /**
     * 上下文scope
     */
    scope: {
      type: Object
    },
    /**
     * modelValue的属性名
     */
    vModel: {
      type: [String, Object]
    },
    /**
     * 组件参数，会与attrs合并
     */
    props: {},
    /**
     * 自定义render
     */
    render: {},
    /**
     * 当输入框的值上报为undefine时，转为null
     */
    undefineToNull: {
      type: Boolean,
      default: true
    }
  },
  emits: ["update:dict", "update:modelValue", "mounted"],
  setup(e, t) {
    const {
      ui: n
    } = w(), {
      merge: o
    } = Fe();
    provide("get:scope", () => e.scope), onMounted(() => {
      t.emit("mounted", e.scope);
    });
    const a = ref(), r = computed(() => {
      const h2 = {
        name: "modelValue",
        trim: false,
        number: false,
        transform: void 0
      };
      e.vModel && (typeof e.vModel == "string" ? h2.name = e.vModel : o(h2, e.vModel));
      const v = e.modelValue ?? (n.type === "antdv" ? void 0 : null), p = {
        ref: a,
        // scope: props.scope,
        // fix element display false bug
        [h2.name]: v,
        ...e.props
      };
      p["onUpdate:" + h2.name] = (_) => {
        if (_ && (h2.trim && (_ = _.trim()), h2.number)) {
          const D = Number(_);
          isNaN(D) || (_ = D);
        }
        h2.transform && (_ = h2.transform(_)), _ === void 0 && e.undefineToNull && (_ = null), t.emit("update:modelValue", _);
      };
      const F = {
        ...e.events,
        ...e.on
      };
      return lodash_default_default.forEach(F, (_, D) => {
        const k = _;
        D.startsWith("on") || (D = lodash_default_default.camelCase("on_" + D)), p[D] = (A) => k({
          ...e.scope,
          $event: A
        });
      }), p;
    }), i = () => {
      const h2 = {}, v = (p, F) => {
        p instanceof Function ? h2[F] = (_) => p({
          ...e.scope,
          scope: _
        }) : h2[F] = () => p;
      };
      return lodash_default_default.forEach(e.children, v), lodash_default_default.forEach(e.slots, v), h2;
    }, s = computed(() => {
      const h2 = {
        isAsyncComponent: false,
        component: unref(e.name) || n.input.name
      };
      let v = h2.component;
      return bu.includes(v) || (typeof v == "string" && (v = resolveComponent(v)), (v == null ? void 0 : v.name) === "AsyncComponentWrapper" && (h2.isAsyncComponent = true)), h2.component = v, h2;
    }), u = i;
    function l2() {
      return s.value.isAsyncComponent ? d() : c();
    }
    function c() {
      return a.value;
    }
    async function d() {
      const h2 = c();
      return h2 ?? new Promise((v, p) => {
        f(v, p, 0);
      });
    }
    function f(h2, v, p) {
      setTimeout(() => {
        const F = c();
        if (F != null) {
          h2(F);
          return;
        }
        if (p++, p > 20) {
          v(new Error("异步组件加载超时"));
          return;
        }
        f(h2, v, p);
      }, 200);
    }
    return t.expose({
      props: e,
      getTargetRefSync: c,
      getTargetRef: l2,
      getTargetRefAsync: d
    }), () => {
      let h2;
      const v = mergeProps(r.value, t.attrs);
      if (Lr(v, "onChange"), Lr(v, "onBlur"), e.render)
        return e.render({
          ...e.scope,
          attrs: v
        });
      const p = markRaw(s.value.component);
      return createVNode(p, v, vu(h2 = u()) ? h2 : {
        default: () => [h2]
      });
    };
  }
});
var wu = defineComponent({
  name: "FsSlotRender",
  inheritAttrs: false,
  props: {
    /**
     * 插槽
     */
    slots: {
      type: Function
    },
    /**
     * 上下文
     */
    scope: {
      type: Object
    }
  },
  setup(e) {
    return () => e.slots(e.scope);
  }
});
var Ma = defineComponent({
  functional: true,
  name: "FsRender",
  props: {
    renderFunc: {
      type: Function
    },
    scope: {
      type: Object
    }
  },
  setup() {
  },
  render() {
    return this.renderFunc(this.scope);
  }
});
var _u = defineComponent({
  name: "FsForm",
  props: {
    /**
     * 初始表单数据
     **/
    initialForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 字段模版
     * {
     *   key:{
     *     title: "字段名称",
     *     component:{
     *       name:"组件名称"
     *       ...组件参数
     *     }
     *   }
     * }
     * */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 字段分组
     * {
     *   type:'xxx', //分组展示类型
     *   groups:{ //分组数据
     *     groupKey:{ title:'xxx',columns:['fieldKey','fieldKey']}
     *   }
     * }
     */
    group: {
      type: Object,
      default: void 0
    },
    /**
     * 重置表单后的操作
     */
    doReset: {
      type: Function,
      default: void 0
    },
    /**
     * 点击保存按钮，表单校验前执行操作（async）
     */
    beforeValidate: {
      type: Function,
      default: void 0
    },
    /**
     * 表单校验完完成后，提交前处理（async）
     */
    beforeSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 点击保存按钮时执行操作（async）
     */
    doSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 表单提交后处理（async）
     */
    afterSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 插槽内容
     */
    slots: {
      type: Object,
      default: () => ({})
    },
    /**
     * 布局方式【flex|grid】
     */
    display: {
      type: String,
      default: "flex"
      // flex
    },
    /**
     * 序号，编辑时会传入
     */
    index: {
      type: Number,
      default: void 0
    },
    /**
     * 模式 [add,edit,view,自定义]
     */
    mode: {
      type: String,
      default: void 0
    },
    /**
     * a-row配置
     */
    row: {
      type: Object,
      default: void 0
    },
    /**
     * el-col|a-col配置，可配置跨列
     */
    col: {
      type: Object,
      default: void 0
    },
    /**
     * formItem的公共配置
     */
    formItem: {
      type: Object,
      default: void 0
    },
    /**
     * helper位置：{position:'label'}
     */
    helper: {
      type: Object
    },
    watch: {
      type: Function,
      default: null
    }
  },
  emits: ["reset", "submit", "success", "validationError", "value-change", "init"],
  setup(e, t) {
    var z, se;
    const { merge: n } = Fe(), { ui: o } = w(), { AsyncComputeValue: a, doComputed: r } = an(), i = ref(), s = reactive({}), { proxy: u } = getCurrentInstance();
    lodash_default_default.each(e.columns, (C) => {
      C.value != null && (C.value instanceof a || C.value instanceof To) && ue.warn("form.value配置不支持Compute/AsyncCompute类型的动态计算");
    });
    function l2() {
      const C = {};
      return lodash_default_default.each(e.columns, (m, b) => {
        const R = unref(m.value);
        R !== void 0 && lodash_default_default.set(C, b, R);
      }), n(C, lodash_default_default.cloneDeep(e.initialForm)), C;
    }
    const c = l2();
    F(c);
    const d = computed(() => ({
      row: c,
      form: s,
      index: e.index,
      mode: e.mode || "add",
      attrs: t.attrs,
      getComponentRef: $
    }));
    function f() {
      return d.value;
    }
    const h2 = r(() => e.columns, f);
    function v(C) {
      C != null && lodash_default_default.each(e.columns, (m, b) => {
        let R = lodash_default_default.get(C, b);
        m.valueBuilder && m.valueBuilder({
          value: R,
          key: b,
          row: c,
          form: C,
          index: e.index,
          mode: e.mode
        });
      });
    }
    function p() {
      return s;
    }
    function F(C, m = {}) {
      if (v(C), m.mergeForm === false)
        for (const R in s)
          delete s[R];
      n(s, C);
      const { valueChange: b } = m;
      b && lodash_default_default.forEach(e.columns, (R, V) => {
        const ne = s[V];
        k(V, ne);
      });
    }
    function _(...C) {
      return n({}, e.col, ...C);
    }
    function D(C) {
      return { key: C.key, ...d.value };
    }
    v(s);
    function k(C, m) {
      const b = { key: C, value: m, formRef: u, ...d.value, immediate: false };
      t.emit("value-change", b);
      let R = e.columns[C].valueChange;
      R && (R instanceof Function ? R(b) : R.handle && R.handle(b));
    }
    const A = ref({});
    function E(C) {
      return A.value[C];
    }
    function $(C, m = false) {
      var b;
      return (b = E(C)) == null ? void 0 : b.getComponentRef(m);
    }
    const S = ref([]);
    lodash_default_default.forEach((z = e.group) == null ? void 0 : z.groups, (C, m) => {
      C.collapsed !== true && S.value.push(m);
    }), ((se = e.group) == null ? void 0 : se.groupType) === "tabs" && (S.value = S.value.length > 0 ? S.value[0] : null);
    const O = r(
      () => e.group,
      f,
      null,
      (C) => {
        if (!C)
          return {};
        const m = {};
        lodash_default_default.forEach(C == null ? void 0 : C.groups, (V, ne) => {
          lodash_default_default.forEach(V.columns, (ie) => {
            if (h2.value[ie] == null) {
              ko.logger.warn("无效的分组字段：" + ie);
              return;
            }
            m[ie] = ne;
          });
        });
        const b = C.groupType;
        let R = {
          parent: o.collapse.name,
          child: o.collapseItem.name
        };
        return b === "tabs" && (R.parent = o.tabs.name, R.child = o.tabPane.name), n(
          {
            wrapper: R,
            groupedKeys: m
          },
          C
        );
      }
    ), B = computed(() => {
      const C = [];
      return lodash_default_default.forEach(h2.value, (m, b) => {
        var V, ne;
        const R = lodash_default_default.cloneDeep(e.formItem || {});
        m = n(R, m), m.key = b, m.order == null && (m.order = Kt.orderDefault), (((V = O.value) == null ? void 0 : V.groupedKeys) == null || ((ne = O.value) == null ? void 0 : ne.groupedKeys[b]) == null) && C.push(m), m.col = _(m.col);
      }), C.sort((m, b) => m.order - b.order), C;
    });
    function x() {
      return i.value;
    }
    async function Q() {
      const C = l2(), m = lodash_default_default.entries(s);
      for (const b of m) {
        const R = lodash_default_default.get(C, b[0]);
        R == null ? lodash_default_default.unset(s, b[0]) : lodash_default_default.set(s, b[0], R);
      }
      e.doReset && await e.doReset(d.value), t.emit("reset");
    }
    const I = ref(), M = ref({});
    function N(C) {
      var m, b;
      if ((m = O.value) != null && m.groupedKeys)
        for (let R in C) {
          const V = (b = O.value) == null ? void 0 : b.groupedKeys[R];
          V != null && (C["group." + V] = true);
        }
    }
    async function J() {
      const C = { ...d.value, form: s };
      if (e.beforeValidate && await e.beforeValidate(C) === false)
        return false;
      try {
        M.value = {}, await o.form.validateWrap(i.value), I.value = true;
      } catch (R) {
        I.value = false;
        const V = o.form.transformValidateErrors(R);
        throw N(V), M.value = V, t.emit("validationError", d.value), R;
      }
      const m = lodash_default_default.cloneDeep(toRaw(s)), b = { ...d.value, form: m };
      if (ue.debug("form submit", JSON.stringify(s)), lodash_default_default.each(e.columns, (R, V) => {
        let ne = lodash_default_default.get(m, V);
        R.valueResolve && R.valueResolve({
          value: ne,
          key: V,
          ...b
        });
      }), e.beforeSubmit && await e.beforeSubmit(b) === false)
        return false;
      if (lodash_default_default.each(e.columns, (R, V) => {
        R.submit === false && lodash_default_default.unset(m, V);
      }), e.doSubmit) {
        const R = await e.doSubmit(b);
        if (b.res = R, R === false)
          return false;
      }
      return t.emit("submit", b), e.afterSubmit && await e.afterSubmit(b) === false ? false : (t.emit("success", b), b);
    }
    onMounted(() => {
      lodash_default_default.forEach(h2.value, (C, m) => {
        if (C.valueChange == null)
          return;
        let b = C.valueChange;
        if (b && b.immediate === true && b.handle) {
          const R = { key: m, value: s[m], formRef: u, ...d.value, immediate: true };
          b.handle && b.handle(R);
        }
      });
    });
    function Z(C) {
      return !!(C && C.show !== false);
    }
    function ge(C) {
      if (!C.columns)
        return false;
      for (let m of C.columns) {
        if (h2.value[m] == null)
          continue;
        if (Z(h2.value[m]))
          return true;
      }
      return false;
    }
    return e.watch && watch(
      () => s,
      (C, m) => {
        e.watch && e.watch(d.value);
      },
      {
        deep: true,
        immediate: true
      }
    ), t.emit("init", d.value), {
      get: (C, m) => lodash_default_default.get(C, m),
      set: (C, m, b) => {
        lodash_default_default.set(C, m, b), k(m, b);
      },
      ui: o,
      validRef: I,
      errorsRef: M,
      formRef: i,
      computedColumns: h2,
      computedDefaultColumns: B,
      submit: J,
      reset: Q,
      getFormRef: x,
      scope: d,
      buildItemScope: D,
      groupActiveKey: S,
      form: s,
      formItemRefs: A,
      getFormData: p,
      setFormData: F,
      getComponentRef: $,
      mergeCol: _,
      computedGroup: O,
      getContextFn: f,
      formItemShow: Z,
      groupItemShow: ge
    };
  }
});
function Cu(e, t, n, o, a, r) {
  const i = resolveComponent("fs-form-item"), s = resolveComponent("fs-render");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), {
    ref: "formRef",
    class: normalizeClass(["fs-form", {
      "fs-form-grid": e.display === "grid",
      "fs-form-flex": e.display === "flex",
      "fs-form-invalid": e.validRef === false
    }]),
    model: e.form
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), mergeProps({ class: "fs-row" }, e.row), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedDefaultColumns, (u) => (openBlock(), createElementBlock(Fragment, {
            key: u == null ? void 0 : u.key
          }, [
            e.formItemShow(u) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
              key: 0,
              class: "fs-col"
            }, u.col), {
              default: withCtx(() => [
                u.blank !== true ? (openBlock(), createBlock(i, {
                  key: 0,
                  ref_for: true,
                  ref: (l2) => {
                    l2 && (e.formItemRefs[u.key] = l2);
                  },
                  item: u,
                  helper: e.helper,
                  "model-value": e.get(e.form, u.key),
                  "form-slot": e.slots["form_" + u.key],
                  "get-context-fn": e.getContextFn,
                  "onUpdate:modelValue": (l2) => e.set(e.form, u.key, l2)
                }, null, 8, ["item", "helper", "model-value", "form-slot", "get-context-fn", "onUpdate:modelValue"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1040)) : createCommentVNode("", true)
          ], 64))), 128))
        ]),
        _: 1
      }, 16)),
      e.computedGroup.wrapper ? (openBlock(), createBlock(resolveDynamicComponent(e.computedGroup.wrapper.parent), mergeProps({
        key: 0,
        [e.ui.collapse.modelValue]: e.groupActiveKey,
        ["onUpdate:" + e.ui.collapse.modelValue]: t[0] || (t[0] = (u) => e.groupActiveKey = u),
        style: { width: "100%" }
      }, e.computedGroup), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedGroup.groups, (u, l2) => (openBlock(), createElementBlock(Fragment, { key: l2 }, [
            e.groupItemShow(u) ? (openBlock(), createBlock(resolveDynamicComponent(e.computedGroup.wrapper.child), mergeProps({
              key: 0,
              [e.ui.collapse.keyName || ""]: l2
            }, u, {
              class: { "fs-form-group-error": e.errorsRef["group." + l2] }
            }), createSlots({
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), mergeProps({ class: "fs-row" }, e.row), {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(u.columns, (c) => {
                      var d;
                      return openBlock(), createElementBlock(Fragment, { key: c }, [
                        e.formItemShow(e.computedColumns[c]) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                          key: 0,
                          class: "fs-col"
                        }, e.mergeCol(u.col, (d = e.computedColumns[c]) == null ? void 0 : d.col)), {
                          default: withCtx(() => {
                            var f;
                            return [
                              e.computedColumns[c] && ((f = e.computedColumns[c]) == null ? void 0 : f.blank) !== true ? (openBlock(), createBlock(i, {
                                key: 0,
                                ref_for: true,
                                ref: (h2) => {
                                  h2 && (e.formItemRefs[c] = h2);
                                },
                                item: e.computedColumns[c],
                                "model-value": e.get(e.form, c),
                                "form-slot": e.slots["form_" + c],
                                "get-context-fn": e.getContextFn,
                                "onUpdate:modelValue": (h2) => e.set(e.form, c, h2)
                              }, null, 8, ["item", "model-value", "form-slot", "get-context-fn", "onUpdate:modelValue"])) : createCommentVNode("", true)
                            ];
                          }),
                          _: 2
                        }, 1040)) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]),
                  _: 2
                }, 1040))
              ]),
              _: 2
            }, [
              renderList(u.slots, (c, d) => ({
                name: d,
                fn: withCtx((f) => [
                  createVNode(s, {
                    "render-func": c,
                    scope: { ...f, hasError: e.errorsRef["group." + l2] }
                  }, null, 8, ["render-func", "scope"])
                ])
              }))
            ]), 1040, ["class"])) : createCommentVNode("", true)
          ], 64))), 128))
        ]),
        _: 1
      }, 16)) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["class", "model"]);
}
var Fu = Se(_u, [["render", Cu]]);
var Su = defineComponent({
  name: "FsFormItem",
  components: { FsRender: Ma },
  props: {
    /**
     * 表单字段值(v-model)
     */
    modelValue: {},
    /**
     * 字段配置
     */
    item: {
      type: Object,
      default: void 0
    },
    /**
     * 字段组件插槽
     */
    formSlot: {
      type: Function,
      default: void 0
    },
    getContextFn: {
      type: Function,
      default: void 0
    },
    helper: {
      type: [String, Object]
    }
  },
  emits: ["update:modelValue"],
  setup(e, t) {
    const { ui: n } = w(), { merge: o } = Fe(), a = ref(), r = () => {
      const v = e.getContextFn ? e.getContextFn() : {};
      return { value: e.modelValue, key: e.item.key, ...v };
    };
    function i(v) {
      t.emit("update:modelValue", v);
    }
    function s(v = false) {
      var p, F;
      return v ? (p = a.value) == null ? void 0 : p.getTargetRefAsync() : (F = a.value) == null ? void 0 : F.getTargetRef();
    }
    const u = computed(() => {
      var v, p, F;
      return ((p = (v = e.item) == null ? void 0 : v.helper) == null ? void 0 : p.position) || ((F = e.helper) == null ? void 0 : F.position);
    }), l2 = computed(() => {
      var v, p;
      return o({}, (v = e.item.helper) == null ? void 0 : v.tooltip, (p = e.helper) == null ? void 0 : p.tooltip);
    }), c = computed(() => {
      if (e.item != null)
        return e.item.key.indexOf(".") >= 0 ? e.item.key.split(".") : e.item.key;
    }), d = computed(() => e.item.label || e.item.title), f = computed(() => d.value instanceof Function);
    return {
      ui: n,
      updateModelValue: i,
      scopeFunc: r,
      getComponentRef: s,
      componentRenderRef: a,
      computedHelperPosition: u,
      computedHelperTooltip: l2,
      computedKey: c,
      computedLabelIsRender: f,
      computedLabel: d,
      computedLabelRender: () => d.value(r())
    };
  }
});
var Eu = {
  key: 0,
  class: "fs-form-item-label-text"
};
var Du = ["title"];
var Ru = { class: "fs-form-helper-tooltip" };
var ku = { class: "fs-form-item-label-icon" };
var Ou = { class: "fs-form-item-content" };
var $u = { class: "fs-form-item-render" };
var Tu = { class: "fs-form-item-component" };
function Au(e, t, n, o, a, r) {
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-form-helper"), u = resolveComponent("fs-icon"), l2 = resolveComponent("fs-slot-render"), c = resolveComponent("fs-component-render");
  return e.item ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), mergeProps({
    key: 0,
    class: "fs-form-item",
    [e.ui.formItem.prop || ""]: e.computedKey
  }, e.item, {
    path: e.item.key,
    "rule-path": e.item.key
  }), {
    label: withCtx(() => [
      e.computedLabelIsRender ? (openBlock(), createElementBlock("span", Eu, [
        createVNode(i, { "render-func": e.computedLabelRender }, null, 8, ["render-func"])
      ])) : (openBlock(), createElementBlock("span", {
        key: 1,
        class: "fs-form-item-label-text",
        title: e.computedLabel
      }, toDisplayString(e.computedLabel), 9, Du)),
      e.item.helper && e.computedHelperPosition === "label" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.tooltip.name), normalizeProps(mergeProps({ key: 2 }, e.computedHelperTooltip)), {
        [e.ui.tooltip.content]: withCtx(() => [
          createBaseVNode("span", Ru, [
            createVNode(s, {
              helper: e.item.helper,
              scope: e.scopeFunc()
            }, null, 8, ["helper", "scope"])
          ])
        ]),
        [e.ui.tooltip.trigger]: withCtx(() => [
          createBaseVNode("span", ku, [
            createVNode(u, {
              class: "fs-form-item-label-icon-inner",
              icon: e.ui.icons.question
            }, null, 8, ["icon"])
          ])
        ]),
        _: 2
      }, 1040)) : createCommentVNode("", true)
    ]),
    default: withCtx(() => {
      var d;
      return [
        createBaseVNode("div", Ou, [
          e.item.topRender ? (openBlock(), createBlock(i, {
            key: 0,
            "render-func": e.item.topRender,
            scope: e.scopeFunc()
          }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
          createBaseVNode("div", $u, [
            e.item.prefixRender ? (openBlock(), createBlock(i, {
              key: 0,
              "render-func": e.item.prefixRender,
              scope: e.scopeFunc()
            }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
            createBaseVNode("div", Tu, [
              e.formSlot ? (openBlock(), createBlock(l2, {
                key: 0,
                slots: e.formSlot,
                scope: e.scopeFunc()
              }, null, 8, ["slots", "scope"])) : ((d = e.item.component) == null ? void 0 : d.show) !== false ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                e.item.conditionalRender && e.item.conditionalRender.match && e.item.conditionalRender.match(e.scopeFunc()) ? (openBlock(), createBlock(i, {
                  key: 0,
                  "render-func": e.item.conditionalRender.render,
                  scope: e.scopeFunc()
                }, null, 8, ["render-func", "scope"])) : e.item.render ? (openBlock(), createBlock(i, {
                  key: 1,
                  "render-func": e.item.render,
                  scope: e.scopeFunc()
                }, null, 8, ["render-func", "scope"])) : (openBlock(), createBlock(c, mergeProps({
                  key: 2,
                  ref: "componentRenderRef"
                }, e.item.component, {
                  "model-value": e.modelValue,
                  scope: e.scopeFunc(),
                  "onUpdate:modelValue": e.updateModelValue
                }), null, 16, ["model-value", "scope", "onUpdate:modelValue"]))
              ], 64)) : createCommentVNode("", true)
            ]),
            e.item.suffixRender ? (openBlock(), createBlock(i, {
              key: 1,
              "render-func": e.item.suffixRender,
              scope: e.scopeFunc()
            }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true)
          ]),
          e.item.bottomRender ? (openBlock(), createBlock(i, {
            key: 1,
            "render-func": e.item.bottomRender,
            scope: e.scopeFunc()
          }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
          e.item.helper && e.computedHelperPosition !== "label" ? (openBlock(), createBlock(s, {
            key: 2,
            helper: e.item.helper,
            scope: e.scopeFunc()
          }, null, 8, ["helper", "scope"])) : createCommentVNode("", true)
        ])
      ];
    }),
    _: 1
  }, 16, ["path", "rule-path"])) : createCommentVNode("", true);
}
var Iu = Se(Su, [["render", Au]]);
var Pu = defineComponent({
  name: "FsFormHelper",
  props: {
    /**
     * 帮助说明, text: 说明文字, render: function(scope) 自定义渲染
     */
    helper: {
      type: [
        /**
         * text: 说明文字,
         * render: function , 自定义render
         */
        Object,
        /**
         * 说明文本
         */
        String
      ]
    },
    scope: {}
  },
  setup(e) {
  }
});
var Vu = { class: "fs-form-helper" };
var Mu = { key: 0 };
var ju = { key: 2 };
function Bu(e, t, n, o, a, r) {
  const i = resolveComponent("fs-render");
  return openBlock(), createElementBlock("div", Vu, [
    typeof e.helper == "string" ? (openBlock(), createElementBlock("pre", Mu, toDisplayString(e.helper), 1)) : e.helper.render ? (openBlock(), createBlock(i, {
      key: 1,
      "render-func": e.helper.render,
      scope: e.scope
    }, null, 8, ["render-func", "scope"])) : e.helper.text ? (openBlock(), createElementBlock("pre", ju, toDisplayString(e.helper.text), 1)) : createCommentVNode("", true)
  ]);
}
var Nu = Se(Pu, [["render", Bu]]);
function Lu(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
var qn = defineComponent({
  name: "FsFormWrapper",
  props: {
    /**
     * 表单配置
     * {
     *     wrapper:{ //表单包装配置
     *         is: 'el-dialog'//el-dialog|a-modal|el-drawer|a-drawer,
     *         draggable: false, //是否支持拖动
     *         inner:false //是否在页面内部打开
     *     }
     *     ...FsForm配置
     * }
     */
    options: {},
    /**
     * 插槽
     */
    slots: {},
    /**
     * 是否在内部打开对话框
     */
    inner: {},
    /**
     * 内部打开对话框的wrapper
     */
    innerWrapper: {},
    id: {},
    zIndex: {}
  },
  emits: ["reset", "submit", "validationError", "value-change", "open", "opened", "mounted", "closed", "inner-change"],
  setup(e, t) {
    const {
      t: n
    } = tt(), {
      merge: o
    } = Fe(), a = ref(false), r = ref(), i = ref(), s = ref(), u = ref(), l2 = ref(), c = ref(false), d = ref(), f = ref(), h2 = ref(), v = e.id || Math.floor(Math.random() * 1e6) + "", p = "fs-form-wrapper_" + v, F = ref({});
    function _() {
      return {
        wrapper: s.value,
        options: i.value,
        formRef: l2.value,
        form: B(),
        wrapperBindRef: s,
        formOptionsRef: i,
        setFormData: x,
        getFormData: B,
        close: k,
        toggleFullscreen: N,
        submit: S
      };
    }
    const D = async (z) => {
      var b;
      const {
        wrapper: se
      } = z;
      se.onOpen && se.onOpen(z), h2.value = se.title, r.value = z.wrapper.is, u.value = se;
      const C = J.formWrapper.customClass(r.value), m = `fs-form-wrapper ${p} ${se[C] || ""} `;
      return s.value = {
        ...lodash_default_default.omit(se, "title", "onOpen", "onClosed", "onOpened", "is", "inner"),
        [C]: m
      }, i.value = {
        ...lodash_default_default.omit(z, "wrapper", "slots"),
        slots: {
          ...e.slots,
          ...z.slots
        }
      }, F.value = {
        ...e.slots,
        ...(b = z.wrapper) == null ? void 0 : b.slots
      }, d.value = () => {
        se.onClosed && se.onClosed(_());
      }, f.value = () => {
        se.onOpened && se.onOpened(_());
      }, se.fullscreen != null && (I.value = se.fullscreen), t.emit("inner-change", !!u.value.inner), new Promise(async (R, V) => {
        await nextTick(), a.value = true, await nextTick(), E();
      });
    }, k = () => {
      a.value = false;
    }, A = () => {
      i.value = null, d.value && d.value(), t.emit("closed");
    }, E = () => {
      if (f.value && f.value(), s.value.draggable) {
        const {
          dragModal: z
        } = Dl();
        z({
          getModal: () => document.querySelector(`.${p}`)
        });
      }
    }, $ = (z) => {
      t.emit("value-change", z);
    };
    async function S() {
      c.value = true;
      try {
        if (await l2.value.submit() === false)
          return;
        k();
      } finally {
        c.value = false;
      }
    }
    async function O() {
      await l2.value.reset();
    }
    function B() {
      var z;
      return (z = l2.value) == null ? void 0 : z.getFormData();
    }
    function x(z, se) {
      var C;
      (C = l2.value) == null || C.setFormData(z, se);
    }
    const Q = computed(() => {
      var m;
      const z = {
        cancel: {
          text: n("fs.form.cancel"),
          onClick: () => {
            k();
          }
        },
        reset: {
          text: n("fs.form.reset"),
          onClick: () => {
            O();
          }
        },
        ok: {
          text: n("fs.form.ok"),
          type: "primary",
          onClick: async () => {
            await S();
          },
          loading: c.value
        }
      }, se = o(z, (m = s.value) == null ? void 0 : m.buttons), C = [];
      return lodash_default_default.forEach(se, (b, R) => {
        b.key = R, C.push(b), b.onClick == null && b.click != null && (b.onClick = () => {
          b.click(_());
        });
      }), lodash_default_default.sortBy(C, (b) => b.order ?? Kt.orderDefault);
    });
    onMounted(() => {
      e.options != null && D(e.options), t.emit("mounted", getCurrentInstance().exposed);
    });
    const I = ref(false), M = computed(() => {
      var z;
      return !((z = r.value) != null && z.endsWith("drawer"));
    });
    function N() {
      I.value = !I.value;
    }
    const J = l.get(), Z = computed(() => u.value.inner ? J.formWrapper.buildInnerBind({
      getInnerWrapper() {
        return e.innerWrapper;
      }
    }) : {});
    t.expose({
      formWrapperId: v,
      formWrapperIdClass: p,
      close: k,
      onClosed: A,
      onOpened: E,
      open: D,
      title: h2,
      fullscreenEnabled: M,
      fullscreen: I,
      toggleFullscreen: N,
      formOptions: i,
      formWrapperIs: r,
      formWrapperOpen: a,
      formWrapperBind: s,
      formRef: l2,
      submit: S,
      computedButtons: Q,
      loading: c,
      getFormData: B,
      setFormData: x,
      onValueChange: $,
      innerBind: Z,
      formWrapperSlots: F
    });
    const ge = useSlots();
    return () => {
      if (!s.value)
        return null;
      const z = l.get();
      let se = {};
      const C = {
        ...ge,
        ...F.value
      }, m = (Je, ct, nt = C) => nt[Je] ? nt[Je](ct) : null, b = r.value || "el-dialog";
      if (i.value) {
        const {
          index: Je,
          mode: ct
        } = i.value || {}, nt = {
          _self: this,
          index: Je,
          mode: ct,
          getFormData: B
        };
        se = {
          [z.formWrapper.titleSlotName]: () => {
            let Cn = null;
            return M.value && (Cn = createVNode(resolveComponent("fs-icon"), {
              class: "fs-fullscreen-icon",
              onClick: N,
              icon: I.value ? z.icons.fullScreen : z.icons.unFullScreen
            }, null)), createVNode("div", {
              class: "fs-form-header"
            }, [createVNode("div", {
              class: "fs-form-header-left"
            }, [m("form-header-left", nt), h2.value, m("form-header-right", nt)]), createVNode("div", {
              class: "fs-form-header-action"
            }, [m("form-header-action-left", nt), Cn, m("form-header-action-right", nt)])]);
          },
          default: () => {
            const Cn = [];
            return lodash_default_default.forEach(Q.value, ($r) => {
              $r.show !== false && Cn.push(createVNode(resolveComponent("fs-button"), $r, null));
            }), createVNode("div", {
              class: "fs-form-wrapper-body"
            }, [createVNode("div", {
              class: "fs-form-body"
            }, [m("form-body-top", nt), createVNode(resolveComponent("fs-form"), mergeProps({
              ref: l2
            }, i.value, {
              onValueChange: $
            }), null), m("form-body-bottom", nt)]), createVNode("div", {
              class: "fs-form-footer-btns"
            }, [m("form-footer-left", nt), Cn, m("form-footer-right", nt)])]);
          }
        };
      }
      if (z.formWrapper.hasContentWrap) {
        const Je = z.formWrapper.hasContentWrap(b), ct = se;
        if (Je) {
          const nt = resolveDynamicComponent(Je);
          se = {
            default: () => createVNode(nt, null, Lu(ct) ? ct : {
              default: () => [ct]
            })
          };
        }
      }
      const R = z.formWrapper.visible, V = {
        [R]: a.value,
        ["onUpdate:" + R]: (Je) => {
          a.value = Je;
        }
      }, ne = z.formWrapper.buildOnClosedBind(b, A), ie = z.formWrapper.customClass(b), he = `${I.value ? "fs-fullscreen" : ""} ${s.value[ie] || ""}`, Me = {
        [ie]: he
      }, Ue = {
        fullscreen: I.value
      }, wn = {
        zIndex: s.value.zIndex || e.zIndex
      }, _n = resolveDynamicComponent(b);
      return createVNode(_n, mergeProps(s.value, Me, V, ne, Ue, Z.value, wn), se);
    };
  }
});
var qu = defineComponent({
  name: "FsFormProvider"
});
var Hu = defineComponent({
  ...qu,
  setup(e) {
    const t = ref({});
    return provide("use:form:wrapper", () => ({
      open(n) {
        const o = n.id || Math.floor(Math.random() * 1e6) + "";
        return new Promise((a, r) => {
          t.value[o] = {
            id: o,
            // zIndex: getMaxZIndex() + 1,
            async onMounted(i) {
              await i.open(n), a(i);
            },
            onClosed() {
              n.id || delete t.value[o];
            }
          };
        });
      }
    })), (n, o) => (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(n.$slots, "default"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(t.value, (a) => (openBlock(), createBlock(unref(qn), mergeProps({
        key: a.id
      }, a), null, 16))), 128))
    ], 64));
  }
});
function Wu(e, t) {
  provide("get:columns", () => e.table.columns), provide("update:columns", (n) => {
    t.emit("update:columns", n);
  }), provide("get:crudBinding", () => e);
}
function xu(e, t) {
  const n = ref(), o = () => n.value, a = () => n.value ? n.value.getForm() : (ue.warn("请使用expose.getSearchFormData代替"), {}), r = () => n.value ? n.value.getValidatedForm() : (ue.warn("请使用expose.getSearchValidatedFormData代替"), {});
  function i({ form: s, mergeForm: u = false }) {
    n.value && n.value.setForm(s, u);
  }
  return {
    searchRef: n,
    getSearchRef: o,
    getSearchFormData: a,
    setSearchFormData: i,
    getSearchValidatedFormData: r
  };
}
function zu(e, t, n) {
  return {
    tabsBinding: computed(() => {
      var a, r, i, s, u, l2, c;
      if (t.tabs && t.tabs.show && t.tabs.name) {
        let d = null;
        const f = { ...t.tabs };
        return (a = t.search) != null && a.columns && ((s = (i = (r = t.search) == null ? void 0 : r.columns[t.tabs.name]) == null ? void 0 : i.component) != null && s.dict) && (d = (c = (l2 = (u = t.search) == null ? void 0 : u.columns[t.tabs.name]) == null ? void 0 : l2.component) == null ? void 0 : c.dict, f.value == null && (f.value = d.value), f.label == null && (f.label = d.label), f.options == null && (f.options = d.data || [])), {
          ...f,
          modelValue: t.search.validatedForm && t.search.validatedForm[t.tabs.name],
          "onUpdate:modelValue": (h2) => {
            n.emit("tab-change", { [t.tabs.name]: h2 });
          }
        };
      }
      return {
        show: false
      };
    })
  };
}
function eo(e, t) {
  if (!e)
    return {};
  const n = {};
  return lodash_default_default.forEach(e, (o, a) => {
    a.startsWith(t) && (n[a] = o);
  }), n;
}
function Uu(e, t, { tableRef: n, containerRef: o }) {
  const a = l.get();
  if (a.table.hasMaxHeight(e.table))
    return {};
  if (!a.table.fixedHeaderNeedComputeBodyHeight)
    return {};
  const r = ref(null);
  function i() {
    var f;
    const u = (f = n == null ? void 0 : n.value) == null ? void 0 : f.$el;
    if (u == null || u.querySelector == null)
      return;
    const l2 = u.querySelector(a.table.headerDomSelector);
    if (l2 == null)
      return;
    const c = u.getBoundingClientRect().height, d = l2.getBoundingClientRect().height;
    r.value = c - d - 2 + (e.table.maxHeightAdjust || 0), ue.debug("table max height recomputed ", r.value);
  }
  function s() {
    const u = n.value.$el;
    if (u == null)
      return;
    const l2 = u.parentNode;
    new ResizeObserver(function(d) {
      ue.debug("table resized", d), d.length > 0 && d[0].contentRect.height > 0 && (i(), setTimeout(() => {
        i();
      }, 200), setTimeout(() => {
        i();
      }, 500));
    }).observe(l2);
  }
  return onMounted(async () => {
    await nextTick(), await nextTick(), s();
  }), { maxHeightRef: r, computeBodyHeight: i };
}
function Yu(e, t) {
  const n = l.get(), o = ref(), a = ref(), r = ref(), { maxHeightRef: i, computeBodyHeight: s } = Uu(e, t, { tableRef: o, containerRef: r }), { merge: u } = Fe(), l2 = toRef(e, "table"), c = computed(() => {
    let E = {};
    (i == null ? void 0 : i.value) != null && (E = n.table.buildMaxHeight(i.value));
    const $ = ko.dash.omit(l2, "loading", "columns", "columnsMap");
    return u(E, { ...t.attrs, ...$ });
  }), d = toRef(e, "toolbar"), f = computed(() => eo(t.slots, "cell")), h2 = computed(() => eo(t.slots, "form")), v = computed(() => eo(t.slots, "search")), p = computed(() => eo(t.slots, "toolbar")), F = ref(), _ = computed(() => {
    const E = { compact: e.toolbar.compact !== false };
    return e.customClass && (E[e.customClass] = true), E;
  }), D = ref(), k = ref(false);
  return {
    tableRef: o,
    containerRef: r,
    toolbarRef: a,
    computedTable: c,
    computedToolbar: d,
    computedCellSlots: f,
    formWrapperRef: F,
    isFormInner: k,
    onFormInnerChange: (E) => {
      k.value = E;
    },
    computedFormSlots: h2,
    computedSearchSlots: v,
    computedToolbarSlots: p,
    computeBodyHeight: s,
    computedClass: _,
    innerWrapperRef: D
  };
}
var Ku = defineComponent({
  name: "FsCrud",
  inheritAttrs: false,
  props: {
    /**
     * 表格配置，见FsTable
     */
    table: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 表格数据
     */
    // eslint-disable-next-line vue/require-default-prop
    data: {
      type: Array
    },
    /**
     * 操作列配置，见FsRowHandle
     */
    rowHandle: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 查询框配置，见FsSearch
     */
    search: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 工具条配置，见FsToolbar
     */
    toolbar: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 动作条配置，见FsActionbar
     */
    actionbar: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * tabs filter
     */
    tabs: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 添加表单对话框配置，见FsFormWrapper
     */
    addForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 编辑表单对话框配置，见FsFormWrapper
     */
    editForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 查看表单对话框配置，见FsFormWrapper
     */
    viewForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 翻页配置,支持el-pagination|a-pagination配置
     */
    pagination: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 容器配置，见FsContainer
     */
    container: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * crud包裹容器的class
     */
    customClass: {},
    /**
     * 不要传到fs-table去
     */
    form: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 可选择
     */
    selection: {
      type: Object,
      default() {
        return { show: false };
      }
    }
  },
  emits: ["update:search", "update:compact", "update:columns", "form-value-change", "update:modelValue", "tab-change"],
  setup(e, t) {
    const { ui: n } = w();
    Wu(e, t);
    const o = xu(), a = zu(o, e, t), r = Yu(e, t);
    return {
      ui: n,
      ...o,
      ...r,
      ...a
    };
  }
});
var Gu = { class: "fs-crud-search" };
var Xu = {
  key: 0,
  class: "fs-crud-actionbar"
};
var Qu = {
  key: 0,
  class: "fs-crud-toolbar"
};
var Ju = { class: "fs-crud-pagination" };
var Zu = { class: "fs-pagination-left" };
var ec = { class: "fs-pagination" };
var tc = { class: "fs-pagination-right" };
function nc(e, t, n, o, a, r) {
  var d;
  const i = resolveComponent("fs-actionbar"), s = resolveComponent("fs-toolbar"), u = resolveComponent("fs-tabs-filter"), l2 = resolveComponent("fs-table"), c = resolveComponent("fs-form-wrapper");
  return openBlock(), createBlock(resolveDynamicComponent(((d = e.container) == null ? void 0 : d.is) || "fs-layout-default"), mergeProps({
    ref: "containerRef",
    class: "fs-crud-container"
  }, e.container, { class: e.computedClass }), {
    "header-top": withCtx(() => [
      renderSlot(e.$slots, "header-top")
    ]),
    "header-bottom": withCtx(() => [
      renderSlot(e.$slots, "header-bottom")
    ]),
    "header-middle": withCtx(() => [
      renderSlot(e.$slots, "header-middle")
    ]),
    search: withCtx(() => [
      createBaseVNode("div", Gu, [
        (openBlock(), createBlock(resolveDynamicComponent(e.search.is || "fs-search"), mergeProps({ ref: "searchRef" }, e.search, { slots: e.computedSearchSlots }), null, 16, ["slots"]))
      ])
    ]),
    actionbar: withCtx(() => [
      e.actionbar && e.actionbar.show !== false ? (openBlock(), createElementBlock("div", Xu, [
        renderSlot(e.$slots, "actionbar-left"),
        createVNode(i, normalizeProps(guardReactiveProps(e.actionbar)), null, 16),
        renderSlot(e.$slots, "actionbar-right")
      ])) : createCommentVNode("", true)
    ]),
    toolbar: withCtx(() => [
      e.toolbar && e.toolbar.show !== false ? (openBlock(), createElementBlock("div", Qu, [
        renderSlot(e.$slots, "toolbar-left"),
        createVNode(s, mergeProps({ ref: "toolbarRef" }, e.toolbar, {
          slots: e.computedToolbarSlots,
          columns: e.table.columns
        }), null, 16, ["slots", "columns"]),
        renderSlot(e.$slots, "toolbar-right")
      ])) : createCommentVNode("", true)
    ]),
    tabs: withCtx(() => [
      e.tabsBinding.show ? (openBlock(), createBlock(u, mergeProps({
        key: 0,
        ref: "tabsRef",
        class: "fs-tabs"
      }, e.tabsBinding), null, 16)) : createCommentVNode("", true)
    ]),
    table: withCtx(() => [
      createVNode(l2, mergeProps({
        ref: "tableRef",
        class: "fs-crud-table"
      }, e.computedTable, {
        columns: e.table.columns,
        loading: e.table.loading,
        "row-handle": e.rowHandle,
        data: e.data,
        "cell-slots": e.computedCellSlots
      }), null, 16, ["columns", "loading", "row-handle", "data", "cell-slots"])
    ]),
    form: withCtx(() => [
      createBaseVNode("div", {
        ref: "innerWrapperRef",
        class: normalizeClass(["fs-form-wrapper-container", { "fs-form-inner-wrapper": e.isFormInner }])
      }, [
        createVNode(c, {
          ref: "formWrapperRef",
          slots: e.computedFormSlots,
          "inner-wrapper": e.innerWrapperRef,
          onInnerChange: e.onFormInnerChange,
          onValueChange: t[0] || (t[0] = (f) => e.$emit("form-value-change", f))
        }, null, 8, ["slots", "inner-wrapper", "onInnerChange"])
      ], 2)
    ]),
    pagination: withCtx(() => [
      createBaseVNode("div", Ju, [
        createBaseVNode("div", Zu, [
          renderSlot(e.$slots, "pagination-left")
        ]),
        createBaseVNode("div", ec, [
          e.pagination.show !== false ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.pagination.name), normalizeProps(mergeProps({ key: 0 }, e.pagination)), null, 16)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", tc, [
          renderSlot(e.$slots, "pagination-right")
        ])
      ])
    ]),
    "footer-top": withCtx(() => [
      renderSlot(e.$slots, "footer-top")
    ]),
    "footer-bottom": withCtx(() => [
      renderSlot(e.$slots, "footer-bottom")
    ]),
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
var oc = Se(Ku, [["render", nc]]);
var rc = defineComponent({
  name: "FsRowHandle",
  props: {
    /**
     * 按钮折叠配置
     */
    dropdown: {
      type: Object
    },
    /**
     * 按钮配置
     * {
     *   view:{...FsButton,click:Function,order:1},
     *   edit:{...FsButton,click:Function,order:2},
     *   remove:{...FsButton,click:Function,order:3},
     *   ...自定义
     * }
     */
    buttons: {
      type: Object
    },
    /**
     * 按钮分组,上面的buttons为默认分组
     *  {
     *    groupKey:{buttonKey:{},buttonKey2:{}}
     *  }
     */
    group: {
      type: Object
    },
    /**
     * 当前激活分组
     */
    active: {
      type: String,
      default: "default"
    },
    /**
     * scope
     */
    scope: {}
  },
  emits: ["handle"],
  setup(e, t) {
    const { ui: n } = w(), { merge: o } = Fe(), { t: a } = tt(), r = (p) => {
      const F = e.scope[n.tableColumn.index], _ = e.scope[n.tableColumn.row], D = { key: p.key, row: _, btn: p, index: F, ...e.scope };
      if (p.click)
        return p.click(D);
      t.emit("handle", D);
    }, { doComputed: i } = an(), s = computed(() => ({
      dropdown: e.dropdown,
      buttons: e.buttons,
      active: e.active,
      group: e.group
    })), u = i(
      () => s.value,
      () => {
        const p = e.scope[n.tableColumn.index], F = e.scope[n.tableColumn.row];
        return { ...e.scope, index: p, row: F };
      }
    ), l2 = computed(() => {
      let p = null;
      if (u.value.active == null || u.value.active === "default") {
        const _ = {
          view: {
            key: "view",
            text: a("fs.rowHandle.view.text"),
            title: a("fs.rowHandle.view.text")
          },
          edit: {
            key: "edit",
            type: "primary",
            text: a("fs.rowHandle.edit.text"),
            title: a("fs.rowHandle.edit.text")
          },
          remove: {
            key: "remove",
            ...n.button.colors("danger"),
            text: a("fs.rowHandle.remove.text"),
            title: a("fs.rowHandle.remove.text")
          }
        };
        p = o(_, u.value.buttons);
      } else
        p = u.value.group[u.value.active];
      const F = [];
      return lodash_default_default.forEach(p, (_, D) => {
        _.key = D, _.show !== false && F.push(_);
      }), lodash_default_default.sortBy(F, (_) => _.order ?? Kt.orderDefault);
    }), c = computed(() => u.value.dropdown == null || u.value.dropdown.atLeast == null || u.value.dropdown.atLeast <= 0 || l2.value.length <= u.value.dropdown.atLeast ? 0 : u.value.dropdown.atLeast || 0);
    function d(p, F) {
      return p.dropdown === true || c.value > 0 && c.value < F;
    }
    const f = computed(() => {
      let p = 0;
      for (const F of l2.value) {
        if (d(F, p))
          return true;
        p++;
      }
      return false;
    });
    function h2(p) {
      for (let F of l2.value)
        if (p === F.key) {
          r(F);
          return;
        }
    }
    const v = computed(() => {
      const p = {};
      if (n.dropdown.renderMode !== "slot") {
        const F = l2.value, _ = [];
        lodash_default_default.forEach(F, (D, k) => {
          D.show !== false && d(D, k) && _.push({
            [n.dropdown.value]: D.key,
            [n.dropdown.label]: D.text,
            title: D.title
          });
        }), p.options = _;
      }
      return {
        ...lodash_default_default.omit(e.dropdown, "more", "atLeast"),
        ...n.dropdown.command(h2),
        ...p
      };
    });
    return {
      ui: n,
      hasDropdownBtn: f,
      computedHandleBtns: l2,
      doDropdownItemClick: h2,
      computedDropdownAtLeast: c,
      doClick: r,
      isDropdownBtn: d,
      computedDropdownBinding: v
    };
  }
});
var ac = { class: "fs-row-handle" };
var ic = {
  key: 0,
  class: "row-handle-btn fs-handle-row-dropdown"
};
function sc(e, t, n, o, a, r) {
  const i = resolveComponent("fs-button"), s = resolveComponent("fs-icon");
  return openBlock(), createElementBlock("div", ac, [
    renderSlot(e.$slots, "cell-rowHandle-left", normalizeProps(guardReactiveProps(e.scope))),
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedHandleBtns, (u, l2) => (openBlock(), createElementBlock(Fragment, { key: l2 }, [
      u.show !== false && !e.isDropdownBtn(u, l2) ? (openBlock(), createBlock(i, mergeProps({
        key: 0,
        class: "row-handle-btn"
      }, u, {
        onClick: withModifiers((c) => e.doClick(u), ["stop"])
      }), null, 16, ["onClick"])) : createCommentVNode("", true)
    ], 64))), 128)),
    renderSlot(e.$slots, "cell-rowHandle-middle", normalizeProps(guardReactiveProps(e.scope))),
    e.hasDropdownBtn ? (openBlock(), createElementBlock("span", ic, [
      (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdown.name), normalizeProps(guardReactiveProps(e.computedDropdownBinding)), {
        [e.ui.dropdown.slotName]: withCtx(() => [
          e.ui.dropdown.renderMode === "slot" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdownMenu.name), normalizeProps(mergeProps({ key: 0 }, e.ui.dropdownMenu.command(e.doDropdownItemClick))), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedHandleBtns, (u, l2) => (openBlock(), createElementBlock(Fragment, { key: l2 }, [
                u.show !== false && e.isDropdownBtn(u, l2) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdownItem.name), normalizeProps({
                  key: 0,
                  [e.ui.dropdownItem.command || ""]: u.key
                }), {
                  default: withCtx(() => [
                    createBaseVNode("div", mergeProps({ class: "fs-row-handle-dropdown-item" }, u), [
                      u.icon ? (openBlock(), createBlock(s, {
                        key: 0,
                        icon: u.icon
                      }, null, 8, ["icon"])) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString(u.text || u.title), 1)
                    ], 16)
                  ]),
                  _: 2
                }, 1040)) : createCommentVNode("", true)
              ], 64))), 128))
            ]),
            _: 1
          }, 16)) : createCommentVNode("", true)
        ]),
        default: withCtx(() => [
          createVNode(i, normalizeProps(guardReactiveProps(e.dropdown.more)), null, 16)
        ]),
        _: 2
      }, 1040))
    ])) : createCommentVNode("", true),
    renderSlot(e.$slots, "cell-rowHandle-right", normalizeProps(guardReactiveProps(e.scope)))
  ]);
}
var lc = Se(rc, [["render", sc]]);
function en() {
  return en = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, en.apply(this, arguments);
}
function uc(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Hn(e, t);
}
function ir(e) {
  return ir = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, ir(e);
}
function Hn(e, t) {
  return Hn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, a) {
    return o.__proto__ = a, o;
  }, Hn(e, t);
}
function cc() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function co(e, t, n) {
  return cc() ? co = Reflect.construct.bind() : co = function(a, r, i) {
    var s = [null];
    s.push.apply(s, r);
    var u = Function.bind.apply(a, s), l2 = new u();
    return i && Hn(l2, i.prototype), l2;
  }, co.apply(null, arguments);
}
function dc(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function sr(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return sr = function(o) {
    if (o === null || !dc(o))
      return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o))
        return t.get(o);
      t.set(o, a);
    }
    function a() {
      return co(o, arguments, ir(this).constructor);
    }
    return a.prototype = Object.create(o.prototype, {
      constructor: {
        value: a,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), Hn(a, o);
  }, sr(e);
}
var fc = /%[sdj%]/g;
var ja = function() {
};
typeof process < "u" && process.env && true && typeof window < "u" && typeof document < "u" && (ja = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function lr(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function ut(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var a = 0, r = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var i = e.replace(fc, function(s) {
      if (s === "%%")
        return "%";
      if (a >= r)
        return s;
      switch (s) {
        case "%s":
          return String(n[a++]);
        case "%d":
          return Number(n[a++]);
        case "%j":
          try {
            return JSON.stringify(n[a++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return i;
  }
  return e;
}
function hc(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function qe(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || hc(t) && typeof e == "string" && !e);
}
function mc(e, t, n) {
  var o = [], a = 0, r = e.length;
  function i(s) {
    o.push.apply(o, s || []), a++, a === r && n(o);
  }
  e.forEach(function(s) {
    t(s, i);
  });
}
function qr(e, t, n) {
  var o = 0, a = e.length;
  function r(i) {
    if (i && i.length) {
      n(i);
      return;
    }
    var s = o;
    o = o + 1, s < a ? t(e[s], r) : n([]);
  }
  r([]);
}
function pc(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var Hr = function(e) {
  uc(t, e);
  function t(n, o) {
    var a;
    return a = e.call(this, "Async Validation Error") || this, a.errors = n, a.fields = o, a;
  }
  return t;
}(sr(Error));
function gc(e, t, n, o, a) {
  if (t.first) {
    var r = new Promise(function(f, h2) {
      var v = function(_) {
        return o(_), _.length ? h2(new Hr(_, lr(_))) : f(a);
      }, p = pc(e);
      qr(p, n, v);
    });
    return r.catch(function(f) {
      return f;
    }), r;
  }
  var i = t.firstFields === true ? Object.keys(e) : t.firstFields || [], s = Object.keys(e), u = s.length, l2 = 0, c = [], d = new Promise(function(f, h2) {
    var v = function(F) {
      if (c.push.apply(c, F), l2++, l2 === u)
        return o(c), c.length ? h2(new Hr(c, lr(c))) : f(a);
    };
    s.length || (o(c), f(a)), s.forEach(function(p) {
      var F = e[p];
      i.indexOf(p) !== -1 ? qr(F, n, v) : mc(F, n, v);
    });
  });
  return d.catch(function(f) {
    return f;
  }), d;
}
function vc(e) {
  return !!(e && e.message !== void 0);
}
function bc(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function Wr(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = bc(t, e.fullFields) : o = t[n.field || e.fullField], vc(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function xr(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = en({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var Ba = function(t, n, o, a, r, i) {
  t.required && (!o.hasOwnProperty(t.field) || qe(n, i || t.type)) && a.push(ut(r.messages.required, t.fullField));
};
var yc = function(t, n, o, a, r) {
  (/^\s+$/.test(n) || n === "") && a.push(ut(r.messages.whitespace, t.fullField));
};
var to;
var wc = function() {
  if (to)
    return to;
  var e = "[a-fA-F\\d:]", t = function(A) {
    return A && A.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", a = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), r = new RegExp("(?:^" + n + "$)|(?:^" + a + "$)"), i = new RegExp("^" + n + "$"), s = new RegExp("^" + a + "$"), u = function(A) {
    return A && A.exact ? r : new RegExp("(?:" + t(A) + n + t(A) + ")|(?:" + t(A) + a + t(A) + ")", "g");
  };
  u.v4 = function(k) {
    return k && k.exact ? i : new RegExp("" + t(k) + n + t(k), "g");
  }, u.v6 = function(k) {
    return k && k.exact ? s : new RegExp("" + t(k) + a + t(k), "g");
  };
  var l2 = "(?:(?:[a-z]+:)?//)", c = "(?:\\S+(?::\\S*)?@)?", d = u.v4().source, f = u.v6().source, h2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", p = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", F = "(?::\\d{2,5})?", _ = '(?:[/?#][^\\s"]*)?', D = "(?:" + l2 + "|www\\.)" + c + "(?:localhost|" + d + "|" + f + "|" + h2 + v + p + ")" + F + _;
  return to = new RegExp("(?:^" + D + "$)", "i"), to;
};
var zr = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var kn = {
  integer: function(t) {
    return kn.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return kn.number(t) && !kn.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return true;
    try {
      return !!new RegExp(t);
    } catch {
      return false;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? false : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !kn.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(zr.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(wc());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(zr.hex);
  }
};
var _c = function(t, n, o, a, r) {
  if (t.required && n === void 0) {
    Ba(t, n, o, a, r);
    return;
  }
  var i = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = t.type;
  i.indexOf(s) > -1 ? kn[s](n) || a.push(ut(r.messages.types[s], t.fullField, t.type)) : s && typeof n !== t.type && a.push(ut(r.messages.types[s], t.fullField, t.type));
};
var Cc = function(t, n, o, a, r) {
  var i = typeof t.len == "number", s = typeof t.min == "number", u = typeof t.max == "number", l2 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = n, d = null, f = typeof n == "number", h2 = typeof n == "string", v = Array.isArray(n);
  if (f ? d = "number" : h2 ? d = "string" : v && (d = "array"), !d)
    return false;
  v && (c = n.length), h2 && (c = n.replace(l2, "_").length), i ? c !== t.len && a.push(ut(r.messages[d].len, t.fullField, t.len)) : s && !u && c < t.min ? a.push(ut(r.messages[d].min, t.fullField, t.min)) : u && !s && c > t.max ? a.push(ut(r.messages[d].max, t.fullField, t.max)) : s && u && (c < t.min || c > t.max) && a.push(ut(r.messages[d].range, t.fullField, t.min, t.max));
};
var sn = "enum";
var Fc = function(t, n, o, a, r) {
  t[sn] = Array.isArray(t[sn]) ? t[sn] : [], t[sn].indexOf(n) === -1 && a.push(ut(r.messages[sn], t.fullField, t[sn].join(", ")));
};
var Sc = function(t, n, o, a, r) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || a.push(ut(r.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var i = new RegExp(t.pattern);
      i.test(n) || a.push(ut(r.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
};
var ye = {
  required: Ba,
  whitespace: yc,
  type: _c,
  range: Cc,
  enum: Fc,
  pattern: Sc
};
var Ec = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n, "string") && !t.required)
      return o();
    ye.required(t, n, a, i, r, "string"), qe(n, "string") || (ye.type(t, n, a, i, r), ye.range(t, n, a, i, r), ye.pattern(t, n, a, i, r), t.whitespace === true && ye.whitespace(t, n, a, i, r));
  }
  o(i);
};
var Dc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && ye.type(t, n, a, i, r);
  }
  o(i);
};
var Rc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (n === "" && (n = void 0), qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && (ye.type(t, n, a, i, r), ye.range(t, n, a, i, r));
  }
  o(i);
};
var kc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && ye.type(t, n, a, i, r);
  }
  o(i);
};
var Oc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), qe(n) || ye.type(t, n, a, i, r);
  }
  o(i);
};
var $c = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && (ye.type(t, n, a, i, r), ye.range(t, n, a, i, r));
  }
  o(i);
};
var Tc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && (ye.type(t, n, a, i, r), ye.range(t, n, a, i, r));
  }
  o(i);
};
var Ac = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (n == null && !t.required)
      return o();
    ye.required(t, n, a, i, r, "array"), n != null && (ye.type(t, n, a, i, r), ye.range(t, n, a, i, r));
  }
  o(i);
};
var Ic = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && ye.type(t, n, a, i, r);
  }
  o(i);
};
var Pc = "enum";
var Vc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r), n !== void 0 && ye[Pc](t, n, a, i, r);
  }
  o(i);
};
var Mc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n, "string") && !t.required)
      return o();
    ye.required(t, n, a, i, r), qe(n, "string") || ye.pattern(t, n, a, i, r);
  }
  o(i);
};
var jc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n, "date") && !t.required)
      return o();
    if (ye.required(t, n, a, i, r), !qe(n, "date")) {
      var u;
      n instanceof Date ? u = n : u = new Date(n), ye.type(t, u, a, i, r), u && ye.range(t, u.getTime(), a, i, r);
    }
  }
  o(i);
};
var Bc = function(t, n, o, a, r) {
  var i = [], s = Array.isArray(n) ? "array" : typeof n;
  ye.required(t, n, a, i, r, s), o(i);
};
var Bo = function(t, n, o, a, r) {
  var i = t.type, s = [], u = t.required || !t.required && a.hasOwnProperty(t.field);
  if (u) {
    if (qe(n, i) && !t.required)
      return o();
    ye.required(t, n, a, s, r, i), qe(n, i) || ye.type(t, n, a, s, r);
  }
  o(s);
};
var Nc = function(t, n, o, a, r) {
  var i = [], s = t.required || !t.required && a.hasOwnProperty(t.field);
  if (s) {
    if (qe(n) && !t.required)
      return o();
    ye.required(t, n, a, i, r);
  }
  o(i);
};
var An = {
  string: Ec,
  method: Dc,
  number: Rc,
  boolean: kc,
  regexp: Oc,
  integer: $c,
  float: Tc,
  array: Ac,
  object: Ic,
  enum: Vc,
  pattern: Mc,
  date: jc,
  url: Bo,
  hex: Bo,
  email: Bo,
  required: Bc,
  any: Nc
};
function ur() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var cr = ur();
var Gn = function() {
  function e(n) {
    this.rules = null, this._messages = cr, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var a = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(r) {
      var i = o[r];
      a.rules[r] = Array.isArray(i) ? i : [i];
    });
  }, t.messages = function(o) {
    return o && (this._messages = xr(ur(), o)), this._messages;
  }, t.validate = function(o, a, r) {
    var i = this;
    a === void 0 && (a = {}), r === void 0 && (r = function() {
    });
    var s = o, u = a, l2 = r;
    if (typeof u == "function" && (l2 = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
      return l2 && l2(null, s), Promise.resolve(s);
    function c(p) {
      var F = [], _ = {};
      function D(A) {
        if (Array.isArray(A)) {
          var E;
          F = (E = F).concat.apply(E, A);
        } else
          F.push(A);
      }
      for (var k = 0; k < p.length; k++)
        D(p[k]);
      F.length ? (_ = lr(F), l2(F, _)) : l2(null, s);
    }
    if (u.messages) {
      var d = this.messages();
      d === cr && (d = ur()), xr(d, u.messages), u.messages = d;
    } else
      u.messages = this.messages();
    var f = {}, h2 = u.keys || Object.keys(this.rules);
    h2.forEach(function(p) {
      var F = i.rules[p], _ = s[p];
      F.forEach(function(D) {
        var k = D;
        typeof k.transform == "function" && (s === o && (s = en({}, s)), _ = s[p] = k.transform(_)), typeof k == "function" ? k = {
          validator: k
        } : k = en({}, k), k.validator = i.getValidationMethod(k), k.validator && (k.field = p, k.fullField = k.fullField || p, k.type = i.getType(k), f[p] = f[p] || [], f[p].push({
          rule: k,
          value: _,
          source: s,
          field: p
        }));
      });
    });
    var v = {};
    return gc(f, u, function(p, F) {
      var _ = p.rule, D = (_.type === "object" || _.type === "array") && (typeof _.fields == "object" || typeof _.defaultField == "object");
      D = D && (_.required || !_.required && p.value), _.field = p.field;
      function k($, S) {
        return en({}, S, {
          fullField: _.fullField + "." + $,
          fullFields: _.fullFields ? [].concat(_.fullFields, [$]) : [$]
        });
      }
      function A($) {
        $ === void 0 && ($ = []);
        var S = Array.isArray($) ? $ : [$];
        !u.suppressWarning && S.length && e.warning("async-validator:", S), S.length && _.message !== void 0 && (S = [].concat(_.message));
        var O = S.map(Wr(_, s));
        if (u.first && O.length)
          return v[_.field] = 1, F(O);
        if (!D)
          F(O);
        else {
          if (_.required && !p.value)
            return _.message !== void 0 ? O = [].concat(_.message).map(Wr(_, s)) : u.error && (O = [u.error(_, ut(u.messages.required, _.field))]), F(O);
          var B = {};
          _.defaultField && Object.keys(p.value).map(function(I) {
            B[I] = _.defaultField;
          }), B = en({}, B, p.rule.fields);
          var x = {};
          Object.keys(B).forEach(function(I) {
            var M = B[I], N = Array.isArray(M) ? M : [M];
            x[I] = N.map(k.bind(null, I));
          });
          var Q = new e(x);
          Q.messages(u.messages), p.rule.options && (p.rule.options.messages = u.messages, p.rule.options.error = u.error), Q.validate(p.value, p.rule.options || u, function(I) {
            var M = [];
            O && O.length && M.push.apply(M, O), I && I.length && M.push.apply(M, I), F(M.length ? M : null);
          });
        }
      }
      var E;
      if (_.asyncValidator)
        E = _.asyncValidator(_, p.value, A, p.source, u);
      else if (_.validator) {
        try {
          E = _.validator(_, p.value, A, p.source, u);
        } catch ($) {
          console.error == null || console.error($), u.suppressValidatorError || setTimeout(function() {
            throw $;
          }, 0), A($.message);
        }
        E === true ? A() : E === false ? A(typeof _.message == "function" ? _.message(_.fullField || _.field) : _.message || (_.fullField || _.field) + " fails") : E instanceof Array ? A(E) : E instanceof Error && A(E.message);
      }
      E && E.then && E.then(function() {
        return A();
      }, function($) {
        return A($);
      });
    }, function(p) {
      c(p);
    }, s);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !An.hasOwnProperty(o.type))
      throw new Error(ut("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var a = Object.keys(o), r = a.indexOf("message");
    return r !== -1 && a.splice(r, 1), a.length === 1 && a[0] === "required" ? An.required : An[this.getType(o)] || void 0;
  }, e;
}();
Gn.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  An[t] = n;
};
Gn.warning = ja;
Gn.messages = cr;
Gn.validators = An;
function Lc(e) {
  const t = {};
  for (const n in e) {
    const o = e[n].getForm(), a = o.rules || o.rule, r = n.split(".");
    let i = t;
    if (a)
      for (let s = 0; s < r.length; s++) {
        const u = r[s];
        i[u] || (i[u] = { type: "object", fields: {} }), s == r.length - 1 ? i[u] = a : i = i[u].fields;
      }
  }
  return new Gn(t);
}
function dr(e, t) {
  lodash_default_default.forEach(e, (n) => {
    n.children ? dr(n.children, t) : t(n);
  });
}
function qc(e, t) {
  const n = l.get();
  function o() {
    return e.data ? e.data : t.value ? t.value[n.table.data] : [];
  }
  return {
    getData: o,
    insert(a, r) {
      o().splice(a, 0, r);
    },
    unshift(a) {
      o().unshift(a);
    },
    remove(a) {
      o().splice(a, 1);
    },
    get(a) {
      return o()[a];
    }
  };
}
function Hc(e, t, n) {
  const o = qc(e, n), a = reactive([]);
  function r(C) {
    return typeof e.rowKey == "string" ? C[e.rowKey] : e.rowKey(C);
  }
  function i(C) {
    return C[e.editable.rowKey];
  }
  function s(C) {
    for (const m in a) {
      const b = a[m], R = b.cells, V = b.rowData;
      if (C({ rowData: V, row: b, cells: R }) === "break")
        return;
    }
  }
  function u(C) {
    s(({ rowData: m, row: b, cells: R }) => {
      lodash_default_default.forEach(R, (V, ne) => {
        C({ rowData: m, row: b, cells: R, cell: V, key: ne });
      });
    });
  }
  const { merge: l2 } = Fe(), c = computed(() => l2({
    enabled: false,
    //模式，free，row，cell
    mode: "free",
    rowKey: "id",
    addForm: {},
    editForm: {},
    //是否排他式激活，激活一个，其他自动提交或取消
    exclusive: true,
    //排他式激活时，其他的效果，cancel，save
    exclusiveEffect: "cancel",
    //激活触发方式,onClick,onDbClick
    activeTrigger: "onClick",
    //默认激活
    activeDefault: false,
    isEditable(C) {
      return true;
    }
  }, e.editable));
  function d(C, m, b, R) {
    function V(he) {
      return lodash_default_default.get(C, he);
    }
    function ne(he, Me) {
      lodash_default_default.set(C, he, Me);
    }
    const ie = computed(() => {
      var he;
      return ((he = R.editable) == null ? void 0 : he.updateCell) || c.value.updateCell;
    }), K = reactive({
      mode: b < 0 ? "add" : "edit",
      oldValue: void 0,
      newValue: void 0,
      loading: false,
      isEditing: c.value.activeDefault,
      activeTrigger: c.value.activeTrigger,
      column: R,
      updateCell: ie,
      showAction: true,
      isEditable: () => {
        var Ue;
        let he = (Ue = R == null ? void 0 : R.editable) == null ? void 0 : Ue.disabled;
        he instanceof Function && (he = config.disabled({ column: item, editableId: b, row: rowData }));
        let Me = null;
        return he != null && (Me = !he), Me ?? (c.value.isEditable({ editableId: b, key: m, row: C }) || false);
      },
      isChanged: () => K.newValue !== K.oldValue,
      getForm: () => {
        let he = c.value[K.mode + "Form"];
        return he == null && (he = c.value.editForm), he[m];
      },
      active: (he = {}) => {
        (he.exclusive ?? c.value.exclusive) && ((he.exclusiveEffect ?? c.value.exclusiveEffect) === "save" ? A() : E()), he.showAction != null ? K.showAction = he.showAction : K.showAction = null, K.isEditing = true, K.oldValue = V(m);
        const Ue = c.value.editForm[m];
        Ue && Q(Ue, C);
      },
      inactive: () => {
        K.isEditing = false, K.newValue = V(m);
      },
      resume: () => {
        K.isEditing && (K.isEditing = false, ne(m, K.oldValue), delete K.newValue, delete K.oldValue);
      },
      cancel: () => {
        K.resume();
      },
      persist: () => {
        K.isEditing = false, delete K.newValue, delete K.oldValue;
      },
      save: async () => {
        const he = unref(K.updateCell);
        if (he) {
          K.loading = true;
          try {
            const Me = await he({ editableId: b, row: C, key: m, value: V(m) });
            Me != null && C[c.value.rowKey] < 0 && (C[c.value.rowKey] = Me[c.value.rowKey]), K.persist();
          } finally {
            K.loading = false;
          }
        }
      }
    });
    return K;
  }
  function f(C, m) {
    const b = {};
    dr(e.columns, (K) => {
      b[K.key] = d(m, K.key, C, K);
    });
    const R = computed(() => Lc(b)), V = r(m), ne = V == null || V < 0, ie = reactive({
      isAdd: ne,
      rowData: m,
      editableId: C,
      isEditing: false,
      loading: false,
      cells: b,
      validator: R,
      inactive: () => {
        ie.isEditing = false, lodash_default_default.forEach(ie.cells, (K) => {
          K.isEditing && K.inactive();
        });
      },
      active: () => {
        ie.isEditing = true, lodash_default_default.forEach(ie.cells, (K) => {
          K.active({ exclusive: false });
        });
      },
      persist: () => {
        ie.isEditing = false, ie.inactive(), delete ie.isAdd, lodash_default_default.forEach(ie.cells, (K) => {
          K.persist();
        });
      },
      resume: () => {
        ie.isEditing = false, lodash_default_default.forEach(ie.cells, (K) => {
          K.resume();
        });
      },
      cancel: () => {
        ie.resume();
      },
      validate: async (K) => {
        try {
          return lodash_default_default.forEach(ie.cells, (he, Me) => {
            he.validateErrors = [];
          }), K == null && (K = ie.rowData), await ie.validator.validate(K), true;
        } catch (he) {
          const { errors: Me, fields: Ue } = he;
          return lodash_default_default.forEach(Ue, (wn, _n) => {
            const Je = ie.cells[_n];
            Je && (Je.validateErrors = wn);
          }), Ue;
        }
      },
      getRowData: () => {
        const K = lodash_default_default.cloneDeep(ie.rowData);
        return delete K[e.editable.rowKey], delete K.children, K;
      },
      save: async (K) => {
        const { doSave: he } = K, Me = ie.rowData, { merge: Ue } = Fe();
        if (await ie.validate() !== true)
          return;
        function _n(ct) {
          ct && (r(ct) == null && console.error("保存接口没有返回rowKey,无法更新该行的id,newRow:", ct), Ue(Me, ct));
        }
        ie.loading = true;
        const Je = ie.getRowData();
        try {
          await he({ isAdd: ie.isAdd, row: Je, setData: _n }), ie.persist();
        } finally {
          ie.loading = false;
        }
      }
    });
    if (watch(() => m, async (K, he, Me) => {
      await ie.validate();
    }, {
      deep: true
    }), m.children && m.children.length > 0)
      for (const K of m.children) {
        K[e.editable.rowKey] || (K[e.editable.rowKey] = v());
        const he = K[e.editable.rowKey];
        a[he] = f(he, K);
      }
    return ne && ie.active(), ie;
  }
  let h2 = 0;
  function v() {
    return h2++, h2;
  }
  function p(C) {
    C == null && (C = o.getData()), lodash_default_default.forOwn(a, (m, b) => {
      delete a[b];
    }), lodash_default_default.forEach(C, (m) => {
      m[e.editable.rowKey] || (m[e.editable.rowKey] = v());
      const b = m[e.editable.rowKey];
      a[b] = f(b, m);
    }), c.value.onSetup && c.value.onSetup();
  }
  function F(C) {
    const m = e.editable.rowKey, b = [];
    for (const R of C) {
      const V = { [m]: R[m] };
      R.children && R.children.length && (V.children = F(R.children)), b.push(V);
    }
    return b;
  }
  watch(() => {
    const C = e.data;
    let m = [];
    return C != null && C instanceof Array && (m = F(C)), JSON.stringify(m);
  }, (C, m) => {
    c.value.enabled && p(e.data);
  }, {
    immediate: true
  }), watch(() => c.value.enabled, (C) => {
    var m;
    C && (((m = o.getData()) == null ? void 0 : m.length) > 0 && p(), c.value.onEnabled && c.value.onEnabled({ ...c.value }));
  }, {
    immediate: true
  }), watch(() => c.value.mode, () => {
    c.value.onEnabled && c.value.onEnabled({ ...c.value });
  });
  function _(C, m) {
    var b;
    if (m != null)
      return (b = a[C]) == null ? void 0 : b.cells[m];
  }
  function D(C = {}) {
    u(({ cell: m }) => {
      m.active({ ...C, exclusive: false });
    });
  }
  function k() {
    u(({ cell: C }) => {
      C.isEditing && C.inactive();
    });
  }
  async function A() {
    u(({ cell: C }) => {
      C.isEditing && C.save();
    });
  }
  function E() {
    u(({ cell: C }) => {
      C.isEditing && C.cancel();
    });
  }
  function $() {
    k(), s(({ row: C }) => {
      delete C.isAdd;
    }), u(({ cell: C }) => {
      delete C.newValue, delete C.oldValue;
    });
  }
  function S() {
    u(({ cell: C }) => {
      C.resume();
    });
  }
  function O() {
    let C = false;
    return s(({ cells: m }) => {
      lodash_default_default.forEach(m, (b) => {
        if (b.isChanged())
          return C = true, "break";
      });
    }), C;
  }
  let B = 0;
  function x(C, m) {
    dr(C, (b) => {
      Q(b, m);
    });
  }
  function Q(C, m) {
    const b = lodash_default_default.get(m, C.key), R = unref(C.value);
    R != null && b == null && lodash_default_default.set(m, C.key, R);
  }
  async function I(C = { row: void 0, active: true }) {
    const m = C.row || { [c.value.rowKey]: --B };
    x(c.value.addForm, m), e.editable.addRow ? await e.editable.addRow(o.getData(), m) : o.unshift(m);
  }
  function M(C, m) {
    for (let b = 0; b < m.length; b++) {
      const R = m[b];
      if (i(R) === C)
        return lodash_default_default.remove(m, R), true;
      if (R.children && R.children.length > 0 && M(C, R.children))
        return;
    }
    return false;
  }
  function N(C) {
    delete a[C], M(C, o.getData());
  }
  function J(C) {
    const { cols: m } = C;
    s(({ cells: b }) => {
      lodash_default_default.forEach(m, (R) => {
        b[R].active({ ...C, exclusive: false });
      });
    });
  }
  function Z(C) {
    return a[C];
  }
  async function ge() {
    const C = {};
    let m = false;
    for (const b in a) {
      const R = a[b];
      await R.validate() != true && (C[R.editableId] = C, m = true);
    }
    return m ? C : true;
  }
  function z(C) {
    for (const m of C)
      delete m[e.editable.rowKey], m.children && m.children.length > 0 && z(m.children);
    return C;
  }
  function se(C) {
    return C == null && (C = lodash_default_default.cloneDeep(o.getData())), C == null ? [] : z(C);
  }
  return {
    editable: {
      options: c,
      setupEditable: p,
      inactive: k,
      active: D,
      persist: $,
      saveEach: A,
      cancelAll: E,
      resume: S,
      addRow: I,
      removeRow: N,
      getEditableRow: Z,
      activeCols: J,
      hasDirty: O,
      getEditableCell: _,
      eachRows: s,
      eachCells: u,
      validate: ge,
      getCleanTableData: se
    }
  };
}
function Wc(e) {
  const t = (o, a) => lodash_default_default.get(e, `value[${o}].${a}`);
  provide("componentRef:get", t);
  const n = (o, a, r) => lodash_default_default.set(e, `value[${o}].${a}`, r);
  return provide("componentRef:set", n), {
    getter: t,
    setter: n
  };
}
function xc({
  props: e,
  ui: t,
  sortedColumns: n,
  renderRowHandle: o,
  renderCellComponent: a
}) {
  resolveDynamicComponent(t.table.name);
  const r = resolveDynamicComponent(t.tableColumn.name), i = resolveDynamicComponent(t.tableColumnGroup.name);
  t.tableColumn;
  const s = {};
  return s.default = () => {
    const u = [], l2 = (c) => {
      const d = {}, f = "cell_" + c.key;
      let h2 = r;
      if (c.children)
        d.default = () => {
          const p = [];
          return lodash_default_default.forEach(c.children, (F) => {
            F.show !== false && p.push(l2(F));
          }), p;
        }, h2 = i;
      else if (c.type != null) {
        ue.debug("cell render column.type:", c.type);
        const p = e.cellSlots && e.cellSlots[f];
        p && (d.default = p);
      } else
        d.default = (p) => a(c, p);
      const v = {
        ...c
      };
      return delete v.children, createVNode(h2, mergeProps({
        ref: "tableColumnRef"
      }, v, {
        label: c.title,
        prop: c.key,
        dataIndex: c.key
      }), d);
    };
    if (lodash_default_default.forEach(n, (c) => {
      c.show !== false && u.push(l2(c));
    }), e.rowHandle && e.rowHandle.show !== false) {
      const c = {
        default: o
      };
      u.push(createVNode(r, mergeProps({
        ref: "tableColumnRef"
      }, e.rowHandle, {
        label: e.rowHandle.title,
        prop: e.rowHandle.key || "rowHandle"
      }), c));
    }
    return u;
  }, e.slots && lodash_default_default.forEach(e.slots, (u, l2) => {
    s[l2] = u;
  }), s;
}
function Na(e) {
  var u;
  const {
    props: t,
    renderRowHandle: n,
    renderCellComponent: o,
    sortedColumns: a
  } = e, {
    ui: r
  } = w(), i = a ?? {}, s = [];
  for (const l2 in i) {
    const c = i[l2];
    if (c.show === false)
      continue;
    const d = {
      ...c
    };
    if (d.dataIndex = c.key, s.push(d), c.children != null) {
      const f = {
        ...e,
        sortedColumns: c.children
      };
      delete f.renderRowHandle, d.children = Na(f);
    } else if (c.type == null) {
      const f = d[r.table.renderMethod], h2 = {
        ...d
      };
      delete h2[r.table.renderMethod], f ? d[r.table.renderMethod] = (v, p, F) => {
        const _ = r.table.rebuildRenderScope(v, p, F);
        return f(_, () => o(h2, _));
      } : d[r.table.renderMethod] = (v, p, F) => {
        const _ = r.table.rebuildRenderScope(v, p, F);
        return o(h2, _);
      };
    }
  }
  if (n && ((u = t.rowHandle) == null ? void 0 : u.show) !== false) {
    const l2 = {
      key: "_rowHandle",
      ...t.rowHandle
    };
    l2[r.table.renderMethod] = (c, d, f) => {
      const h2 = r.table.rebuildRenderScope(c, d, f);
      return n(h2);
    }, s.push(l2);
  }
  return ue.debug("table columns:", s), s;
}
var zc = defineComponent({
  name: "FsTable",
  inheritAttrs: false,
  props: {
    /**
     * table插槽
     */
    slots: {
      type: Object
    },
    /**
     * 单元格插槽
     */
    cellSlots: {
      type: Object
    },
    /**
     * 列配置，支持el-table-column|a-table-column配置
     */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 操作列
     */
    rowHandle: {
      type: Object
    },
    /**
     * 是否显示表格
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 表格数据
     */
    data: {
      type: Array
    },
    conditionalRender: {
      type: Object
    },
    /**
     * 行编辑，批量编辑
     */
    editable: {
      type: Object,
      default() {
        return {};
      }
    },
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * 当前sort状态
     */
    sort: {
      type: Object
    },
    request: {
      type: Object
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    }
  },
  emits: ["row-handle", "value-change", "pagination-change", "filter-change", "sort-change", "data-change"],
  setup(e, t) {
    const n = ref(), o = ref([]);
    Wc(o);
    const a = (E, $) => {
      if (!$ || E == null || E > o.value.length)
        return;
      const O = o.value[E][$];
      return O == null ? void 0 : O.getTargetRef();
    }, {
      ui: r
    } = w(), i = getCurrentInstance();
    watch(() => e.data, (E) => {
      r.table.scrollTo({
        top: 0,
        tableRef: n,
        fsTableRef: i
      }), t.emit("data-change", {
        data: E
      });
    });
    const s = resolveDynamicComponent(r.table.name), u = r.tableColumn, l2 = Hc(e, t, n), c = (E, $) => {
      const S = $[u.row], O = S, B = $[r.tableColumn.index];
      return $.index = B, {
        ...$,
        key: E.key,
        value: lodash_default_default.get(S, E.key),
        row: S,
        form: O,
        getComponentRef: (x) => a(B, x)
      };
    };
    function d(E) {
      t.emit("row-handle", E);
    }
    const f = r.table.onChange({
      onSortChange: (E) => {
        t.emit("sort-change", E);
      },
      onFilterChange: (E) => {
        t.emit("filter-change", E);
      },
      onPagination: () => {
      },
      bubbleUp: (E) => {
        E(t.attrs);
      }
    }), h2 = (E) => {
      E.index = E[r.tableColumn.index];
      const $ = "cell-rowHandle", S = {};
      if (e.cellSlots)
        for (const O in e.cellSlots)
          O.startsWith($) && (S[O] = e.cellSlots[O]);
      return createVNode(resolveComponent("fs-row-handle"), mergeProps(e.rowHandle, {
        scope: E,
        onHandle: d
      }), S);
    }, v = (E, $) => {
      var J, Z, ge, z, se, C, m, b, R, V, ne, ie;
      const S = "cell_" + E.key, O = $.row = $[u.row], B = c(E, $), x = {
        modelValue: lodash_default_default.get($[u.row], E.key),
        "onUpdate:modelValue": (K) => {
          lodash_default_default.set($[u.row], E.key, K), t.emit("value-change", B), E.valueChange && E.valueChange(B);
        }
      }, Q = (K) => {
        const he = $[r.tableColumn.index], Me = E.key;
        let Ue = o.value[he];
        Ue == null && (o.value[he] = Ue = {}), Ue[Me] = K;
      }, I = $[r.tableColumn.index], M = O[(J = e.editable) == null ? void 0 : J.rowKey], N = e.cellSlots && e.cellSlots[S];
      if (((z = (ge = (Z = l2.editable) == null ? void 0 : Z.options) == null ? void 0 : ge.value) == null ? void 0 : z.enabled) === true) {
        const K = l2.editable.getEditableCell(M, E.key);
        return createVNode(resolveComponent("fs-editable-cell"), mergeProps({
          ref: Q,
          key: E.key,
          columnKey: E.key,
          index: I,
          editableId: M,
          item: E,
          editableCell: K,
          editableOpts: (C = (se = l2.editable) == null ? void 0 : se.options) == null ? void 0 : C.value,
          scope: B,
          slots: N,
          disabled: (R = (b = (m = l2.editable) == null ? void 0 : m.options) == null ? void 0 : b.value) == null ? void 0 : R.disabled,
          readonly: (ie = (ne = (V = l2.editable) == null ? void 0 : V.options) == null ? void 0 : ne.value) == null ? void 0 : ie.readonly
        }, x), null);
      } else
        return createVNode(resolveComponent("fs-cell"), mergeProps({
          ref: Q,
          key: E.key,
          item: E,
          scope: B,
          slots: N
        }, x, {
          conditionalRender: e.conditionalRender
        }), null);
    }, {
      expose: p
    } = t;
    p({
      tableRef: n,
      componentRefs: o,
      getComponentRef: a,
      ...l2
    });
    const F = r.table.renderMode, _ = computed(() => ({
      [r.table.data]: e.data
    })), {
      merge: D
    } = Fe(), k = computed(() => D({}, t.attrs, f)), A = computed(() => e.columns);
    if (F === "slot") {
      const E = computed(() => xc({
        props: e,
        ui: r,
        sortedColumns: A.value,
        renderRowHandle: h2,
        renderCellComponent: v
      }));
      return () => {
        if (e.show === false)
          return;
        const $ = createVNode(s, mergeProps({
          ref: n,
          loading: e.loading,
          rowKey: e.rowKey
        }, k.value, _.value), E.value);
        if (typeof r.table.vLoading == "string") {
          const S = resolveDirective(r.table.vLoading);
          return withDirectives($, [[S, e.loading]]);
        }
        return $;
      };
    } else {
      const E = computed(() => Na({
        props: e,
        ctx: t,
        ui: r,
        getContextFn: c,
        sortedColumns: A.value,
        componentRefs: o,
        renderRowHandle: h2,
        renderCellComponent: v,
        columns: e.columns
      }));
      return () => {
        if (e.show !== false)
          return createVNode(s, mergeProps({
            ref: n,
            loading: e.loading,
            rowKey: e.rowKey
          }, k.value, {
            columns: E.value
          }, _.value), e.slots);
      };
    }
  }
});
var Uc = defineComponent({
  name: "FsCell",
  props: {
    item: {},
    /**
     * scope
     */
    scope: {
      default() {
        return {};
      }
    },
    /**
     * 插槽
     */
    slots: {},
    /**
     * 条件渲染，符合条件的情况下优先渲染
     */
    conditionalRender: {
      type: Object
    }
  },
  setup(e, t) {
    const {
      doComputed: n
    } = an(), r = n(() => e.item.component, () => e.scope), i = ref();
    function s() {
      return i.value.getTargetRef();
    }
    t.expose({
      getTargetRef: s,
      targetRef: i
    });
    const u = computed(() => {
      let c = e.item.showTitle;
      const d = e.scope.value;
      return c === true && (c = d), c;
    }), l2 = computed(() => (d) => createVNode("span", {
      class: "fs-cell",
      title: u.value
    }, [d]));
    return () => {
      var v, p;
      const c = e.scope.value, d = l2.value, f = {
        ...e.scope,
        props: e.item
      }, h2 = e.item.conditionalRender ?? e.conditionalRender;
      if (h2 && h2.match && h2.match(f))
        return d(h2.render(f));
      if (e.slots)
        return d(e.slots(f));
      if (e.item.formatter)
        return d(e.item.formatter(f));
      if (e.item.cellRender)
        return d(e.item.cellRender(f));
      if (e.item.render)
        console.warn("column.render 配置已废弃，请使用column.cellRender代替");
      else
        return (v = r.value) != null && v.name ? ((p = r.value) == null ? void 0 : p.show) === false ? void 0 : createVNode(resolveComponent("fs-component-render"), mergeProps({
          title: u.value,
          ref: i
        }, r.value, {
          scope: f
        }), null) : d(lodash_default_default.toString(c));
    };
  }
});
var Yc = defineComponent({
  name: "FsEditableCell",
  inheritAttrs: false,
  props: {
    /**
     * 组件配置
     */
    item: {},
    scope: {},
    index: {},
    editableId: {},
    columnKey: {},
    editableCell: {
      type: Object
    },
    editableOpts: {
      type: Object
    },
    disabled: {},
    readonly: {}
  },
  setup(e, t) {
    l.get();
    const {
      doComputed: n
    } = an();
    if (e.index === -1)
      return () => {
      };
    const a = n(() => {
      var h2;
      return (h2 = e.editableCell) == null ? void 0 : h2.getForm();
    }, () => e.scope), r = computed(() => {
      var h2;
      return a.value && a.value.show !== false && ((h2 = e.editableCell) == null ? void 0 : h2.isEditable());
    });
    function i(h2) {
      h2 && r.value && e.editableCell.active();
    }
    async function s() {
      await e.editableCell.save();
    }
    function u() {
      e.editableCell.cancel();
    }
    const l2 = computed(() => {
      var h2;
      return ((h2 = e.editableOpts) == null ? void 0 : h2.mode) === "cell" && e.editableCell.showAction !== false;
    }), c = computed(() => e.editableCell.isChanged && e.editableCell.isChanged()), d = () => e.scope, f = {
      default: () => createVNode(resolveComponent("fs-cell"), mergeProps({
        ref: "targetRef",
        item: e.item,
        scope: e.scope
      }, t.attrs), null),
      edit: () => {
        var v, p;
        let h2 = null;
        return (v = e.editableCell) != null && v.isEditing && (a.value.blank === false || ((p = a.value.component) == null ? void 0 : p.show) === false ? h2 = null : a.value.conditionalRender && a.value.conditionalRender.match && a.value.conditionalRender.match(d()) ? h2 = createVNode(resolveComponent("fs-render"), mergeProps({
          "render-func": a.value.conditionalRender.render,
          scope: d()
        }, t.attrs), null) : a.value.render ? h2 = createVNode(resolveComponent("fs-render"), mergeProps({
          "render-func": a.value.render,
          scope: d()
        }, t.attrs), null) : h2 = createVNode(resolveComponent("fs-component-render"), mergeProps({
          ref: "targetInputRef"
        }, a.value.component, t.attrs), null)), h2;
      }
    };
    return () => {
      var p;
      if (!r.value || e.disabled || e.readonly)
        return createVNode(resolveComponent("fs-cell"), mergeProps({
          ref: "targetRef",
          item: e.item,
          scope: e.scope
        }, t.attrs), null);
      const h2 = e.editableCell, v = e.editableOpts.mode === "cell" ? (p = e.editableOpts) == null ? void 0 : p.activeTrigger : false;
      return createVNode(resolveComponent("fs-editable"), {
        ref: "editableRef",
        class: "fs-editable-cell",
        editing: h2 == null ? void 0 : h2.isEditing,
        showAction: l2.value,
        dirty: c.value,
        "onUpdate:editing": i,
        onSubmit: s,
        onCancel: u,
        loading: h2 == null ? void 0 : h2.loading,
        trigger: v,
        validateErrors: h2 == null ? void 0 : h2.validateErrors
      }, f);
    };
  },
  methods: {
    getTargetRef() {
      var e;
      return ((e = this.$refs.targetInputRef) == null ? void 0 : e.getTargetRef()) || this.$refs.targetRef;
    }
  }
});
var Kc = { class: "fs-editable" };
var Gc = { class: "fs-editable-input" };
var Xc = {
  key: 0,
  class: "fs-editable-dirty"
};
var Qc = {
  key: 0,
  class: "fs-editable-action fs-editable-icon"
};
var Jc = { class: "fs-editable-input" };
var Zc = { class: "fs-editable-action" };
var ed = { class: "error-icon" };
var td = defineComponent({
  __name: "fs-editable",
  props: {
    disabled: { type: Boolean, default: false },
    editing: { type: Boolean, default: false },
    dirty: { type: Boolean, default: false },
    trigger: { type: [String, Boolean], default: "onClick" },
    loading: { type: Boolean, default: false },
    showAction: { type: Boolean, default: true },
    validateErrors: { default: () => [] }
  },
  emits: ["update:editing", "submit", "cancel"],
  setup(e, { emit: t }) {
    const n = e, { ui: o } = w(), a = computed(() => n.trigger ? {
      [n.trigger]: () => {
        t("update:editing", true);
      }
    } : {});
    function r() {
      t("submit");
    }
    function i() {
      t("cancel");
    }
    function s() {
      var l2;
      return ((l2 = n.validateErrors) == null ? void 0 : l2.length) > 0;
    }
    function u() {
      var l2, c;
      if (((l2 = n.validateErrors) == null ? void 0 : l2.length) !== 0)
        return (c = n.validateErrors) == null ? void 0 : c.map((d) => d.message).join(",");
    }
    return (l2, c) => {
      const d = resolveComponent("fs-icon");
      return openBlock(), createElementBlock("div", Kc, [
        !l2.editing || l2.disabled ? (openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: "fs-editable-inner fs-editable-pointer"
        }, a.value), [
          createBaseVNode("div", Gc, [
            l2.dirty ? (openBlock(), createElementBlock("div", Xc)) : createCommentVNode("", true),
            renderSlot(l2.$slots, "default")
          ]),
          l2.trigger && !l2.disabled ? (openBlock(), createElementBlock("div", Qc, [
            createVNode(d, {
              icon: unref(o).icons.edit
            }, null, 8, ["icon"])
          ])) : createCommentVNode("", true)
        ], 16)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["fs-editable-inner", { "fs-validate-error": s() }])
        }, [
          createBaseVNode("div", Jc, [
            renderSlot(l2.$slots, "edit")
          ]),
          createBaseVNode("div", Zc, [
            (openBlock(), createBlock(resolveDynamicComponent(unref(o).tooltip.name), null, {
              [unref(o).tooltip.content]: withCtx(() => [
                createBaseVNode("span", ed, toDisplayString(u()), 1)
              ]),
              [unref(o).tooltip.trigger]: withCtx(() => [
                createVNode(d, {
                  class: normalizeClass({ hidden: !s(), "error-icon": true }),
                  size: "mini",
                  icon: unref(o).icons.info
                }, null, 8, ["class", "icon"])
              ]),
              _: 2
            }, 1024)),
            l2.showAction ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              l2.loading ? (openBlock(), createBlock(d, {
                key: 0,
                size: "mini",
                spin: true,
                icon: unref(o).icons.refresh
              }, null, 8, ["icon"])) : (openBlock(), createBlock(d, {
                key: 1,
                size: "mini",
                icon: unref(o).icons.check,
                onClick: r
              }, null, 8, ["icon"])),
              createVNode(d, {
                class: normalizeClass({ hidden: l2.loading }),
                size: "mini",
                icon: unref(o).icons.close,
                onClick: i
              }, null, 8, ["class", "icon"])
            ], 64)) : createCommentVNode("", true)
          ])
        ], 2))
      ]);
    };
  }
});
var nd = defineComponent({
  name: "FsActionbar",
  props: {
    /**
     * 按钮配置
     * {
     *  add:{
     *    ...FsButton,
     *    show:true
     *  },
     *  custom:{...}
     * }
     */
    buttons: {}
  },
  emits: ["action"],
  setup(e, t) {
    function n(a, r, i) {
      const s = { key: a, btn: r, $event: i };
      if (r.click) {
        r.click(s);
        return;
      }
      if (r.onClick) {
        r.onClick(s);
        return;
      }
      t.emit("action", s);
    }
    const o = computed(() => {
      let a = [];
      for (let i in e.buttons)
        a.push({
          ...e.buttons[i],
          _key: i
        });
      a = lodash_default_default.sortBy(a, (i) => i.order ?? Kt.orderDefault);
      const r = {};
      return a.forEach((i) => {
        let s = i._key;
        delete i._key, r[s] = i;
      }), r;
    });
    return {
      onClick: n,
      computedButtons: o
    };
  }
});
var od = { class: "fs-actionbar" };
function rd(e, t, n, o, a, r) {
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", od, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (s, u) => (openBlock(), createElementBlock(Fragment, { key: u }, [
      s.show !== false ? (openBlock(), createBlock(i, mergeProps({ key: 0 }, s, {
        onClick: (l2) => e.onClick(u, s, l2)
      }), null, 16, ["onClick"])) : createCommentVNode("", true)
    ], 64))), 128))
  ]);
}
var ad = Se(nd, [["render", rd]]);
var Wh = class {
  constructor() {
    te(this, "valueChange");
    te(this, "mergeForm");
  }
};
var La = "ColumnsFilterContext";
var id = defineComponent({
  __name: "index",
  props: {
    container: { default: () => ({ is: "fs-columns-filter-layout-default" }) },
    is: {},
    show: { type: Boolean },
    mode: { default: "default" },
    columns: {},
    originalColumns: {},
    storage: { type: [Boolean, String], default: true },
    text: {}
  },
  emits: ["update:columns", "update:show"],
  setup(e, { expose: t, emit: n }) {
    const o = e, { t: a } = tt(), r = l.get(), i = ref(false), s = () => {
      i.value = true;
    }, u = computed(() => v(o.originalColumns)), l2 = ref([]), { merge: c } = Fe(), d = computed(() => {
      const N = {
        title: a("fs.toolbar.columnFilter.title"),
        fixed: a("fs.toolbar.columnFilter.fixed"),
        order: a("fs.toolbar.columnFilter.order"),
        reset: a("fs.toolbar.columnFilter.reset"),
        confirm: a("fs.toolbar.columnFilter.confirm"),
        unnamed: a("fs.toolbar.columnFilter.unnamed")
      };
      return c(N, o.text), N;
    });
    function f(N) {
      return {
        key: N.key,
        title: N.title,
        fixed: N.fixed ?? false,
        show: N.show ?? true,
        __show: N.columnSetShow !== false,
        __disabled: N.columnSetDisabled ?? false
      };
    }
    function h2(N) {
      const J = {};
      return lodash_default_default.forEach(N, (Z) => {
        J[Z.key] = Z;
      }), J;
    }
    function v(N) {
      const J = {};
      return lodash_default_default.forEach(N, (Z) => {
        const ge = f(Z);
        if (Z.children) {
          const z = v(Z.children);
          for (let se in z)
            J[se] = z[se];
        } else
          J[ge.key] = ge;
      }), J;
    }
    function p(N) {
      const J = [];
      return lodash_default_default.forEach(N, (Z) => {
        const ge = f(Z);
        if (Z.children) {
          const z = p(Z.children);
          for (let se of z)
            J.push(se);
        } else
          J.push(ge);
      }), J;
    }
    function F(N) {
      l2.value = p(N);
    }
    function _() {
      l2.value = p(o.originalColumns), D(true), x();
    }
    function D(N = false) {
      N || O(l2.value);
      const J = lodash_default_default.cloneDeep(l2.value);
      J.forEach((Z) => {
        Z && (delete Z.__disabled, delete Z.__show);
      }), E(J), i.value = false;
    }
    provide(La, { originalColumns: u, currentColumns: l2, text: d, active: i, submit: D, reset: _ });
    function k() {
      D(false), n("update:show", false);
    }
    function A() {
      _(), n("update:show", false);
    }
    function E(N) {
      n("update:columns", h2(N));
    }
    const $ = ref();
    function S() {
      if ($.value == null) {
        const N = useRoute();
        $.value = new fa({
          $router: N,
          tableName: "columnsFilter",
          keyType: o.storage
        });
      }
      return $.value;
    }
    function O(N) {
      if (o.storage === false)
        return;
      const J = [];
      for (let Z = 0; Z < N.length; Z++) {
        const ge = N[Z];
        J.push(ge);
      }
      S().updateTableValue(J);
    }
    function B() {
      if (o.storage !== false)
        return S().getTableValue();
    }
    function x() {
      S().clearTableValue();
    }
    function Q(N) {
      const J = [];
      lodash_default_default.forEach(N, (ge) => {
        const z = lodash_default_default.pick(ge, "key", "__show", "__disabled");
        J.push(JSON.stringify(z));
      }), J.sort();
      let Z = "";
      for (const ge of J)
        Z += ge;
      return Z;
    }
    watch(
      () => o.columns,
      (N) => {
        F(N);
      }
    ), (() => {
      F(o.columns);
      const N = B();
      if (N) {
        const J = Q(N);
        if (Q(u.value) !== J)
          return;
        const ge = [];
        for (const z of N) {
          const se = l2.value.find((C) => C.key === z.key);
          se && (se.fixed = z.fixed, se.show = z.show, ge.push(se));
        }
        l2.value = ge, nextTick(() => {
          D(true);
        });
      }
    })(), t({
      start: s,
      original: u,
      columns: l2
    });
    function M(N) {
      return N.label || N.title || N.key || d.value.unnamed;
    }
    return (N, J) => {
      var ge;
      const Z = resolveComponent("fs-button");
      return N.mode === "simple" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        (openBlock(), createBlock(resolveDynamicComponent(unref(r).row.name), { class: "fs-table-columns-filter-simple" }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(l2.value, (z, se) => {
              var C;
              return withDirectives((openBlock(), createBlock(resolveDynamicComponent(unref(r).col.name), {
                key: se,
                span: 6
              }, {
                default: withCtx(() => {
                  var m;
                  return [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(r).checkbox.name), normalizeProps({
                      [unref(r).checkbox.modelValue]: z.show,
                      ["onUpdate:" + unref(r).checkbox.modelValue]: (b) => z.show = b,
                      disabled: ((m = u.value[z.key]) == null ? void 0 : m.__disabled) === true,
                      class: "item-label",
                      title: M(z)
                    }), {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(M(z)), 1)
                      ]),
                      _: 2
                    }, 1040, ["disabled", "title"]))
                  ];
                }),
                _: 2
              }, 1024)), [
                [vShow, ((C = u.value[z.key]) == null ? void 0 : C.__show) !== false]
              ]);
            }), 128))
          ]),
          _: 1
        })),
        (openBlock(), createBlock(resolveDynamicComponent(unref(r).divider.name))),
        (openBlock(), createBlock(resolveDynamicComponent(unref(r).row.name), null, {
          default: withCtx(() => [
            createVNode(Z, {
              style: { "margin-right": "5px" },
              type: "primary",
              icon: unref(r).icons.check,
              text: d.value.confirm,
              onClick: J[0] || (J[0] = (z) => k())
            }, null, 8, ["icon", "text"]),
            createVNode(Z, {
              icon: unref(r).icons.refresh,
              text: d.value.reset,
              onClick: A
            }, null, 8, ["icon", "text"])
          ]),
          _: 1
        }))
      ], 64)) : (openBlock(), createBlock(resolveDynamicComponent(((ge = N.container) == null ? void 0 : ge.is) || "fs-columns-filter-layout-default"), normalizeProps(mergeProps({ key: 1 }, N.container)), {
        buttons: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(r).row.name), {
            class: "fs-drawer-footer",
            gutter: 10
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(unref(r).col.name), { span: 12 }, {
                default: withCtx(() => [
                  createVNode(Z, {
                    icon: unref(r).icons.refresh,
                    text: d.value.reset,
                    block: "",
                    onClick: _
                  }, null, 8, ["icon", "text"])
                ]),
                _: 1
              })),
              (openBlock(), createBlock(resolveDynamicComponent(unref(r).col.name), { span: 12 }, {
                default: withCtx(() => [
                  createVNode(Z, {
                    type: "primary",
                    icon: unref(r).icons.check,
                    text: d.value.confirm,
                    block: "",
                    onClick: J[1] || (J[1] = (z) => D(false))
                  }, null, 8, ["icon", "text"])
                ]),
                _: 1
              }))
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 16));
    };
  }
});
var sd = defineComponent({
  name: "FsToolbar",
  components: { FsTableColumnsFilter: id },
  props: {
    /**
     * 按钮配置
     *{
     *   search:{}, 查询
     *   refresh:{}, 刷新
     *   compact:{}, 紧凑模式
     *   export:{}, 导出
     *   columns:{} 列设置
     *}
     **/
    buttons: {
      type: Object
    },
    /**
     * 当前是否紧凑模式
     */
    compact: {
      type: Boolean,
      default: true
    },
    /**
     * 列配置
     */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 是否保存用户列设置
     * 传string则表示传入缓存的主key
     */
    storage: {
      type: [String, Boolean],
      default: true
    },
    /**
     * 插槽
     */
    slots: {},
    /**
     * 列设置配置
     */
    columnsFilter: {
      type: Object
    }
  },
  emits: ["update:columns"],
  setup(e, t) {
    tt();
    const n = ref(), { ui: o } = w(), { merge: a } = Fe(), r = computed(() => {
      const u = {
        columns: {
          click: () => {
            n.value.start();
          }
        }
      };
      a(u, e.buttons);
      let l2 = [];
      for (let d in u)
        l2.push({
          ...u[d],
          _key: d
        });
      l2 = lodash_default_default.sortBy(l2, (d) => d.order ?? Kt.orderDefault);
      const c = {};
      return l2.forEach((d) => {
        let f = d._key;
        delete d._key, c[f] = d;
      }), c;
    }), i = ref(false);
    return {
      ui: o,
      columnsFilterRef: n,
      computedButtons: r,
      popoverVisible: i,
      handleSimpleClick: () => {
        o.type !== "element" && (i.value = !i.value);
      }
    };
  }
});
var ld = { class: "fs-toolbar" };
function ud(e, t, n, o, a, r) {
  var s;
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", ld, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (u, l2) => {
      var c;
      return openBlock(), createElementBlock(Fragment, { key: l2 }, [
        u.show !== false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          l2 === "columns" && e.columnsFilter && ((c = e.columnsFilter) == null ? void 0 : c.mode) === "simple" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.popover.name), normalizeProps({
            key: 0,
            [e.ui.popover.visible]: e.popoverVisible,
            ["onUpdate:" + e.ui.popover.visible]: t[2] || (t[2] = (d) => e.popoverVisible = d),
            "display-directive": "show",
            placement: "bottom",
            width: 760,
            trigger: "click"
          }), {
            [e.ui.popover.triggerSlotName]: withCtx(() => [
              createVNode(i, mergeProps(u, { onClick: e.handleSimpleClick }), null, 16, ["onClick"])
            ]),
            [e.ui.popover.contentSlotName]: withCtx(() => [
              e.columns ? (openBlock(), createBlock(resolveDynamicComponent(e.columnsFilter.is || "fs-table-columns-filter"), mergeProps({
                key: 0,
                ref_for: true,
                ref: "columnsFilterRef",
                show: e.popoverVisible,
                "onUpdate:show": t[0] || (t[0] = (d) => e.popoverVisible = d),
                mode: "simple"
              }, e.columnsFilter, {
                columns: e.columns,
                storage: e.storage,
                "onUpdate:columns": t[1] || (t[1] = (d) => e.$emit("update:columns", d))
              }), null, 16, ["show", "columns", "storage"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1040)) : (openBlock(), createBlock(i, mergeProps({ key: 1 }, u, {
            onClick: (d) => u.click()
          }), null, 16, ["onClick"]))
        ], 64)) : createCommentVNode("", true)
      ], 64);
    }), 128)),
    e.columns && ((s = e.columnsFilter) == null ? void 0 : s.mode) !== "simple" ? (openBlock(), createBlock(resolveDynamicComponent(e.columnsFilter.is || "fs-table-columns-filter"), mergeProps({
      key: 0,
      ref: "columnsFilterRef"
    }, e.columnsFilter, {
      columns: e.columns,
      storage: e.storage,
      "onUpdate:columns": t[3] || (t[3] = (u) => e.$emit("update:columns", u))
    }), null, 16, ["columns", "storage"])) : createCommentVNode("", true)
  ]);
}
var cd = Se(sd, [["render", ud]]);
function Ur(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Ot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ur(Object(n), true).forEach(function(o) {
      dd(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ur(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function fo(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fo = function(t) {
    return typeof t;
  } : fo = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fo(e);
}
function dd(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = n, e;
}
function Vt() {
  return Vt = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Vt.apply(this, arguments);
}
function fd(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), a, r;
  for (r = 0; r < o.length; r++)
    a = o[r], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function hd(e, t) {
  if (e == null)
    return {};
  var n = fd(e, t), o, a;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    for (a = 0; a < r.length; a++)
      o = r[a], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
var md = "1.14.0";
function Pt(e) {
  if (typeof window < "u" && window.navigator)
    return !!navigator.userAgent.match(e);
}
var Mt = Pt(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Xn = Pt(/Edge/i);
var Yr = Pt(/firefox/i);
var In = Pt(/safari/i) && !Pt(/chrome/i) && !Pt(/android/i);
var qa = Pt(/iP(ad|od|hone)/i);
var pd = Pt(/chrome/i) && Pt(/android/i);
var Ha = {
  capture: false,
  passive: false
};
function Ce(e, t, n) {
  e.addEventListener(t, n, !Mt && Ha);
}
function _e(e, t, n) {
  e.removeEventListener(t, n, !Mt && Ha);
}
function yo(e, t) {
  if (t) {
    if (t[0] === ">" && (t = t.substring(1)), e)
      try {
        if (e.matches)
          return e.matches(t);
        if (e.msMatchesSelector)
          return e.msMatchesSelector(t);
        if (e.webkitMatchesSelector)
          return e.webkitMatchesSelector(t);
      } catch {
        return false;
      }
    return false;
  }
}
function gd(e) {
  return e.host && e !== document && e.host.nodeType ? e.host : e.parentNode;
}
function Ct(e, t, n, o) {
  if (e) {
    n = n || document;
    do {
      if (t != null && (t[0] === ">" ? e.parentNode === n && yo(e, t) : yo(e, t)) || o && e === n)
        return e;
      if (e === n)
        break;
    } while (e = gd(e));
  }
  return null;
}
var Kr = /\s+/g;
function ot(e, t, n) {
  if (e && t)
    if (e.classList)
      e.classList[n ? "add" : "remove"](t);
    else {
      var o = (" " + e.className + " ").replace(Kr, " ").replace(" " + t + " ", " ");
      e.className = (o + (n ? " " + t : "")).replace(Kr, " ");
    }
}
function ce(e, t, n) {
  var o = e && e.style;
  if (o) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(e, "") : e.currentStyle && (n = e.currentStyle), t === void 0 ? n : n[t];
    !(t in o) && t.indexOf("webkit") === -1 && (t = "-webkit-" + t), o[t] = n + (typeof n == "string" ? "" : "px");
  }
}
function hn(e, t) {
  var n = "";
  if (typeof e == "string")
    n = e;
  else
    do {
      var o = ce(e, "transform");
      o && o !== "none" && (n = o + " " + n);
    } while (!t && (e = e.parentNode));
  var a = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return a && new a(n);
}
function Wa(e, t, n) {
  if (e) {
    var o = e.getElementsByTagName(t), a = 0, r = o.length;
    if (n)
      for (; a < r; a++)
        n(o[a], a);
    return o;
  }
  return [];
}
function kt() {
  var e = document.scrollingElement;
  return e || document.documentElement;
}
function Ne(e, t, n, o, a) {
  if (!(!e.getBoundingClientRect && e !== window)) {
    var r, i, s, u, l2, c, d;
    if (e !== window && e.parentNode && e !== kt() ? (r = e.getBoundingClientRect(), i = r.top, s = r.left, u = r.bottom, l2 = r.right, c = r.height, d = r.width) : (i = 0, s = 0, u = window.innerHeight, l2 = window.innerWidth, c = window.innerHeight, d = window.innerWidth), (t || n) && e !== window && (a = a || e.parentNode, !Mt))
      do
        if (a && a.getBoundingClientRect && (ce(a, "transform") !== "none" || n && ce(a, "position") !== "static")) {
          var f = a.getBoundingClientRect();
          i -= f.top + parseInt(ce(a, "border-top-width")), s -= f.left + parseInt(ce(a, "border-left-width")), u = i + r.height, l2 = s + r.width;
          break;
        }
      while (a = a.parentNode);
    if (o && e !== window) {
      var h2 = hn(a || e), v = h2 && h2.a, p = h2 && h2.d;
      h2 && (i /= p, s /= v, d /= v, c /= p, u = i + c, l2 = s + d);
    }
    return {
      top: i,
      left: s,
      bottom: u,
      right: l2,
      width: d,
      height: c
    };
  }
}
function Gr(e, t, n) {
  for (var o = xt(e, true), a = Ne(e)[t]; o; ) {
    var r = Ne(o)[n], i = void 0;
    if (n === "top" || n === "left" ? i = a >= r : i = a <= r, !i)
      return o;
    if (o === kt())
      break;
    o = xt(o, false);
  }
  return false;
}
function yn(e, t, n, o) {
  for (var a = 0, r = 0, i = e.children; r < i.length; ) {
    if (i[r].style.display !== "none" && i[r] !== de.ghost && (o || i[r] !== de.dragged) && Ct(i[r], n.draggable, e, false)) {
      if (a === t)
        return i[r];
      a++;
    }
    r++;
  }
  return null;
}
function Dr(e, t) {
  for (var n = e.lastElementChild; n && (n === de.ghost || ce(n, "display") === "none" || t && !yo(n, t)); )
    n = n.previousElementSibling;
  return n || null;
}
function dt(e, t) {
  var n = 0;
  if (!e || !e.parentNode)
    return -1;
  for (; e = e.previousElementSibling; )
    e.nodeName.toUpperCase() !== "TEMPLATE" && e !== de.clone && (!t || yo(e, t)) && n++;
  return n;
}
function Xr(e) {
  var t = 0, n = 0, o = kt();
  if (e)
    do {
      var a = hn(e), r = a.a, i = a.d;
      t += e.scrollLeft * r, n += e.scrollTop * i;
    } while (e !== o && (e = e.parentNode));
  return [t, n];
}
function vd(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      for (var o in t)
        if (t.hasOwnProperty(o) && t[o] === e[n][o])
          return Number(n);
    }
  return -1;
}
function xt(e, t) {
  if (!e || !e.getBoundingClientRect)
    return kt();
  var n = e, o = false;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var a = ce(n);
      if (n.clientWidth < n.scrollWidth && (a.overflowX == "auto" || a.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (a.overflowY == "auto" || a.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return kt();
        if (o || t)
          return n;
        o = true;
      }
    }
  while (n = n.parentNode);
  return kt();
}
function bd(e, t) {
  if (e && t)
    for (var n in t)
      t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
function No(e, t) {
  return Math.round(e.top) === Math.round(t.top) && Math.round(e.left) === Math.round(t.left) && Math.round(e.height) === Math.round(t.height) && Math.round(e.width) === Math.round(t.width);
}
var Pn;
function xa(e, t) {
  return function() {
    if (!Pn) {
      var n = arguments, o = this;
      n.length === 1 ? e.call(o, n[0]) : e.apply(o, n), Pn = setTimeout(function() {
        Pn = void 0;
      }, t);
    }
  };
}
function yd() {
  clearTimeout(Pn), Pn = void 0;
}
function za(e, t, n) {
  e.scrollLeft += t, e.scrollTop += n;
}
function Ua(e) {
  var t = window.Polymer, n = window.jQuery || window.Zepto;
  return t && t.dom ? t.dom(e).cloneNode(true) : n ? n(e).clone(true)[0] : e.cloneNode(true);
}
var lt = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function wd() {
  var e = [], t;
  return {
    captureAnimationState: function() {
      if (e = [], !!this.options.animation) {
        var o = [].slice.call(this.el.children);
        o.forEach(function(a) {
          if (!(ce(a, "display") === "none" || a === de.ghost)) {
            e.push({
              target: a,
              rect: Ne(a)
            });
            var r = Ot({}, e[e.length - 1].rect);
            if (a.thisAnimationDuration) {
              var i = hn(a, true);
              i && (r.top -= i.f, r.left -= i.e);
            }
            a.fromRect = r;
          }
        });
      }
    },
    addAnimationState: function(o) {
      e.push(o);
    },
    removeAnimationState: function(o) {
      e.splice(vd(e, {
        target: o
      }), 1);
    },
    animateAll: function(o) {
      var a = this;
      if (!this.options.animation) {
        clearTimeout(t), typeof o == "function" && o();
        return;
      }
      var r = false, i = 0;
      e.forEach(function(s) {
        var u = 0, l2 = s.target, c = l2.fromRect, d = Ne(l2), f = l2.prevFromRect, h2 = l2.prevToRect, v = s.rect, p = hn(l2, true);
        p && (d.top -= p.f, d.left -= p.e), l2.toRect = d, l2.thisAnimationDuration && No(f, d) && !No(c, d) && // Make sure animatingRect is on line between toRect & fromRect
        (v.top - d.top) / (v.left - d.left) === (c.top - d.top) / (c.left - d.left) && (u = Cd(v, f, h2, a.options)), No(d, c) || (l2.prevFromRect = c, l2.prevToRect = d, u || (u = a.options.animation), a.animate(l2, v, d, u)), u && (r = true, i = Math.max(i, u), clearTimeout(l2.animationResetTimer), l2.animationResetTimer = setTimeout(function() {
          l2.animationTime = 0, l2.prevFromRect = null, l2.fromRect = null, l2.prevToRect = null, l2.thisAnimationDuration = null;
        }, u), l2.thisAnimationDuration = u);
      }), clearTimeout(t), r ? t = setTimeout(function() {
        typeof o == "function" && o();
      }, i) : typeof o == "function" && o(), e = [];
    },
    animate: function(o, a, r, i) {
      if (i) {
        ce(o, "transition", ""), ce(o, "transform", "");
        var s = hn(this.el), u = s && s.a, l2 = s && s.d, c = (a.left - r.left) / (u || 1), d = (a.top - r.top) / (l2 || 1);
        o.animatingX = !!c, o.animatingY = !!d, ce(o, "transform", "translate3d(" + c + "px," + d + "px,0)"), this.forRepaintDummy = _d(o), ce(o, "transition", "transform " + i + "ms" + (this.options.easing ? " " + this.options.easing : "")), ce(o, "transform", "translate3d(0,0,0)"), typeof o.animated == "number" && clearTimeout(o.animated), o.animated = setTimeout(function() {
          ce(o, "transition", ""), ce(o, "transform", ""), o.animated = false, o.animatingX = false, o.animatingY = false;
        }, i);
      }
    }
  };
}
function _d(e) {
  return e.offsetWidth;
}
function Cd(e, t, n, o) {
  return Math.sqrt(Math.pow(t.top - e.top, 2) + Math.pow(t.left - e.left, 2)) / Math.sqrt(Math.pow(t.top - n.top, 2) + Math.pow(t.left - n.left, 2)) * o.animation;
}
var ln = [];
var Lo = {
  initializeByDefault: true
};
var Qn = {
  mount: function(t) {
    for (var n in Lo)
      Lo.hasOwnProperty(n) && !(n in t) && (t[n] = Lo[n]);
    ln.forEach(function(o) {
      if (o.pluginName === t.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(t.pluginName, " more than once");
    }), ln.push(t);
  },
  pluginEvent: function(t, n, o) {
    var a = this;
    this.eventCanceled = false, o.cancel = function() {
      a.eventCanceled = true;
    };
    var r = t + "Global";
    ln.forEach(function(i) {
      n[i.pluginName] && (n[i.pluginName][r] && n[i.pluginName][r](Ot({
        sortable: n
      }, o)), n.options[i.pluginName] && n[i.pluginName][t] && n[i.pluginName][t](Ot({
        sortable: n
      }, o)));
    });
  },
  initializePlugins: function(t, n, o, a) {
    ln.forEach(function(s) {
      var u = s.pluginName;
      if (!(!t.options[u] && !s.initializeByDefault)) {
        var l2 = new s(t, n, t.options);
        l2.sortable = t, l2.options = t.options, t[u] = l2, Vt(o, l2.defaults);
      }
    });
    for (var r in t.options)
      if (t.options.hasOwnProperty(r)) {
        var i = this.modifyOption(t, r, t.options[r]);
        typeof i < "u" && (t.options[r] = i);
      }
  },
  getEventProperties: function(t, n) {
    var o = {};
    return ln.forEach(function(a) {
      typeof a.eventProperties == "function" && Vt(o, a.eventProperties.call(n[a.pluginName], t));
    }), o;
  },
  modifyOption: function(t, n, o) {
    var a;
    return ln.forEach(function(r) {
      t[r.pluginName] && r.optionListeners && typeof r.optionListeners[n] == "function" && (a = r.optionListeners[n].call(t[r.pluginName], o));
    }), a;
  }
};
function Fd(e) {
  var t = e.sortable, n = e.rootEl, o = e.name, a = e.targetEl, r = e.cloneEl, i = e.toEl, s = e.fromEl, u = e.oldIndex, l2 = e.newIndex, c = e.oldDraggableIndex, d = e.newDraggableIndex, f = e.originalEvent, h2 = e.putSortable, v = e.extraEventProperties;
  if (t = t || n && n[lt], !!t) {
    var p, F = t.options, _ = "on" + o.charAt(0).toUpperCase() + o.substr(1);
    window.CustomEvent && !Mt && !Xn ? p = new CustomEvent(o, {
      bubbles: true,
      cancelable: true
    }) : (p = document.createEvent("Event"), p.initEvent(o, true, true)), p.to = i || n, p.from = s || n, p.item = a || n, p.clone = r, p.oldIndex = u, p.newIndex = l2, p.oldDraggableIndex = c, p.newDraggableIndex = d, p.originalEvent = f, p.pullMode = h2 ? h2.lastPutMode : void 0;
    var D = Ot(Ot({}, v), Qn.getEventProperties(o, t));
    for (var k in D)
      p[k] = D[k];
    n && n.dispatchEvent(p), F[_] && F[_].call(t, p);
  }
}
var Sd = ["evt"];
var Ze = function(t, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = o.evt, r = hd(o, Sd);
  Qn.pluginEvent.bind(de)(t, n, Ot({
    dragEl: L,
    parentEl: Te,
    ghostEl: pe,
    rootEl: ke,
    nextEl: Jt,
    lastDownEl: ho,
    cloneEl: Ae,
    cloneHidden: Ht,
    dragStarted: On,
    putSortable: We,
    activeSortable: de.active,
    originalEvent: a,
    oldIndex: fn,
    oldDraggableIndex: Vn,
    newIndex: rt,
    newDraggableIndex: qt,
    hideGhostForTarget: Xa,
    unhideGhostForTarget: Qa,
    cloneNowHidden: function() {
      Ht = true;
    },
    cloneNowShown: function() {
      Ht = false;
    },
    dispatchSortableEvent: function(s) {
      Xe({
        sortable: n,
        name: s,
        originalEvent: a
      });
    }
  }, r));
};
function Xe(e) {
  Fd(Ot({
    putSortable: We,
    cloneEl: Ae,
    targetEl: L,
    rootEl: ke,
    oldIndex: fn,
    oldDraggableIndex: Vn,
    newIndex: rt,
    newDraggableIndex: qt
  }, e));
}
var L;
var Te;
var pe;
var ke;
var Jt;
var ho;
var Ae;
var Ht;
var fn;
var rt;
var Vn;
var qt;
var no;
var We;
var cn = false;
var wo = false;
var _o = [];
var Xt;
var ft;
var qo;
var Ho;
var Qr;
var Jr;
var On;
var un;
var Mn;
var jn = false;
var oo = false;
var mo;
var Ye;
var Wo = [];
var fr = false;
var Co = [];
var Io = typeof document < "u";
var ro = qa;
var Zr = Xn || Mt ? "cssFloat" : "float";
var Ed = Io && !pd && !qa && "draggable" in document.createElement("div");
var Ya = function() {
  if (Io) {
    if (Mt)
      return false;
    var e = document.createElement("x");
    return e.style.cssText = "pointer-events:auto", e.style.pointerEvents === "auto";
  }
}();
var Ka = function(t, n) {
  var o = ce(t), a = parseInt(o.width) - parseInt(o.paddingLeft) - parseInt(o.paddingRight) - parseInt(o.borderLeftWidth) - parseInt(o.borderRightWidth), r = yn(t, 0, n), i = yn(t, 1, n), s = r && ce(r), u = i && ce(i), l2 = s && parseInt(s.marginLeft) + parseInt(s.marginRight) + Ne(r).width, c = u && parseInt(u.marginLeft) + parseInt(u.marginRight) + Ne(i).width;
  if (o.display === "flex")
    return o.flexDirection === "column" || o.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (o.display === "grid")
    return o.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (r && s.float && s.float !== "none") {
    var d = s.float === "left" ? "left" : "right";
    return i && (u.clear === "both" || u.clear === d) ? "vertical" : "horizontal";
  }
  return r && (s.display === "block" || s.display === "flex" || s.display === "table" || s.display === "grid" || l2 >= a && o[Zr] === "none" || i && o[Zr] === "none" && l2 + c > a) ? "vertical" : "horizontal";
};
var Dd = function(t, n, o) {
  var a = o ? t.left : t.top, r = o ? t.right : t.bottom, i = o ? t.width : t.height, s = o ? n.left : n.top, u = o ? n.right : n.bottom, l2 = o ? n.width : n.height;
  return a === s || r === u || a + i / 2 === s + l2 / 2;
};
var Rd = function(t, n) {
  var o;
  return _o.some(function(a) {
    var r = a[lt].options.emptyInsertThreshold;
    if (!(!r || Dr(a))) {
      var i = Ne(a), s = t >= i.left - r && t <= i.right + r, u = n >= i.top - r && n <= i.bottom + r;
      if (s && u)
        return o = a;
    }
  }), o;
};
var Ga = function(t) {
  function n(r, i) {
    return function(s, u, l2, c) {
      var d = s.options.group.name && u.options.group.name && s.options.group.name === u.options.group.name;
      if (r == null && (i || d))
        return true;
      if (r == null || r === false)
        return false;
      if (i && r === "clone")
        return r;
      if (typeof r == "function")
        return n(r(s, u, l2, c), i)(s, u, l2, c);
      var f = (i ? s : u).options.group.name;
      return r === true || typeof r == "string" && r === f || r.join && r.indexOf(f) > -1;
    };
  }
  var o = {}, a = t.group;
  (!a || fo(a) != "object") && (a = {
    name: a
  }), o.name = a.name, o.checkPull = n(a.pull, true), o.checkPut = n(a.put), o.revertClone = a.revertClone, t.group = o;
};
var Xa = function() {
  !Ya && pe && ce(pe, "display", "none");
};
var Qa = function() {
  !Ya && pe && ce(pe, "display", "");
};
Io && document.addEventListener("click", function(e) {
  if (wo)
    return e.preventDefault(), e.stopPropagation && e.stopPropagation(), e.stopImmediatePropagation && e.stopImmediatePropagation(), wo = false, false;
}, true);
var Qt = function(t) {
  if (L) {
    t = t.touches ? t.touches[0] : t;
    var n = Rd(t.clientX, t.clientY);
    if (n) {
      var o = {};
      for (var a in t)
        t.hasOwnProperty(a) && (o[a] = t[a]);
      o.target = o.rootEl = n, o.preventDefault = void 0, o.stopPropagation = void 0, n[lt]._onDragOver(o);
    }
  }
};
var kd = function(t) {
  L && L.parentNode[lt]._isOutsideThisEl(t.target);
};
function de(e, t) {
  if (!(e && e.nodeType && e.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(e));
  this.el = e, this.options = t = Vt({}, t), e[lt] = this;
  var n = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(e.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function() {
      return Ka(e, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function(i, s) {
      i.setData("Text", s.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: de.supportPointer !== false && "PointerEvent" in window && !In,
    emptyInsertThreshold: 5
  };
  Qn.initializePlugins(this, e, n);
  for (var o in n)
    !(o in t) && (t[o] = n[o]);
  Ga(t);
  for (var a in this)
    a.charAt(0) === "_" && typeof this[a] == "function" && (this[a] = this[a].bind(this));
  this.nativeDraggable = t.forceFallback ? false : Ed, this.nativeDraggable && (this.options.touchStartThreshold = 1), t.supportPointer ? Ce(e, "pointerdown", this._onTapStart) : (Ce(e, "mousedown", this._onTapStart), Ce(e, "touchstart", this._onTapStart)), this.nativeDraggable && (Ce(e, "dragover", this), Ce(e, "dragenter", this)), _o.push(this.el), t.store && t.store.get && this.sort(t.store.get(this) || []), Vt(this, wd());
}
de.prototype = /** @lends Sortable.prototype */
{
  constructor: de,
  _isOutsideThisEl: function(t) {
    !this.el.contains(t) && t !== this.el && (un = null);
  },
  _getDirection: function(t, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, t, n, L) : this.options.direction;
  },
  _onTapStart: function(t) {
    if (t.cancelable) {
      var n = this, o = this.el, a = this.options, r = a.preventOnFilter, i = t.type, s = t.touches && t.touches[0] || t.pointerType && t.pointerType === "touch" && t, u = (s || t).target, l2 = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || u, c = a.filter;
      if (Md(o), !L && !(/mousedown|pointerdown/.test(i) && t.button !== 0 || a.disabled) && !l2.isContentEditable && !(!this.nativeDraggable && In && u && u.tagName.toUpperCase() === "SELECT") && (u = Ct(u, a.draggable, o, false), !(u && u.animated) && ho !== u)) {
        if (fn = dt(u), Vn = dt(u, a.draggable), typeof c == "function") {
          if (c.call(this, t, u, this)) {
            Xe({
              sortable: n,
              rootEl: l2,
              name: "filter",
              targetEl: u,
              toEl: o,
              fromEl: o
            }), Ze("filter", n, {
              evt: t
            }), r && t.cancelable && t.preventDefault();
            return;
          }
        } else if (c && (c = c.split(",").some(function(d) {
          if (d = Ct(l2, d.trim(), o, false), d)
            return Xe({
              sortable: n,
              rootEl: d,
              name: "filter",
              targetEl: u,
              fromEl: o,
              toEl: o
            }), Ze("filter", n, {
              evt: t
            }), true;
        }), c)) {
          r && t.cancelable && t.preventDefault();
          return;
        }
        a.handle && !Ct(l2, a.handle, o, false) || this._prepareDragStart(t, s, u);
      }
    }
  },
  _prepareDragStart: function(t, n, o) {
    var a = this, r = a.el, i = a.options, s = r.ownerDocument, u;
    if (o && !L && o.parentNode === r) {
      var l2 = Ne(o);
      if (ke = r, L = o, Te = L.parentNode, Jt = L.nextSibling, ho = o, no = i.group, de.dragged = L, Xt = {
        target: L,
        clientX: (n || t).clientX,
        clientY: (n || t).clientY
      }, Qr = Xt.clientX - l2.left, Jr = Xt.clientY - l2.top, this._lastX = (n || t).clientX, this._lastY = (n || t).clientY, L.style["will-change"] = "all", u = function() {
        if (Ze("delayEnded", a, {
          evt: t
        }), de.eventCanceled) {
          a._onDrop();
          return;
        }
        a._disableDelayedDragEvents(), !Yr && a.nativeDraggable && (L.draggable = true), a._triggerDragStart(t, n), Xe({
          sortable: a,
          name: "choose",
          originalEvent: t
        }), ot(L, i.chosenClass, true);
      }, i.ignore.split(",").forEach(function(c) {
        Wa(L, c.trim(), xo);
      }), Ce(s, "dragover", Qt), Ce(s, "mousemove", Qt), Ce(s, "touchmove", Qt), Ce(s, "mouseup", a._onDrop), Ce(s, "touchend", a._onDrop), Ce(s, "touchcancel", a._onDrop), Yr && this.nativeDraggable && (this.options.touchStartThreshold = 4, L.draggable = true), Ze("delayStart", this, {
        evt: t
      }), i.delay && (!i.delayOnTouchOnly || n) && (!this.nativeDraggable || !(Xn || Mt))) {
        if (de.eventCanceled) {
          this._onDrop();
          return;
        }
        Ce(s, "mouseup", a._disableDelayedDrag), Ce(s, "touchend", a._disableDelayedDrag), Ce(s, "touchcancel", a._disableDelayedDrag), Ce(s, "mousemove", a._delayedDragTouchMoveHandler), Ce(s, "touchmove", a._delayedDragTouchMoveHandler), i.supportPointer && Ce(s, "pointermove", a._delayedDragTouchMoveHandler), a._dragStartTimer = setTimeout(u, i.delay);
      } else
        u();
    }
  },
  _delayedDragTouchMoveHandler: function(t) {
    var n = t.touches ? t.touches[0] : t;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    L && xo(L), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var t = this.el.ownerDocument;
    _e(t, "mouseup", this._disableDelayedDrag), _e(t, "touchend", this._disableDelayedDrag), _e(t, "touchcancel", this._disableDelayedDrag), _e(t, "mousemove", this._delayedDragTouchMoveHandler), _e(t, "touchmove", this._delayedDragTouchMoveHandler), _e(t, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(t, n) {
    n = n || t.pointerType == "touch" && t, !this.nativeDraggable || n ? this.options.supportPointer ? Ce(document, "pointermove", this._onTouchMove) : n ? Ce(document, "touchmove", this._onTouchMove) : Ce(document, "mousemove", this._onTouchMove) : (Ce(L, "dragend", this), Ce(ke, "dragstart", this._onDragStart));
    try {
      document.selection ? po(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(t, n) {
    if (cn = false, ke && L) {
      Ze("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && Ce(document, "dragover", kd);
      var o = this.options;
      !t && ot(L, o.dragClass, false), ot(L, o.ghostClass, true), de.active = this, t && this._appendGhost(), Xe({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (ft) {
      this._lastX = ft.clientX, this._lastY = ft.clientY, Xa();
      for (var t = document.elementFromPoint(ft.clientX, ft.clientY), n = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ft.clientX, ft.clientY), t !== n); )
        n = t;
      if (L.parentNode[lt]._isOutsideThisEl(t), n)
        do {
          if (n[lt]) {
            var o = void 0;
            if (o = n[lt]._onDragOver({
              clientX: ft.clientX,
              clientY: ft.clientY,
              target: t,
              rootEl: n
            }), o && !this.options.dragoverBubble)
              break;
          }
          t = n;
        } while (n = n.parentNode);
      Qa();
    }
  },
  _onTouchMove: function(t) {
    if (Xt) {
      var n = this.options, o = n.fallbackTolerance, a = n.fallbackOffset, r = t.touches ? t.touches[0] : t, i = pe && hn(pe, true), s = pe && i && i.a, u = pe && i && i.d, l2 = ro && Ye && Xr(Ye), c = (r.clientX - Xt.clientX + a.x) / (s || 1) + (l2 ? l2[0] - Wo[0] : 0) / (s || 1), d = (r.clientY - Xt.clientY + a.y) / (u || 1) + (l2 ? l2[1] - Wo[1] : 0) / (u || 1);
      if (!de.active && !cn) {
        if (o && Math.max(Math.abs(r.clientX - this._lastX), Math.abs(r.clientY - this._lastY)) < o)
          return;
        this._onDragStart(t, true);
      }
      if (pe) {
        i ? (i.e += c - (qo || 0), i.f += d - (Ho || 0)) : i = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: c,
          f: d
        };
        var f = "matrix(".concat(i.a, ",").concat(i.b, ",").concat(i.c, ",").concat(i.d, ",").concat(i.e, ",").concat(i.f, ")");
        ce(pe, "webkitTransform", f), ce(pe, "mozTransform", f), ce(pe, "msTransform", f), ce(pe, "transform", f), qo = c, Ho = d, ft = r;
      }
      t.cancelable && t.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!pe) {
      var t = this.options.fallbackOnBody ? document.body : ke, n = Ne(L, true, ro, true, t), o = this.options;
      if (ro) {
        for (Ye = t; ce(Ye, "position") === "static" && ce(Ye, "transform") === "none" && Ye !== document; )
          Ye = Ye.parentNode;
        Ye !== document.body && Ye !== document.documentElement ? (Ye === document && (Ye = kt()), n.top += Ye.scrollTop, n.left += Ye.scrollLeft) : Ye = kt(), Wo = Xr(Ye);
      }
      pe = L.cloneNode(true), ot(pe, o.ghostClass, false), ot(pe, o.fallbackClass, true), ot(pe, o.dragClass, true), ce(pe, "transition", ""), ce(pe, "transform", ""), ce(pe, "box-sizing", "border-box"), ce(pe, "margin", 0), ce(pe, "top", n.top), ce(pe, "left", n.left), ce(pe, "width", n.width), ce(pe, "height", n.height), ce(pe, "opacity", "0.8"), ce(pe, "position", ro ? "absolute" : "fixed"), ce(pe, "zIndex", "100000"), ce(pe, "pointerEvents", "none"), de.ghost = pe, t.appendChild(pe), ce(pe, "transform-origin", Qr / parseInt(pe.style.width) * 100 + "% " + Jr / parseInt(pe.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(t, n) {
    var o = this, a = t.dataTransfer, r = o.options;
    if (Ze("dragStart", this, {
      evt: t
    }), de.eventCanceled) {
      this._onDrop();
      return;
    }
    Ze("setupClone", this), de.eventCanceled || (Ae = Ua(L), Ae.draggable = false, Ae.style["will-change"] = "", this._hideClone(), ot(Ae, this.options.chosenClass, false), de.clone = Ae), o.cloneId = po(function() {
      Ze("clone", o), !de.eventCanceled && (o.options.removeCloneOnHide || ke.insertBefore(Ae, L), o._hideClone(), Xe({
        sortable: o,
        name: "clone"
      }));
    }), !n && ot(L, r.dragClass, true), n ? (wo = true, o._loopId = setInterval(o._emulateDragOver, 50)) : (_e(document, "mouseup", o._onDrop), _e(document, "touchend", o._onDrop), _e(document, "touchcancel", o._onDrop), a && (a.effectAllowed = "move", r.setData && r.setData.call(o, a, L)), Ce(document, "drop", o), ce(L, "transform", "translateZ(0)")), cn = true, o._dragStartId = po(o._dragStarted.bind(o, n, t)), Ce(document, "selectstart", o), On = true, In && ce(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(t) {
    var n = this.el, o = t.target, a, r, i, s = this.options, u = s.group, l2 = de.active, c = no === u, d = s.sort, f = We || l2, h2, v = this, p = false;
    if (fr)
      return;
    function F(z, se) {
      Ze(z, v, Ot({
        evt: t,
        isOwner: c,
        axis: h2 ? "vertical" : "horizontal",
        revert: i,
        dragRect: a,
        targetRect: r,
        canSort: d,
        fromSortable: f,
        target: o,
        completed: D,
        onMove: function(m, b) {
          return ao(ke, n, L, a, m, Ne(m), t, b);
        },
        changed: k
      }, se));
    }
    function _() {
      F("dragOverAnimationCapture"), v.captureAnimationState(), v !== f && f.captureAnimationState();
    }
    function D(z) {
      return F("dragOverCompleted", {
        insertion: z
      }), z && (c ? l2._hideClone() : l2._showClone(v), v !== f && (ot(L, We ? We.options.ghostClass : l2.options.ghostClass, false), ot(L, s.ghostClass, true)), We !== v && v !== de.active ? We = v : v === de.active && We && (We = null), f === v && (v._ignoreWhileAnimating = o), v.animateAll(function() {
        F("dragOverAnimationComplete"), v._ignoreWhileAnimating = null;
      }), v !== f && (f.animateAll(), f._ignoreWhileAnimating = null)), (o === L && !L.animated || o === n && !o.animated) && (un = null), !s.dragoverBubble && !t.rootEl && o !== document && (L.parentNode[lt]._isOutsideThisEl(t.target), !z && Qt(t)), !s.dragoverBubble && t.stopPropagation && t.stopPropagation(), p = true;
    }
    function k() {
      rt = dt(L), qt = dt(L, s.draggable), Xe({
        sortable: v,
        name: "change",
        toEl: n,
        newIndex: rt,
        newDraggableIndex: qt,
        originalEvent: t
      });
    }
    if (t.preventDefault !== void 0 && t.cancelable && t.preventDefault(), o = Ct(o, s.draggable, n, true), F("dragOver"), de.eventCanceled)
      return p;
    if (L.contains(t.target) || o.animated && o.animatingX && o.animatingY || v._ignoreWhileAnimating === o)
      return D(false);
    if (wo = false, l2 && !s.disabled && (c ? d || (i = Te !== ke) : We === this || (this.lastPutMode = no.checkPull(this, l2, L, t)) && u.checkPut(this, l2, L, t))) {
      if (h2 = this._getDirection(t, o) === "vertical", a = Ne(L), F("dragOverValid"), de.eventCanceled)
        return p;
      if (i)
        return Te = ke, _(), this._hideClone(), F("revert"), de.eventCanceled || (Jt ? ke.insertBefore(L, Jt) : ke.appendChild(L)), D(true);
      var A = Dr(n, s.draggable);
      if (!A || Ad(t, h2, this) && !A.animated) {
        if (A === L)
          return D(false);
        if (A && n === t.target && (o = A), o && (r = Ne(o)), ao(ke, n, L, a, o, r, t, !!o) !== false)
          return _(), n.appendChild(L), Te = n, k(), D(true);
      } else if (A && Td(t, h2, this)) {
        var E = yn(n, 0, s, true);
        if (E === L)
          return D(false);
        if (o = E, r = Ne(o), ao(ke, n, L, a, o, r, t, false) !== false)
          return _(), n.insertBefore(L, E), Te = n, k(), D(true);
      } else if (o.parentNode === n) {
        r = Ne(o);
        var $ = 0, S, O = L.parentNode !== n, B = !Dd(L.animated && L.toRect || a, o.animated && o.toRect || r, h2), x = h2 ? "top" : "left", Q = Gr(o, "top", "top") || Gr(L, "top", "top"), I = Q ? Q.scrollTop : void 0;
        un !== o && (S = r[x], jn = false, oo = !B && s.invertSwap || O), $ = Id(t, o, r, h2, B ? 1 : s.swapThreshold, s.invertedSwapThreshold == null ? s.swapThreshold : s.invertedSwapThreshold, oo, un === o);
        var M;
        if ($ !== 0) {
          var N = dt(L);
          do
            N -= $, M = Te.children[N];
          while (M && (ce(M, "display") === "none" || M === pe));
        }
        if ($ === 0 || M === o)
          return D(false);
        un = o, Mn = $;
        var J = o.nextElementSibling, Z = false;
        Z = $ === 1;
        var ge = ao(ke, n, L, a, o, r, t, Z);
        if (ge !== false)
          return (ge === 1 || ge === -1) && (Z = ge === 1), fr = true, setTimeout($d, 30), _(), Z && !J ? n.appendChild(L) : o.parentNode.insertBefore(L, Z ? J : o), Q && za(Q, 0, I - Q.scrollTop), Te = L.parentNode, S !== void 0 && !oo && (mo = Math.abs(S - Ne(o)[x])), k(), D(true);
      }
      if (n.contains(L))
        return D(false);
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    _e(document, "mousemove", this._onTouchMove), _e(document, "touchmove", this._onTouchMove), _e(document, "pointermove", this._onTouchMove), _e(document, "dragover", Qt), _e(document, "mousemove", Qt), _e(document, "touchmove", Qt);
  },
  _offUpEvents: function() {
    var t = this.el.ownerDocument;
    _e(t, "mouseup", this._onDrop), _e(t, "touchend", this._onDrop), _e(t, "pointerup", this._onDrop), _e(t, "touchcancel", this._onDrop), _e(document, "selectstart", this);
  },
  _onDrop: function(t) {
    var n = this.el, o = this.options;
    if (rt = dt(L), qt = dt(L, o.draggable), Ze("drop", this, {
      evt: t
    }), Te = L && L.parentNode, rt = dt(L), qt = dt(L, o.draggable), de.eventCanceled) {
      this._nulling();
      return;
    }
    cn = false, oo = false, jn = false, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), hr(this.cloneId), hr(this._dragStartId), this.nativeDraggable && (_e(document, "drop", this), _e(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), In && ce(document.body, "user-select", ""), ce(L, "transform", ""), t && (On && (t.cancelable && t.preventDefault(), !o.dropBubble && t.stopPropagation()), pe && pe.parentNode && pe.parentNode.removeChild(pe), (ke === Te || We && We.lastPutMode !== "clone") && Ae && Ae.parentNode && Ae.parentNode.removeChild(Ae), L && (this.nativeDraggable && _e(L, "dragend", this), xo(L), L.style["will-change"] = "", On && !cn && ot(L, We ? We.options.ghostClass : this.options.ghostClass, false), ot(L, this.options.chosenClass, false), Xe({
      sortable: this,
      name: "unchoose",
      toEl: Te,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: t
    }), ke !== Te ? (rt >= 0 && (Xe({
      rootEl: Te,
      name: "add",
      toEl: Te,
      fromEl: ke,
      originalEvent: t
    }), Xe({
      sortable: this,
      name: "remove",
      toEl: Te,
      originalEvent: t
    }), Xe({
      rootEl: Te,
      name: "sort",
      toEl: Te,
      fromEl: ke,
      originalEvent: t
    }), Xe({
      sortable: this,
      name: "sort",
      toEl: Te,
      originalEvent: t
    })), We && We.save()) : rt !== fn && rt >= 0 && (Xe({
      sortable: this,
      name: "update",
      toEl: Te,
      originalEvent: t
    }), Xe({
      sortable: this,
      name: "sort",
      toEl: Te,
      originalEvent: t
    })), de.active && ((rt == null || rt === -1) && (rt = fn, qt = Vn), Xe({
      sortable: this,
      name: "end",
      toEl: Te,
      originalEvent: t
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    Ze("nulling", this), ke = L = Te = pe = Jt = Ae = ho = Ht = Xt = ft = On = rt = qt = fn = Vn = un = Mn = We = no = de.dragged = de.ghost = de.clone = de.active = null, Co.forEach(function(t) {
      t.checked = true;
    }), Co.length = qo = Ho = 0;
  },
  handleEvent: function(t) {
    switch (t.type) {
      case "drop":
      case "dragend":
        this._onDrop(t);
        break;
      case "dragenter":
      case "dragover":
        L && (this._onDragOver(t), Od(t));
        break;
      case "selectstart":
        t.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var t = [], n, o = this.el.children, a = 0, r = o.length, i = this.options; a < r; a++)
      n = o[a], Ct(n, i.draggable, this.el, false) && t.push(n.getAttribute(i.dataIdAttr) || Vd(n));
    return t;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(t, n) {
    var o = {}, a = this.el;
    this.toArray().forEach(function(r, i) {
      var s = a.children[i];
      Ct(s, this.options.draggable, a, false) && (o[r] = s);
    }, this), n && this.captureAnimationState(), t.forEach(function(r) {
      o[r] && (a.removeChild(o[r]), a.appendChild(o[r]));
    }), n && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var t = this.options.store;
    t && t.set && t.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(t, n) {
    return Ct(t, n || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(t, n) {
    var o = this.options;
    if (n === void 0)
      return o[t];
    var a = Qn.modifyOption(this, t, n);
    typeof a < "u" ? o[t] = a : o[t] = n, t === "group" && Ga(o);
  },
  /**
   * Destroy
   */
  destroy: function() {
    Ze("destroy", this);
    var t = this.el;
    t[lt] = null, _e(t, "mousedown", this._onTapStart), _e(t, "touchstart", this._onTapStart), _e(t, "pointerdown", this._onTapStart), this.nativeDraggable && (_e(t, "dragover", this), _e(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), _o.splice(_o.indexOf(this.el), 1), this.el = t = null;
  },
  _hideClone: function() {
    if (!Ht) {
      if (Ze("hideClone", this), de.eventCanceled)
        return;
      ce(Ae, "display", "none"), this.options.removeCloneOnHide && Ae.parentNode && Ae.parentNode.removeChild(Ae), Ht = true;
    }
  },
  _showClone: function(t) {
    if (t.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ht) {
      if (Ze("showClone", this), de.eventCanceled)
        return;
      L.parentNode == ke && !this.options.group.revertClone ? ke.insertBefore(Ae, L) : Jt ? ke.insertBefore(Ae, Jt) : ke.appendChild(Ae), this.options.group.revertClone && this.animate(L, Ae), ce(Ae, "display", ""), Ht = false;
    }
  }
};
function Od(e) {
  e.dataTransfer && (e.dataTransfer.dropEffect = "move"), e.cancelable && e.preventDefault();
}
function ao(e, t, n, o, a, r, i, s) {
  var u, l2 = e[lt], c = l2.options.onMove, d;
  return window.CustomEvent && !Mt && !Xn ? u = new CustomEvent("move", {
    bubbles: true,
    cancelable: true
  }) : (u = document.createEvent("Event"), u.initEvent("move", true, true)), u.to = t, u.from = e, u.dragged = n, u.draggedRect = o, u.related = a || t, u.relatedRect = r || Ne(t), u.willInsertAfter = s, u.originalEvent = i, e.dispatchEvent(u), c && (d = c.call(l2, u, i)), d;
}
function xo(e) {
  e.draggable = false;
}
function $d() {
  fr = false;
}
function Td(e, t, n) {
  var o = Ne(yn(n.el, 0, n.options, true)), a = 10;
  return t ? e.clientX < o.left - a || e.clientY < o.top && e.clientX < o.right : e.clientY < o.top - a || e.clientY < o.bottom && e.clientX < o.left;
}
function Ad(e, t, n) {
  var o = Ne(Dr(n.el, n.options.draggable)), a = 10;
  return t ? e.clientX > o.right + a || e.clientX <= o.right && e.clientY > o.bottom && e.clientX >= o.left : e.clientX > o.right && e.clientY > o.top || e.clientX <= o.right && e.clientY > o.bottom + a;
}
function Id(e, t, n, o, a, r, i, s) {
  var u = o ? e.clientY : e.clientX, l2 = o ? n.height : n.width, c = o ? n.top : n.left, d = o ? n.bottom : n.right, f = false;
  if (!i) {
    if (s && mo < l2 * a) {
      if (!jn && (Mn === 1 ? u > c + l2 * r / 2 : u < d - l2 * r / 2) && (jn = true), jn)
        f = true;
      else if (Mn === 1 ? u < c + mo : u > d - mo)
        return -Mn;
    } else if (u > c + l2 * (1 - a) / 2 && u < d - l2 * (1 - a) / 2)
      return Pd(t);
  }
  return f = f || i, f && (u < c + l2 * r / 2 || u > d - l2 * r / 2) ? u > c + l2 / 2 ? 1 : -1 : 0;
}
function Pd(e) {
  return dt(L) < dt(e) ? 1 : -1;
}
function Vd(e) {
  for (var t = e.tagName + e.className + e.src + e.href + e.textContent, n = t.length, o = 0; n--; )
    o += t.charCodeAt(n);
  return o.toString(36);
}
function Md(e) {
  Co.length = 0;
  for (var t = e.getElementsByTagName("input"), n = t.length; n--; ) {
    var o = t[n];
    o.checked && Co.push(o);
  }
}
function po(e) {
  return setTimeout(e, 0);
}
function hr(e) {
  return clearTimeout(e);
}
Io && Ce(document, "touchmove", function(e) {
  (de.active || cn) && e.cancelable && e.preventDefault();
});
de.utils = {
  on: Ce,
  off: _e,
  css: ce,
  find: Wa,
  is: function(t, n) {
    return !!Ct(t, n, t, false);
  },
  extend: bd,
  throttle: xa,
  closest: Ct,
  toggleClass: ot,
  clone: Ua,
  index: dt,
  nextTick: po,
  cancelNextTick: hr,
  detectDirection: Ka,
  getChild: yn
};
de.get = function(e) {
  return e[lt];
};
de.mount = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  t[0].constructor === Array && (t = t[0]), t.forEach(function(o) {
    if (!o.prototype || !o.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(o));
    o.utils && (de.utils = Ot(Ot({}, de.utils), o.utils)), Qn.mount(o);
  });
};
de.create = function(e, t) {
  return new de(e, t);
};
de.version = md;
var Pe = [];
var $n;
var mr;
var pr = false;
var zo;
var Uo;
var Fo;
var Tn;
function jd() {
  function e() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
  }
  return e.prototype = {
    dragStarted: function(n) {
      var o = n.originalEvent;
      this.sortable.nativeDraggable ? Ce(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Ce(document, "pointermove", this._handleFallbackAutoScroll) : o.touches ? Ce(document, "touchmove", this._handleFallbackAutoScroll) : Ce(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var o = n.originalEvent;
      !this.options.dragOverBubble && !o.rootEl && this._handleAutoScroll(o);
    },
    drop: function() {
      this.sortable.nativeDraggable ? _e(document, "dragover", this._handleAutoScroll) : (_e(document, "pointermove", this._handleFallbackAutoScroll), _e(document, "touchmove", this._handleFallbackAutoScroll), _e(document, "mousemove", this._handleFallbackAutoScroll)), ea(), go(), yd();
    },
    nulling: function() {
      Fo = mr = $n = pr = Tn = zo = Uo = null, Pe.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, true);
    },
    _handleAutoScroll: function(n, o) {
      var a = this, r = (n.touches ? n.touches[0] : n).clientX, i = (n.touches ? n.touches[0] : n).clientY, s = document.elementFromPoint(r, i);
      if (Fo = n, o || this.options.forceAutoScrollFallback || Xn || Mt || In) {
        Yo(n, this.options, s, o);
        var u = xt(s, true);
        pr && (!Tn || r !== zo || i !== Uo) && (Tn && ea(), Tn = setInterval(function() {
          var l2 = xt(document.elementFromPoint(r, i), true);
          l2 !== u && (u = l2, go()), Yo(n, a.options, l2, o);
        }, 10), zo = r, Uo = i);
      } else {
        if (!this.options.bubbleScroll || xt(s, true) === kt()) {
          go();
          return;
        }
        Yo(n, this.options, xt(s, false), false);
      }
    }
  }, Vt(e, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function go() {
  Pe.forEach(function(e) {
    clearInterval(e.pid);
  }), Pe = [];
}
function ea() {
  clearInterval(Tn);
}
var Yo = xa(function(e, t, n, o) {
  if (t.scroll) {
    var a = (e.touches ? e.touches[0] : e).clientX, r = (e.touches ? e.touches[0] : e).clientY, i = t.scrollSensitivity, s = t.scrollSpeed, u = kt(), l2 = false, c;
    mr !== n && (mr = n, go(), $n = t.scroll, c = t.scrollFn, $n === true && ($n = xt(n, true)));
    var d = 0, f = $n;
    do {
      var h2 = f, v = Ne(h2), p = v.top, F = v.bottom, _ = v.left, D = v.right, k = v.width, A = v.height, E = void 0, $ = void 0, S = h2.scrollWidth, O = h2.scrollHeight, B = ce(h2), x = h2.scrollLeft, Q = h2.scrollTop;
      h2 === u ? (E = k < S && (B.overflowX === "auto" || B.overflowX === "scroll" || B.overflowX === "visible"), $ = A < O && (B.overflowY === "auto" || B.overflowY === "scroll" || B.overflowY === "visible")) : (E = k < S && (B.overflowX === "auto" || B.overflowX === "scroll"), $ = A < O && (B.overflowY === "auto" || B.overflowY === "scroll"));
      var I = E && (Math.abs(D - a) <= i && x + k < S) - (Math.abs(_ - a) <= i && !!x), M = $ && (Math.abs(F - r) <= i && Q + A < O) - (Math.abs(p - r) <= i && !!Q);
      if (!Pe[d])
        for (var N = 0; N <= d; N++)
          Pe[N] || (Pe[N] = {});
      (Pe[d].vx != I || Pe[d].vy != M || Pe[d].el !== h2) && (Pe[d].el = h2, Pe[d].vx = I, Pe[d].vy = M, clearInterval(Pe[d].pid), (I != 0 || M != 0) && (l2 = true, Pe[d].pid = setInterval((function() {
        o && this.layer === 0 && de.active._onTouchMove(Fo);
        var J = Pe[this.layer].vy ? Pe[this.layer].vy * s : 0, Z = Pe[this.layer].vx ? Pe[this.layer].vx * s : 0;
        typeof c == "function" && c.call(de.dragged.parentNode[lt], Z, J, e, Fo, Pe[this.layer].el) !== "continue" || za(Pe[this.layer].el, Z, J);
      }).bind({
        layer: d
      }), 24))), d++;
    } while (t.bubbleScroll && f !== u && (f = xt(f, false)));
    pr = l2;
  }
}, 30);
var Ja = function(t) {
  var n = t.originalEvent, o = t.putSortable, a = t.dragEl, r = t.activeSortable, i = t.dispatchSortableEvent, s = t.hideGhostForTarget, u = t.unhideGhostForTarget;
  if (n) {
    var l2 = o || r;
    s();
    var c = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, d = document.elementFromPoint(c.clientX, c.clientY);
    u(), l2 && !l2.el.contains(d) && (i("spill"), this.onSpill({
      dragEl: a,
      putSortable: o
    }));
  }
};
function Rr() {
}
Rr.prototype = {
  startIndex: null,
  dragStart: function(t) {
    var n = t.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable;
    this.sortable.captureAnimationState(), o && o.captureAnimationState();
    var a = yn(this.sortable.el, this.startIndex, this.options);
    a ? this.sortable.el.insertBefore(n, a) : this.sortable.el.appendChild(n), this.sortable.animateAll(), o && o.animateAll();
  },
  drop: Ja
};
Vt(Rr, {
  pluginName: "revertOnSpill"
});
function kr() {
}
kr.prototype = {
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable, a = o || this.sortable;
    a.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), a.animateAll();
  },
  drop: Ja
};
Vt(kr, {
  pluginName: "removeOnSpill"
});
de.mount(new jd());
de.mount(kr, Rr);
var Bd = Object.defineProperty;
var Nd = Object.defineProperties;
var Ld = Object.getOwnPropertyDescriptors;
var ta = Object.getOwnPropertySymbols;
var qd = Object.prototype.hasOwnProperty;
var Hd = Object.prototype.propertyIsEnumerable;
var na = (e, t, n) => t in e ? Bd(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var zt = (e, t) => {
  for (var n in t || (t = {}))
    qd.call(t, n) && na(e, n, t[n]);
  if (ta)
    for (var n of ta(t))
      Hd.call(t, n) && na(e, n, t[n]);
  return e;
};
var So = (e, t) => Nd(e, Ld(t));
function Ko(e) {
  e.parentElement !== null && e.parentElement.removeChild(e);
}
function oa(e, t, n) {
  const o = n === 0 ? e.children[0] : e.children[n - 1].nextSibling;
  e.insertBefore(t, o);
}
function Wd() {
  return typeof window < "u" ? window.console : global.console;
}
var xd = Wd();
function zd(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return function(o) {
    return t[o] || (t[o] = e(o));
  };
}
var Ud = /-(\w)/g;
var Yd = zd((e) => e.replace(Ud, (t, n) => n.toUpperCase()));
var Za = ["Start", "Add", "Remove", "Update", "End"];
var ei = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
var ti = ["Move"];
var Kd = [ti, Za, ei].flatMap((e) => e).map((e) => `on${e}`);
var gr = {
  manage: ti,
  manageAndEmit: Za,
  emit: ei
};
function Gd(e) {
  return Kd.indexOf(e) !== -1;
}
var Xd = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function Qd(e) {
  return Xd.includes(e);
}
function Jd(e) {
  return ["transition-group", "TransitionGroup"].includes(e);
}
function ni(e) {
  return ["id", "class", "role", "style"].includes(e) || e.startsWith("data-") || e.startsWith("aria-") || e.startsWith("on");
}
function oi(e) {
  return e.reduce((t, [n, o]) => (t[n] = o, t), {});
}
function Zd({ $attrs: e, componentData: t = {} }) {
  const n = oi(Object.entries(e).filter(([o, a]) => ni(o)));
  return zt(zt({}, n), t);
}
function ef({ $attrs: e, callBackBuilder: t }) {
  const n = oi(ri(e));
  Object.entries(t).forEach(([a, r]) => {
    gr[a].forEach((i) => {
      n[`on${i}`] = r(i);
    });
  });
  const o = `[data-draggable]${n.draggable || ""}`;
  return So(zt({}, n), {
    draggable: o
  });
}
function ri(e) {
  return Object.entries(e).filter(([t, n]) => !ni(t)).map(([t, n]) => [Yd(t), n]).filter(([t, n]) => !Gd(t));
}
var ra = (e) => {
  const t = e.el || Array.isArray(e.children) && e.children[0].el.parentNode;
  return t || console.error("使用 transition-group , 需要在slot中template内至少2层html标签"), t || {};
};
var tf = (e, t) => e.__draggable_context = t;
var aa = (e) => e.__draggable_context;
var nf = class {
  constructor({
    nodes: { header: t, default: n, footer: o },
    root: a,
    realList: r
  }) {
    this.defaultNodes = n, this.children = [...t, ...n, ...o], this.externalComponent = a.externalComponent, this.rootTransition = a.transition, this.tag = a.tag, this.realList = r;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(t, n) {
    const { tag: o, children: a, _isRootComponent: r } = this;
    return t(o, n, r ? { default: () => a } : a);
  }
  updated() {
    const { defaultNodes: t, realList: n } = this;
    t.forEach((o, a) => {
      tf(ra(o), {
        element: n[a],
        index: a
      });
    });
  }
  getUnderlyingVm(t) {
    return aa(t);
  }
  getVmIndexFromDomIndex(t, n) {
    const { defaultNodes: o } = this, { length: a } = o, r = n.children, i = r.item(t);
    if (i === null)
      return a;
    const s = aa(i);
    if (s)
      return s.index;
    if (a === 0)
      return 0;
    const u = ra(o[0]), l2 = [...r].findIndex((c) => c === u);
    return t < l2 ? 0 : a;
  }
};
function of(e, t) {
  const n = e[t];
  return n ? n() : [];
}
function rf({ $slots: e, realList: t, getKey: n }) {
  const o = t || [], [a, r] = ["header", "footer"].map((u) => of(e, u)), { item: i } = e;
  if (!i)
    throw new Error("draggable element must have an item slot");
  const s = o.flatMap((u, l2) => i({ element: u, index: l2 }).map((c) => (c.key = n(u), c.props = So(zt({}, c.props || {}), { "data-draggable": true }), c)));
  if (s.length !== o.length)
    throw new Error("Item slot must have only one child");
  return {
    header: a,
    footer: r,
    default: s
  };
}
function af(e) {
  const t = Jd(e), n = !Qd(e) && !t;
  return {
    transition: t,
    externalComponent: n,
    tag: n ? resolveComponent(e) : t ? TransitionGroup : e
  };
}
function sf({ $slots: e, tag: t, realList: n, getKey: o }) {
  const a = rf({ $slots: e, realList: n, getKey: o }), r = af(t);
  return new nf({ nodes: a, root: r, realList: n });
}
function ai(e, t) {
  nextTick(() => this.$emit(e.toLowerCase(), t));
}
function ii(e) {
  return (t, n) => {
    if (this.realList !== null)
      return this[`onDrag${e}`](t, n);
  };
}
function lf(e) {
  const t = ii.call(this, e);
  return (n, o) => {
    t.call(this, n, o), ai.call(this, e, n);
  };
}
var Go = null;
var uf = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (e) => e
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
var cf = [
  "update:modelValue",
  "change",
  ...[...gr.manageAndEmit, ...gr.emit].map((e) => e.toLowerCase())
];
var df = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props: uf,
  emits: cf,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots: e, $attrs: t, tag: n, componentData: o, realList: a, getKey: r } = this, i = sf({
        $slots: e,
        tag: n,
        realList: a,
        getKey: r
      });
      this.componentStructure = i;
      const s = Zd({ $attrs: t, componentData: o });
      return i.render(h, s);
    } catch (e) {
      return this.error = true, h("pre", { style: { color: "red" } }, e.stack);
    }
  },
  created() {
    this.list !== null && this.modelValue !== null && xd.error("modelValue and list props are mutually exclusive! Please set one or another.");
  },
  mounted() {
    if (this.error)
      return;
    const { $attrs: e, $el: t, componentStructure: n } = this;
    n.updated();
    const o = ef({
      $attrs: e,
      callBackBuilder: {
        manageAndEmit: (r) => lf.call(this, r),
        emit: (r) => ai.bind(this, r),
        manage: (r) => ii.call(this, r)
      }
    }), a = t.nodeType === 1 ? t : t.parentElement;
    this._sortable = new de(a, o), this.targetDomElement = a, a.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    this._sortable !== void 0 && this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list: e } = this;
      return e || this.modelValue;
    },
    getKey() {
      const { itemKey: e } = this;
      return typeof e == "function" ? e : (t) => t[e];
    }
  },
  watch: {
    $attrs: {
      handler(e) {
        const { _sortable: t } = this;
        t && ri(e).forEach(([n, o]) => {
          t.option(n, o);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(e) {
      return this.componentStructure.getUnderlyingVm(e) || null;
    },
    getUnderlyingPotencialDraggableComponent(e) {
      return e.__draggable_component__;
    },
    emitChanges(e) {
      nextTick(() => this.$emit("change", e));
    },
    alterList(e) {
      if (this.list) {
        e(this.list);
        return;
      }
      const t = [...this.modelValue];
      e(t), this.$emit("update:modelValue", t);
    },
    spliceList() {
      const e = (t) => t.splice(...arguments);
      this.alterList(e);
    },
    updatePosition(e, t) {
      const n = (o) => o.splice(t, 0, o.splice(e, 1)[0]);
      this.alterList(n);
    },
    getRelatedContextFromMoveEvent({ to: e, related: t }) {
      const n = this.getUnderlyingPotencialDraggableComponent(e);
      if (!n)
        return { component: n };
      const o = n.realList, a = { list: o, component: n };
      if (e !== t && o) {
        const r = n.getUnderlyingVm(t) || {};
        return zt(zt({}, r), a);
      }
      return a;
    },
    getVmIndexFromDomIndex(e) {
      return this.componentStructure.getVmIndexFromDomIndex(e, this.targetDomElement);
    },
    onDragStart(e) {
      this.context = this.getUnderlyingVm(e.item), e.item._underlying_vm_ = this.clone(this.context.element), Go = e.item;
    },
    onDragAdd(e) {
      const t = e.item._underlying_vm_;
      if (t === void 0)
        return;
      Ko(e.item);
      const n = this.getVmIndexFromDomIndex(e.newIndex);
      this.spliceList(n, 0, t);
      const o = { element: t, newIndex: n };
      this.emitChanges({ added: o });
    },
    onDragRemove(e) {
      if (oa(this.$el, e.item, e.oldIndex), e.pullMode === "clone") {
        Ko(e.clone);
        return;
      }
      const { index: t, element: n } = this.context;
      this.spliceList(t, 1);
      const o = { element: n, oldIndex: t };
      this.emitChanges({ removed: o });
    },
    onDragUpdate(e) {
      Ko(e.item), oa(e.from, e.item, e.oldIndex);
      const t = this.context.index, n = this.getVmIndexFromDomIndex(e.newIndex);
      this.updatePosition(t, n);
      const o = { element: this.context.element, oldIndex: t, newIndex: n };
      this.emitChanges({ moved: o });
    },
    computeFutureIndex(e, t) {
      if (!e.element)
        return 0;
      const n = [...t.to.children].filter((i) => i.style.display !== "none"), o = n.indexOf(t.related), a = e.component.getVmIndexFromDomIndex(o);
      return n.indexOf(Go) !== -1 || !t.willInsertAfter ? a : a + 1;
    },
    onDragMove(e, t) {
      const { move: n, realList: o } = this;
      if (!n || !o)
        return true;
      const a = this.getRelatedContextFromMoveEvent(e), r = this.computeFutureIndex(a, e), i = So(zt({}, this.context), {
        futureIndex: r
      }), s = So(zt({}, e), {
        relatedContext: a,
        draggedContext: i
      });
      return n(s, t);
    },
    onDragEnd() {
      Go = null;
    }
  }
});
var ff = defineComponent({
  name: "FsTableColumnsFixedController",
  props: {
    modelValue: {
      default: false
    }
  },
  emits: ["update:modelValue", "change"],
  setup(e, t) {
    const { ui: n } = w(), o = ref([
      {
        value: "left",
        icon: n.icons.left
        // 'el-icon-arrow-left'
      },
      {
        value: false,
        icon: n.icons.close
        // 'el-icon-close'
      },
      {
        value: "right",
        icon: n.icons.right
        // 'el-icon-arrow-right'
      }
    ]);
    function a(r) {
      t.emit("update:modelValue", r), t.emit("change", r);
    }
    return {
      ui: n,
      options: o,
      submit: a
    };
  }
});
function hf(e, t, n, o, a, r) {
  const i = resolveComponent("fs-button");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.buttonGroup.name), { class: "fs-table-columns-fixed-controller" }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.options, (s) => (openBlock(), createBlock(i, {
        key: s.icon,
        type: e.modelValue === s.value ? "primary" : "default",
        icon: s.icon,
        size: "small",
        onClick: (u) => e.submit(s.value)
      }, null, 8, ["type", "icon", "onClick"]))), 128))
    ]),
    _: 1
  });
}
var mf = Se(ff, [["render", hf]]);
var pf = { class: "component--list" };
var gf = {
  key: "__first__",
  class: "component--list-item",
  flex: "main:justify cross:center"
};
var vf = { span: 12 };
var bf = { class: "title" };
var yf = ["title", "i"];
var wf = { class: "item-right" };
var _f = {
  "flex-box": "0",
  class: "component--list-item-handle handle"
};
var Cf = defineComponent({
  __name: "fs-columns-filter-layout-default",
  props: {
    width: {},
    drawer: {}
  },
  setup(e) {
    const t = e, { ui: n } = w(), { originalColumns: o, currentColumns: a, text: r, active: i } = inject(La), s = computed(() => lodash_default_default.merge(
      {
        [n.drawer.visible]: i.value,
        ["onUpdate:" + n.drawer.visible]: (D) => {
          i.value = D;
        },
        [n.drawer.width]: t.width || "300px"
      },
      t.drawer
    )), u = ref(false);
    function l2(D) {
      u.value = D, a.value = a.value.map((k) => (!k.__show || k.__disabled || (k.show = D), k));
    }
    const c = computed(() => ({
      [n.checkbox.modelValue]: u.value,
      ["onUpdate:" + n.checkbox.modelValue]: (D) => {
        l2(D);
      }
    })), d = computed(() => a.value.filter((D) => D.__show && D.show === true).length), f = computed(() => a.value.filter((D) => D.__show).length), h2 = computed(() => d.value > 0 && d.value < f.value);
    watch(
      () => {
        a.value;
      },
      () => {
        F();
      },
      { immediate: true }
    );
    function v(D) {
      const k = D.draggedContext.element, A = D.relatedContext.element, E = [];
      for (const x of a.value)
        x.key === k.key ? E.push(A) : x.key === A.key ? E.push(k) : E.push(x);
      let $ = 0, S = E.length - 1, O = E.length - 1, B = 0;
      for (let x = 0; x < E.length; x++) {
        const Q = E[x];
        Q.fixed === "left" ? $ = x : Q.fixed === "right" ? S = S > x ? x : S : (O = O > x ? x : O, B = B < x ? x : B);
      }
      if (O < $ || B > S)
        return false;
    }
    function p(D, k) {
      k && (a.value[D].show = true), k === "left" && a.value.unshift(a.value.splice(D, 1)[0]), k === "right" && a.value.push(a.value.splice(D, 1)[0]), F();
    }
    function F() {
      u.value = d.value === f.value;
    }
    function _(D) {
      return D.label || D.title || D.key || r.value.unnamed;
    }
    return (D, k) => {
      const A = resolveComponent("fs-icon");
      return openBlock(), createBlock(resolveDynamicComponent(unref(n).drawer.name), mergeProps({
        class: "fs-columns-filter-layout-default",
        title: unref(r).title
      }, s.value, { "append-to-body": "" }), {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(n).drawer.hasContentWrap || "div"), {
            class: "fs-drawer-wrapper fs-table-columns-filter",
            title: unref(r).title
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(unref(n).card.name), { shadow: "never" }, {
                default: withCtx(() => [
                  createBaseVNode("div", pf, [
                    createBaseVNode("div", gf, [
                      createBaseVNode("span", vf, [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(n).checkbox.name), mergeProps({ indeterminate: h2.value }, c.value), {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(d.value) + " / " + toDisplayString(f.value), 1)
                          ]),
                          _: 1
                        }, 16, ["indeterminate"]))
                      ]),
                      createBaseVNode("span", bf, toDisplayString(unref(r).fixed) + " / " + toDisplayString(unref(r).order), 1)
                    ]),
                    createVNode(unref(df), {
                      modelValue: unref(a),
                      "onUpdate:modelValue": k[0] || (k[0] = (E) => isRef(a) ? a.value = E : null),
                      "item-key": "key",
                      move: v
                    }, {
                      item: withCtx(({ element: E, index: $ }) => {
                        var S, O;
                        return [
                          withDirectives(createBaseVNode("div", {
                            title: _(E),
                            class: "component--list-item",
                            flex: "main:justify cross:center",
                            i: $
                          }, [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(n).checkbox.name), normalizeProps({
                              [unref(n).checkbox.modelValue]: E.show,
                              ["onUpdate:" + unref(n).checkbox.modelValue]: (B) => E.show = B,
                              disabled: ((S = unref(o)[E.key]) == null ? void 0 : S.__disabled) === true,
                              class: "item-label",
                              title: _(E),
                              onChange: F
                            }), {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(_(E)), 1)
                              ]),
                              _: 2
                            }, 1040, ["disabled", "title"])),
                            createBaseVNode("div", wf, [
                              createVNode(mf, {
                                modelValue: E.fixed,
                                "onUpdate:modelValue": (B) => E.fixed = B,
                                "flex-box": "0",
                                class: "d2-mr-10",
                                onChange: (B) => p($, B)
                              }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"]),
                              createBaseVNode("div", _f, [
                                createVNode(A, {
                                  icon: unref(n).icons.sort
                                }, null, 8, ["icon"])
                              ])
                            ])
                          ], 8, yf), [
                            [vShow, ((O = unref(o)[E.key]) == null ? void 0 : O.__show) !== false]
                          ])
                        ];
                      }),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ]),
                _: 1
              })),
              renderSlot(D.$slots, "buttons")
            ]),
            _: 3
          }, 8, ["title"]))
        ]),
        _: 3
      }, 16, ["title"]);
    };
  }
});
var Ff = defineComponent({
  name: "FsSearchButtons",
  inheritAttrs: false,
  props: {
    buttons: {
      type: Object
    }
  },
  setup() {
    const { ui: e } = w();
    return { ui: e };
  }
});
var Sf = { class: "fs-search-col fs-search-btns" };
function Ef(e, t, n, o, a, r) {
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", Sf, [
    (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(e.buttons, (s, u) => (openBlock(), createElementBlock(Fragment, { key: u }, [
          s.show ? (openBlock(), createBlock(i, mergeProps({ key: 0 }, s, {
            onClick: (l2) => s._click()
          }), null, 16, ["onClick"])) : createCommentVNode("", true)
        ], 64))), 128))
      ]),
      _: 1
    }))
  ]);
}
var si = Se(Ff, [["render", Ef]]);
var Df = defineComponent({
  name: "FsSearch",
  components: {
    FsSearchButtons: si
  },
  inheritAttrs: false,
  props: {
    /**
     * 布局容器
     */
    container: {
      type: Object
    },
    /**
     * 初始查询条件
     * 点击重置，会重置成该条件
     */
    initialForm: {
      type: Object
    },
    /**
     * 校验后的查询表单数据
     */
    validatedForm: {
      type: Object
    },
    /**
     * 表单参数
     * 支持el-form | a-form的属性
     */
    options: {
      type: Object
    },
    /**
     * 查询字段配置
     */
    columns: {
      type: Object
    },
    /**
     * 按钮配置,可以根据order排序
     * `{search:{...FsButton},reset:{...FsButton}}`
     */
    buttons: {
      type: Object
    },
    /**
     * 点击重置后是否立即触发查询
     */
    searchAfterReset: {
      type: Boolean,
      default: true
    },
    /**
     * 是否开启自动查询
     */
    autoSearch: {
      type: Boolean,
      default: true
    },
    /**
     * 自动查询，防抖设置
     * 传false则关闭自动查询
     */
    debounce: {
      type: [Boolean, Object],
      default: void 0
    },
    /**
     * 插槽
     */
    slots: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 是否显示查询框
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 是否启用校验
     */
    validate: {
      default: false
    },
    /**
     * 是否任意值变化就触发校验
     */
    validateOnChange: {
      default: true,
      type: Boolean
    },
    /**
     * 列的宽度设置，span=xx
     */
    col: {},
    /**
     * 统一字段的formItem属性
     */
    formItem: {
      type: Object,
      default: void 0
    }
  },
  emits: [
    /**
     * 查询事件
     **/
    "search",
    /**
     * 重置事件，供用户使用
     **/
    "reset",
    /**
     * 重置事件，此事件供系统调用
     */
    "_reset",
    /**
     * 校验失败事件
     */
    "validate-error",
    /**
     * 校验后的表单数据变化
     */
    "update:validatedForm"
  ],
  setup(e, t) {
    const {
      ui: n
    } = w(), {
      merge: o
    } = Fe(), a = o, {
      doComputed: r,
      AsyncComputeValue: i,
      ComputeValue: s
    } = an();
    lodash_default_default.each(e.columns, (m) => {
      m.value != null && (m.value instanceof i || m.value instanceof s) && ue.warn("search.value配置不支持ComputeValue/AsyncCompute类型的动态计算");
    });
    function u() {
      const m = {};
      return lodash_default_default.forEach(e.columns, (b, R) => {
        var ne;
        if (b.value === void 0)
          return;
        const V = unref(b.value);
        V !== void 0 && b.show !== false && ((ne = b.component) == null ? void 0 : ne.show) !== false && (m[R] = V);
      }), lodash_default_default.cloneDeep(o({}, e.initialForm, m));
    }
    const l2 = reactive(u());
    let c = null;
    const d = r(() => e.columns, E, null, (m) => {
      const b = lodash_default_default.cloneDeep(e.formItem || {});
      m = o(b, m), e.validate || lodash_default_default.forEach(m, (ne) => {
        delete ne.rules, delete ne.rule;
      }), e.col && lodash_default_default.forEach(m, (ne) => {
        ne.col = o({}, e.col, ne.col);
      }), lodash_default_default.forEach(m, (ne) => {
        ne._cellRender = () => p(ne);
      });
      let R = [];
      lodash_default_default.forEach(m, (ne, ie) => {
        ne._key = ie, R.push(ne);
      }), R = lodash_default_default.sortBy(R, (ne) => ne.order ?? Kt.orderDefault);
      const V = {};
      return R.forEach((ne) => {
        let ie = ne._key;
        delete ne._key, V[ie] = ne;
      }), V;
    });
    function f() {
      const m = lodash_default_default.cloneDeep(l2);
      t.emit("update:validatedForm", m);
    }
    watch(() => e.validatedForm, (m) => {
      for (const b in l2)
        delete l2[b];
      o(l2, m || {});
    }, {
      deep: true
    });
    const h2 = (m, b) => lodash_default_default.get(m, b);
    function v(m) {
      if (m != null)
        return m.indexOf(".") >= 0 ? m.split(".") : m;
    }
    function p(m) {
      const b = m.key;
      async function R(he) {
        se(he, m);
      }
      function V() {
        ge(m);
      }
      function ne(he, Me) {
        Me.code === "Enter" && he.autoSearchTrigger === "enter" && O();
      }
      let ie = null;
      e.slots["search_" + b] ? ie = createVNode(resolveComponent("fs-slot-render"), {
        slots: e.slots["search_" + b],
        scope: $(b)
      }, null) : m.render ? ie = createVNode(resolveComponent("fs-render"), {
        "render-func": m.render,
        scope: $(b)
      }, null) : m.component && m.component.show !== false && (ie = createVNode(resolveComponent("fs-component-render"), mergeProps({
        ref: (he) => {
          D.value[b] = he;
        },
        "model-value": h2(l2, b),
        onKeyup: (he) => {
          ne(m, he);
        }
      }, m.component, {
        scope: $(b),
        "onUpdate:modelValue": R,
        onInput: V
      }), null));
      const K = v(b);
      return n.formItem.render({
        prop: b,
        label: m.title,
        props: {
          ...m,
          label: m.title,
          [n.formItem.prop]: K,
          path: b,
          rulePath: b
        },
        slots: {
          default() {
            return ie;
          }
        }
      });
    }
    const F = ref(), {
      t: _
    } = tt(), D = ref({});
    function k(m) {
      return D.value[m];
    }
    function A(m) {
      var b;
      return (b = k(m)) == null ? void 0 : b.getTargetRef();
    }
    function E() {
      return {
        form: l2,
        validatedForm: e.validatedForm,
        getComponentRef: A
      };
    }
    function $(m) {
      return {
        ...E(),
        key: m,
        value: lodash_default_default.get(l2, m)
      };
    }
    async function S(m = false, b = "search") {
      try {
        return e.validate && await n.form.validateWrap(F.value), true;
      } catch (R) {
        return m || t.emit("validate-error", {
          ...E(),
          error: R,
          trigger: b
        }), false;
      }
    }
    async function O() {
      c && c.cancel(), await S() && (f(), await nextTick(), t.emit("search", E()));
    }
    async function B() {
      const m = u(), b = lodash_default_default.entries(l2);
      for (const R of b) {
        const V = lodash_default_default.get(m, R[0]);
        V == null ? lodash_default_default.unset(l2, R[0]) : lodash_default_default.set(l2, R[0], V);
      }
      await S() && (f(), await nextTick(), e.reset && e.reset(E()), t.emit("_reset", E()), t.emit("reset", E()), e.searchAfterReset && O());
    }
    const x = computed(() => {
      const m = [], b = {
        search: {
          show: true,
          type: "primary",
          disabled: false,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          click: (R) => {
            O();
          },
          order: 1,
          text: _("fs.search.search.text")
          // '查询',
        },
        reset: {
          show: true,
          disabled: false,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          click: (R) => {
            B();
          },
          text: _("fs.search.reset.text"),
          // '重置',
          order: 2
        }
      };
      o(b, e.buttons);
      for (let R in b) {
        const V = b[R];
        V._click = () => {
          V.click(E());
        }, m.push(V);
      }
      return m.sort((R, V) => R.order - V.order), m;
    });
    function Q() {
      var m;
      if (e.autoSearch !== false && e.debounce !== false) {
        let b = ((m = e.debounce) == null ? void 0 : m.wait) || 500;
        c = lodash_default_default.debounce(O, b, e.debounce);
      }
    }
    Q();
    function I() {
      return l2;
    }
    function M() {
      return e.validatedForm;
    }
    function N(m, b = true) {
      b || lodash_default_default.each(lodash_default_default.keys(l2), (R) => {
        delete l2[R];
      }), a(l2, m), f();
    }
    const J = ref(false), Z = () => {
      ue.debug("do auto search,inputEventDisabled:", J.value), J.value !== true && c && c();
    }, ge = (m) => {
      m.autoSearchTrigger === "input" && Z();
    }, z = (m) => {
      J.value = m, Z();
    };
    async function se(m, b) {
      const R = b.key;
      lodash_default_default.set(l2, R, m);
      const V = e.validateOnChangeSilent;
      if (e.validateOnChange && await S(V, "change") && f(), b.valueChange) {
        const ne = b.key, ie = l2[ne], K = A(ne);
        (b.valueChange instanceof Function ? b.valueChange : b.valueChange.handle)({
          key: ne,
          value: ie,
          componentRef: K,
          ...E()
        });
      }
      (b.autoSearchTrigger == null || b.autoSearchTrigger === true || b.autoSearchTrigger === "change") && Z();
    }
    const C = computed(() => e.validate ? e.options.rules : []);
    return f(), {
      get: h2,
      ui: n,
      onValueChanged: se,
      doValidate: S,
      doSearch: O,
      doReset: B,
      formData: l2,
      componentRenderRefs: D,
      getComponentRenderRef: k,
      getComponentRef: A,
      getForm: I,
      getValidatedForm: M,
      setForm: N,
      searchFormRef: F,
      onInput: ge,
      inputEventDisabled: J,
      changeInputEventDisabled: z,
      computedColumns: d,
      computedButtons: x,
      computedRules: C,
      buildFieldContext: $,
      getContextFn: E
    };
  }
});
var Rf = { class: "fs-search fs-search-v2" };
function kf(e, t, n, o, a, r) {
  const i = resolveComponent("fs-button"), s = resolveComponent("fs-slot-render");
  return openBlock(), createElementBlock("div", Rf, [
    (openBlock(), createBlock(resolveDynamicComponent(e.ui.collapseTransition.name), null, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), mergeProps({
          ref: "searchFormRef",
          model: e.formData
        }, e.options, {
          rules: e.computedRules,
          class: "fs-search-form",
          onCompositionstart: t[0] || (t[0] = (u) => e.changeInputEventDisabled(true)),
          onCompositionend: t[1] || (t[1] = (u) => e.changeInputEventDisabled(false))
        }), {
          default: withCtx(() => {
            var u;
            return [
              e.show !== false ? (openBlock(), createBlock(resolveDynamicComponent(((u = e.container) == null ? void 0 : u.is) || "fs-search-layout-default"), mergeProps({ key: 0 }, e.container, {
                columns: e.computedColumns,
                "get-context-fn": e.getContextFn
              }), createSlots({
                "search-buttons": withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (l2, c) => (openBlock(), createElementBlock(Fragment, { key: c }, [
                    l2.show !== false ? (openBlock(), createBlock(i, mergeProps({ key: 0 }, l2, {
                      onClick: (d) => l2._click()
                    }), null, 16, ["onClick"])) : createCommentVNode("", true)
                  ], 64))), 128))
                ]),
                _: 2
              }, [
                e.slots["search-left"] ? {
                  name: "search-left",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-left"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "0"
                } : void 0,
                e.slots["search-middle"] ? {
                  name: "search-middle",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-middle"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "1"
                } : void 0,
                e.slots["search-right"] ? {
                  name: "search-right",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-right"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "2"
                } : void 0
              ]), 1040, ["columns", "get-context-fn"])) : createCommentVNode("", true)
            ];
          }),
          _: 1
        }, 16, ["model", "rules"]))
      ]),
      _: 1
    }))
  ]);
}
var Of = Se(Df, [["render", kf]]);
var $f = defineComponent({
  name: "FsSearchV1",
  components: { FsSearchButtons: si },
  inheritAttrs: false,
  props: {
    /**
     * 初始查询条件
     * 点击重置，会重置成该条件
     */
    initialForm: {
      type: Object
    },
    /**
     * 表单参数
     * 支持el-form | a-form的属性
     */
    options: {
      type: Object
    },
    /**
     * 查询字段配置
     */
    columns: {
      type: Object
    },
    /**
     * tabs
     * { show , options,key, default}
     */
    tabs: {
      type: Object
    },
    /**
     * 按钮配置,可以根据order排序
     * {search:{...FsButton},reset:{...FsButton}}
     */
    buttons: {
      type: Object
    },
    /**
     * 点击重置后是否立即触发查询
     */
    searchAfterReset: {
      type: Boolean,
      default: true
    },
    /**
     * 是否开启自动查询
     */
    autoSearch: {
      type: Boolean,
      default: true
    },
    /**
     * 自动查询，防抖设置
     * 传false则关闭自动查询
     */
    debounce: {
      type: [Boolean, Object],
      default: void 0
    },
    /**
     * 插槽
     */
    slots: {
      default() {
        return {};
      }
    },
    /**
     * 是否显示查询框
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 是否启用校验
     */
    validate: {
      default: false
    },
    /**
     * 布局, single-line 单行， multi-line 多行（支持展开收起）
     */
    layout: {
      type: String,
      default: "single-line"
    },
    /**
     * 列的宽度设置，span=xx
     */
    col: {},
    /**
     * 是否折叠
     */
    collapse: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    /**
     * 查询事件
     **/
    "search",
    /**
     * 重置事件
     **/
    "reset",
    "collapse",
    "update:collapse"
  ],
  setup(e, t) {
    const { ui: n } = w();
    onMounted(() => {
      if (se.value && N.value) {
        J.value = N.value.$el.offsetHeight;
        const m = N.value.$el.children;
        m && m.length > 1 && (Z.value = m[1].offsetHeight + 2);
      }
    });
    let o = null;
    function a() {
      return lodash_default_default.cloneDeep(e.initialForm || {});
    }
    const r = reactive(a()), { doComputed: i, AsyncComputeValue: s } = an();
    lodash_default_default.each(e.columns, (m) => {
      m.value != null && m.value instanceof s && ue.warn("search.value配置不支持AsyncCompute类型的动态计算");
    });
    const { merge: u } = Fe(), l2 = u, c = i(
      () => e.columns,
      F,
      null,
      (m) => {
        e.validate || lodash_default_default.forEach(m, (V) => {
          delete V.rules;
        }), e.col && lodash_default_default.forEach(m, (V) => {
          V.col = u({}, e.col, V.col);
        });
        let b = [];
        lodash_default_default.forEach(m, (V, ne) => {
          V._key = ne, b.push(V);
        }), b = lodash_default_default.sortBy(b, (V) => V.order ?? Kt.orderDefault);
        const R = {};
        return b.forEach((V) => {
          let ne = V._key;
          delete V._key, R[ne] = V;
        }), R;
      }
    );
    lodash_default_default.forEach(c.value, (m, b) => {
      var V;
      if (m.value === void 0)
        return;
      const R = unref(m.value);
      R !== void 0 && m.show !== false && ((V = m.component) == null ? void 0 : V.show) !== false && (r[b] = R);
    });
    const d = ref(), { t: f } = tt(), h2 = ref({});
    function v(m) {
      return h2.value[m];
    }
    function p(m) {
      var b, R;
      return (R = (b = v(m)) == null ? void 0 : b.$refs) == null ? void 0 : R.targetRef;
    }
    function F() {
      return { form: r, validatedForm: r, getComponentRef: p };
    }
    const _ = ref(F());
    async function D() {
      if (o && o.cancel(), await n.form.validateWrap(d.value))
        t.emit("search", _.value);
      else
        return n.message.error({
          message: f("fs.search.error.message")
        }), false;
    }
    function k() {
      const m = a(), b = lodash_default_default.entries(r);
      for (const R of b) {
        const V = lodash_default_default.get(m, R[0]);
        V == null ? lodash_default_default.unset(r, R[0]) : lodash_default_default.set(r, R[0], V);
      }
      e.reset && e.reset(_.value), t.emit("reset", F()), e.searchAfterReset && nextTick(() => {
        D();
      });
    }
    const A = computed(() => {
      const m = [], b = {
        search: {
          show: true,
          type: "primary",
          disabled: false,
          click: (R) => {
            D();
          },
          order: 1,
          text: f("fs.search.search.text")
          // '查询',
        },
        reset: {
          show: true,
          disabled: false,
          click: (R) => {
            k();
          },
          text: f("fs.search.reset.text"),
          // '重置',
          order: 2
        }
      };
      u(b, e.buttons);
      for (let R in b) {
        const V = b[R];
        V._click = () => {
          V.click(F());
        }, m.push(V);
      }
      return m.sort((R, V) => R.order - V.order), m;
    });
    function E() {
      var m;
      if (e.autoSearch !== false && e.debounce !== false) {
        let b = ((m = e.debounce) == null ? void 0 : m.wait) || 500;
        o = lodash_default_default.debounce(D, b, e.debounce);
      }
    }
    E();
    function $() {
      return r;
    }
    function S(m, b = true) {
      b || lodash_default_default.each(lodash_default_default.keys(r), (R) => {
        delete r[R];
      }), l2(r, m);
    }
    const O = ref(false), B = () => {
      ue.debug("do auto search,inputEventDisabled:", O.value), O.value !== true && o && o();
    }, x = (m) => {
      m.autoSearchTrigger === "input" && B();
    }, Q = (m) => {
      O.value = m, B();
    };
    function I(m, b) {
      const R = b.key;
      if (lodash_default_default.set(r, R, m), b.valueChange) {
        const V = b.key, ne = r[V], ie = p(V);
        (b.valueChange instanceof Function ? b.valueChange : b.valueChange.handle)({ key: V, value: ne, componentRef: ie, ...F() });
      }
      (b.autoSearchTrigger == null || b.autoSearchTrigger === true || b.autoSearchTrigger === "change") && B();
    }
    const M = computed(() => e.validate ? e.options.rules : []), N = ref(), J = ref(0), Z = ref(0), ge = () => {
      t.emit("update:collapse", !e.collapse), t.emit("collapse", !e.collapse);
    }, z = computed(() => e.layout === "multi-line" ? n.col.name : "div"), se = computed(() => e.layout === "multi-line"), C = computed(() => se.value ? e.collapse ? Z.value ? Z.value + "px" : "" : J.value ? J.value + "px" : "" : "auto");
    return {
      get: (m, b) => lodash_default_default.get(m, b),
      ui: n,
      onValueChanged: I,
      doSearch: D,
      doReset: k,
      form: r,
      componentRenderRefs: h2,
      getComponentRenderRef: v,
      getComponentRef: p,
      getForm: $,
      setForm: S,
      searchFormRef: d,
      onInput: x,
      inputEventDisabled: O,
      changeInputEventDisabled: Q,
      computedColumns: c,
      computedButtons: A,
      computedRules: M,
      columnsRowRef: N,
      computedColumnBoxHeight: C,
      computedColName: z,
      computedIsMultiLine: se,
      toggleCollapse: ge,
      searchEventContextRef: _
    };
  }
});
var Tf = { class: "fs-search-box" };
var Af = { class: "fs-search-main" };
var If = {
  key: 0,
  class: "fs-search-col"
};
var Pf = {
  key: 1,
  class: "fs-search-col fs-search-middle"
};
var Vf = {
  key: 3,
  class: "fs-search-col fs-search-right"
};
var Mf = {
  key: 0,
  class: "fs-search-action"
};
function jf(e, t, n, o, a, r) {
  const i = resolveComponent("fs-slot-render"), s = resolveComponent("fs-component-render"), u = resolveComponent("fs-search-buttons"), l2 = resolveComponent("fs-button");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.collapseTransition.name), null, {
    default: withCtx(() => [
      e.show !== false ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["fs-search", { "fs-search-multi-line": e.computedIsMultiLine }])
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), mergeProps({
          ref: "searchFormRef",
          model: e.form
        }, e.options, {
          rules: e.computedRules,
          class: "fs-search-form",
          onCompositionstart: t[0] || (t[0] = (c) => e.changeInputEventDisabled(true)),
          onCompositionend: t[1] || (t[1] = (c) => e.changeInputEventDisabled(false))
        }), {
          default: withCtx(() => [
            createBaseVNode("div", Tf, [
              createBaseVNode("div", Af, [
                createBaseVNode("div", {
                  class: normalizeClass(["fs-search-columns", { "fs-search-collapse": e.collapse }]),
                  style: normalizeStyle({ height: e.computedColumnBoxHeight })
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), { ref: "columnsRowRef" }, {
                    default: withCtx(() => [
                      e.slots["search-left"] ? (openBlock(), createElementBlock("div", If, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-left"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedColumns, (c, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                        c.show === true ? (openBlock(), createBlock(resolveDynamicComponent(e.computedColName), mergeProps({
                          key: 0,
                          class: "fs-search-col"
                        }, c.col), {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), mergeProps(c, {
                              [e.ui.formItem.prop || ""]: d,
                              label: c.title
                            }), {
                              default: withCtx(() => [
                                e.slots["search_" + d] ? (openBlock(), createBlock(i, {
                                  key: 0,
                                  slots: e.slots["search_" + d],
                                  scope: { ...e.searchEventContextRef, key: d }
                                }, null, 8, ["slots", "scope"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                  c.component && c.component.show !== false ? (openBlock(), createBlock(s, mergeProps({
                                    key: 0,
                                    ref_for: true,
                                    ref: (f) => {
                                      f && (e.componentRenderRefs[c.key] = f);
                                    },
                                    "model-value": e.get(e.form, d)
                                  }, c.component, {
                                    scope: e.searchEventContextRef,
                                    "onUpdate:modelValue": (f) => e.onValueChanged(f, c),
                                    onInput: (f) => e.onInput(c)
                                  }), null, 16, ["model-value", "scope", "onUpdate:modelValue", "onInput"])) : createCommentVNode("", true)
                                ], 64))
                              ]),
                              _: 2
                            }, 1040, ["label"]))
                          ]),
                          _: 2
                        }, 1040)) : createCommentVNode("", true)
                      ], 64))), 128)),
                      e.slots["search-middle"] ? (openBlock(), createElementBlock("div", Pf, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-middle"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true),
                      e.computedIsMultiLine ? createCommentVNode("", true) : (openBlock(), createBlock(u, {
                        key: 2,
                        buttons: e.computedButtons
                      }, null, 8, ["buttons"])),
                      e.slots["search-right"] ? (openBlock(), createElementBlock("div", Vf, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-right"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }, 512))
                ], 6),
                e.computedIsMultiLine ? (openBlock(), createBlock(u, {
                  key: 0,
                  buttons: e.computedButtons
                }, null, 8, ["buttons"])) : createCommentVNode("", true)
              ]),
              e.computedIsMultiLine ? (openBlock(), createElementBlock("div", Mf, [
                (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                  default: withCtx(() => [
                    createVNode(l2, {
                      icon: e.collapse ? e.ui.icons.caretUp : e.ui.icons.caretDown,
                      onClick: e.toggleCollapse
                    }, null, 8, ["icon", "onClick"])
                  ]),
                  _: 1
                }))
              ])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 16, ["model", "rules"]))
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var Bf = Se($f, [["render", jf]]);
var Nf = defineComponent({
  name: "FsSearchLayoutDefault",
  props: {
    /**
     * 是否收缩
     */
    collapse: {
      type: Boolean,
      default: true
    },
    /**
     * 展开按钮
     */
    collapseButton: {
      type: Object
    },
    action: {
      type: Object
    },
    /**
     * 布局模式
     */
    layout: {
      type: String,
      default: "single-line"
    },
    /**
     * 查询字段列表，可以精细化自定义查询字段布局
     */
    columns: {
      type: Object
    },
    /**
     * 默认的col配置
     */
    col: {
      type: Object
    },
    /**
     * 获取查询上下文
     */
    getContextFn: {
      type: Function
    }
  },
  emits: ["update:collapse", "collapse"],
  setup(e, t) {
    const { ui: n } = w(), { t: o } = tt(), a = ref(), r = computed(() => e.layout === "multi-line");
    onMounted(() => {
      r.value && a.value && (s.value = a.value.$el.offsetHeight);
    });
    const i = computed(() => !r.value || !e.collapse ? "auto" : s.value ? s.value + "px" : ""), s = ref(0), u = () => {
      t.emit("update:collapse", !e.collapse), t.emit("collapse", !e.collapse);
    };
    function l2(c) {
      return lodash_default_default.merge({}, e.col, c);
    }
    return {
      ui: n,
      columnsRowRef: a,
      computedColumnBoxHeight: i,
      computedIsMultiLine: r,
      toggleCollapse: u,
      mergeCol: l2,
      t: o
    };
  }
});
var Lf = { class: "fs-search-box" };
var qf = { class: "fs-search-col fs-search-slot" };
var Hf = { class: "fs-search-col fs-search-slot" };
var Wf = {
  key: 0,
  class: "fs-search-buttons-group fs-search-multi-line-buttons"
};
function xf(e, t, n, o, a, r) {
  var u;
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["fs-search-layout-default", { "fs-search-multi-line": e.computedIsMultiLine }])
  }, [
    createBaseVNode("div", Lf, [
      createBaseVNode("div", {
        class: normalizeClass(["fs-search-main", { "fs-search-collapse": e.collapse }]),
        style: normalizeStyle({ maxHeight: e.computedColumnBoxHeight })
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), {
          ref: "columnsRowRef",
          class: "fs-search-columns"
        }, {
          default: withCtx(() => {
            var l2;
            return [
              createBaseVNode("span", qf, [
                renderSlot(e.$slots, "search-left")
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(e.columns, (c, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                c.show ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                  key: 0,
                  class: "fs-search-col"
                }, e.mergeCol(c.col)), {
                  default: withCtx(() => [
                    createVNode(i, {
                      "render-func": c._cellRender,
                      scope: e.getContextFn()
                    }, null, 8, ["render-func", "scope"])
                  ]),
                  _: 2
                }, 1040)) : createCommentVNode("", true)
              ], 64))), 128)),
              createBaseVNode("span", Hf, [
                renderSlot(e.$slots, "search-middle")
              ]),
              e.computedIsMultiLine ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                key: 0,
                class: "fs-search-col fs-search-buttons-group"
              }, e.mergeCol((l2 = e.action) == null ? void 0 : l2.col)), {
                default: withCtx(() => {
                  var c;
                  return [
                    (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), normalizeProps({
                      [e.ui.formItem.label || ""]: (c = e.action) == null ? void 0 : c.label
                    }), {
                      default: withCtx(() => [
                        renderSlot(e.$slots, "search-buttons", normalizeProps(guardReactiveProps(e.getContextFn()))),
                        renderSlot(e.$slots, "search-right", normalizeProps(guardReactiveProps(e.getContextFn())))
                      ]),
                      _: 3
                    }, 16))
                  ];
                }),
                _: 3
              }, 16))
            ];
          }),
          _: 3
        }, 512))
      ], 6),
      e.computedIsMultiLine ? (openBlock(), createElementBlock("div", Wf, [
        renderSlot(e.$slots, "search-buttons"),
        ((u = e.collapseButton) == null ? void 0 : u.show) !== false ? (openBlock(), createBlock(s, mergeProps({
          key: 0,
          icon: e.collapse ? e.ui.icons.caretUp : e.ui.icons.caretDown,
          text: e.collapse ? e.t("fs.search.container.collapseButton.text.expand") : e.t("fs.search.container.collapseButton.text.collapse")
        }, e.collapseButton, { onClick: e.toggleCollapse }), null, 16, ["icon", "text", "onClick"])) : createCommentVNode("", true),
        renderSlot(e.$slots, "search-right")
      ])) : createCommentVNode("", true)
    ])
  ], 2);
}
var zf = Se(Nf, [["render", xf]]);
var Uf = { class: "fs-tabs-filter" };
var Yf = defineComponent({
  name: "FsTabsFilter",
  inheritAttrs: false
});
var Kf = defineComponent({
  ...Yf,
  props: {
    name: {},
    show: { type: Boolean, default: false },
    defaultOption: { default: void 0 },
    options: { default: () => [] },
    modelValue: {},
    value: { default: "value" },
    label: { default: "label" }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = useAttrs(), { merge: a } = Fe(), r = computed(() => a({
      show: true,
      value: null,
      label: "全部"
    }, n.defaultOption || {})), i = "_default_key_", s = computed(() => {
      const f = n.modelValue == null || n.modelValue === r.value.value ? i : n.modelValue;
      return {
        type: "card",
        ...o,
        [d.tabs.modelValue]: f,
        ["onUpdate:" + d.tabs.modelValue]: u
      };
    });
    function u(f) {
      i === f && (f = r.value.value);
      const h2 = n.modelValue;
      t("update:modelValue", f), h2 !== f && t("change", f);
    }
    function l2(f) {
      return f[n.value];
    }
    function c(f) {
      return f[n.label];
    }
    const { ui: d } = w();
    return (f, h2) => (openBlock(), createElementBlock("div", Uf, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(d).tabs.name), normalizeProps(guardReactiveProps(s.value)), {
        default: withCtx(() => [
          r.value.show ? (openBlock(), createBlock(resolveDynamicComponent(unref(d).tabPane.name), normalizeProps({
            key: 0,
            [unref(d).tabPane.key || ""]: i,
            [unref(d).tabPane.tab || ""]: r.value.label
          }), null, 16)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(f.options, (v, p) => (openBlock(), createBlock(resolveDynamicComponent(unref(d).tabPane.name), normalizeProps({
            key: p,
            [unref(d).tabPane.key || ""]: l2(v),
            [unref(d).tabPane.tab || ""]: c(v)
          }), null, 16))), 128))
        ]),
        _: 1
      }, 16))
    ]));
  }
});
var Gf = defineComponent({
  name: "FsDictRadio",
  props: {
    /**
     * 数据字典配置
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * radio组件名称
     * antdv使用button样式的时候有用
     * 即将废弃,请使用optionName
     */
    radioName: {},
    /**
     * 选项的组件名称
     */
    optionName: {
      type: String
    },
    /**
     * 选项的属性
     */
    optionProps: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const { ui: n } = w();
    e.radioName && console.warn("参数radioName即将废弃，请改成optionName");
    const o = computed(() => e.optionName ?? e.radioName ?? n.radio.name);
    let a = Gt(e, t, n.radioGroup.modelValue);
    const r = a.createComputedOptions();
    return {
      ui: n,
      computedRadioName: o,
      ...a,
      computedOptions: r
    };
  }
});
function Xf(e, t, n, o, a, r) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.radioGroup.name), null, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedOptions, (i) => (openBlock(), createBlock(resolveDynamicComponent(e.computedRadioName), mergeProps({
        key: e.getValue(i),
        [e.ui.radio.value || ""]: e.getValue(i)
      }, e.optionProps), {
        default: withCtx(() => [
          createTextVNode(toDisplayString(e.getLabel(i)), 1)
        ]),
        _: 2
      }, 1040))), 128))
    ]),
    _: 1
  });
}
var Qf = Se(Gf, [["render", Xf]]);
var Jf = defineComponent({
  name: "FsDictSelect",
  props: {
    /**
     * 字典
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: {
      type: Array
    },
    /**
     * placeholder
     */
    placeholder: {
      type: String
    },
    /**
     * select组件的插槽
     */
    slots: {},
    /**
     * 自定义label的render方法
     */
    renderLabel: {
      type: Function
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const {
      t: n
    } = tt(), o = computed(() => e.placeholder || n("fs.component.select.placeholder")), {
      ui: a
    } = w(), r = Gt(e, t, a.select.modelValue), i = r.createComputedOptions();
    return {
      computedPlaceholder: o,
      ...r,
      computedOptions: i
    };
  },
  render() {
    const {
      ui: e
    } = w(), t = resolveDynamicComponent(e.select.name);
    if (e.option.name == null) {
      const r = this.computedOptions || [];
      return createVNode(t, {
        placeholder: this.computedPlaceholder,
        options: r,
        renderLabel: this.renderLabel
      }, null);
    }
    const n = [], o = resolveDynamicComponent(e.option.name), a = this.computedOptions || [];
    for (const r of a) {
      const i = createVNode(o, mergeProps(r, {
        value: this.getValue(r),
        label: this.getLabel(r)
      }), {
        default: () => [this.renderLabel ? this.renderLabel(r) : this.getLabel(r)]
      });
      n.push(i);
    }
    return createVNode(t, {
      placeholder: this.computedPlaceholder
    }, {
      default: () => [n],
      ...this.slots
    });
  }
});
function Zf(e) {
  if (e == null)
    return 0;
  typeof e != "string" && (e = JSON.stringify(e));
  let t = 0, n, o, a;
  if (e.length === 0)
    return t;
  for (n = 0, a = e.length; n < a; n++)
    o = e.charCodeAt(n), t = (t << 5) - t + o, t |= 0;
  return t;
}
function eh(e) {
  let t = [];
  return typeof e.modelValue == "string" && e.multiple && e.separator != null && e.separator !== "" ? t = e.modelValue.split(e.separator) : e.modelValue instanceof Array ? t = e.modelValue : t = [e.modelValue], t;
}
var th = defineComponent({
  name: "FsValuesFormat",
  props: {
    /**
     * 值
     */
    modelValue: {},
    /**
     * 字典配置
     */
    dict: {},
    /**
     * 是否多选
     */
    multiple: { default: true },
    /**
     * 分隔符<br/>
     * 多选时，如果value为string，则以该分隔符分割成多个展示<br/>
     * 传入空字符串，表示不分割<br/>
     */
    separator: { default: "," },
    /**
     * 颜色
     * element=【auto, primary, success, warning, danger ,info】
     * antdv=【auto, primary, success, blue,red,...】
     * 配置auto，则自动根据value值hashcode分配颜色值
     */
    color: {},
    /**
     * 效果（仅element）
     **/
    effect: {},
    /**
     * 自动染色颜色值列表
     */
    autoColors: {
      type: Array
    },
    /**
     * 自动主题列表（仅element）
     * 【 light, plain 】
     */
    autoEffects: {
      type: Array
    },
    /**
     * 显示类型：【text, tag】
     */
    type: {
      default: "tag"
    },
    /**
     * 值的类型，【 value | object】
     */
    valueType: {
      type: String
    },
    /**
     * 当value值不在字典中时默认显示的文本
     */
    defaultLabel: {},
    /**
     * label自定义render
     */
    labelFormatter: {
      type: Function
    },
    /**
     * 自定义选项render
     */
    itemRender: {
      type: Function
    },
    closable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click", "dict-change", "close", "update:modelValue"],
  setup(e, t) {
    const { ui: n } = w(), o = n.tag.colors, a = ["plain", "light"], r = Gt(e, t), { getColor: i, getValue: s, removePropValue: u } = r;
    r.watchValue();
    function l2(h2, v) {
      !v.effect && h2.effect && (v.effect = h2.effect);
      const p = n.tag.type, F = i(v);
      if (F != null) {
        if (typeof F != "string")
          return;
        u(v, "color"), v[p] = F;
        return;
      }
      if (h2.color === "auto") {
        const _ = Zf(s(v)), D = h2.autoColors ? h2.autoColors : o;
        v[p] = D[_ % D.length];
        const k = h2.autoEffects ? h2.autoEffects : a;
        v.effect = k[Math.floor(_ / D.length) % k.length];
      } else
        v[p] = h2.color;
    }
    const c = computed(() => {
      var k, A;
      if (e.valueType === "object")
        return e.modelValue && !Array.isArray(e.modelValue) ? [e.modelValue] : e.modelValue;
      const h2 = r.getDict();
      if (e.modelValue == null || e.modelValue === "")
        return [];
      const v = eh(e);
      let p = [];
      const F = ((k = e.dict) == null ? void 0 : k.value) || "value", _ = ((A = e.dict) == null ? void 0 : A.label) || "label";
      h2 ? (p = h2.getNodesFromDataMap(v), lodash_default_default.forEach(p, (E) => {
        E[_] == null && (E[_] = e.defaultLabel || E[F]);
      })) : (p = [], lodash_default_default.forEach(v, (E) => {
        E instanceof Object ? p.push(E) : p.push({
          [F]: E,
          [_]: E
        });
      }));
      const D = [];
      return lodash_default_default.forEach(p, (E) => {
        D.push(lodash_default_default.omit(E, "children"));
      }), lodash_default_default.forEach(D, (E) => {
        l2(e, E);
      }), D;
    });
    function d(h2) {
      t.emit("click", { item: h2 });
    }
    function f(h2, v) {
      t.emit("close", { item: v, index: h2 });
      const p = [];
      for (let F = 0; F < c.value.length; F++)
        F !== h2 && p.push(s(c.value[F]));
      t.emit("update:modelValue", p);
    }
    return {
      ui: n,
      ...r,
      doClick: d,
      computedValueItems: c,
      doClose: f
    };
  }
});
var nh = { class: "fs-values-format" };
var oh = ["onClick"];
function rh(e, t, n, o, a, r) {
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-icon");
  return openBlock(), createElementBlock("span", nh, [
    e.itemRender ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(e.computedValueItems, (u) => (openBlock(), createBlock(i, {
      key: e.getValue(u),
      "render-func": e.itemRender,
      scope: u
    }, null, 8, ["render-func", "scope"]))), 128)) : e.type === "text" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(e.computedValueItems, (u) => (openBlock(), createElementBlock("span", {
      key: e.getValue(u),
      onClick: (l2) => e.doClick(u)
    }, toDisplayString(e.getLabel(u)), 9, oh))), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(e.computedValueItems, (u, l2) => (openBlock(), createBlock(resolveDynamicComponent(e.ui.tag.name), mergeProps({
      key: e.getValue(u),
      class: "fs-tag",
      size: "small",
      closable: e.closable
    }, u, {
      icon: null,
      name: null,
      onClose: (c) => e.doClose(l2, u),
      onClick: (c) => e.doClick(u)
    }), {
      default: withCtx(() => [
        u.icon ? (openBlock(), createBlock(s, {
          key: 0,
          icon: u.icon,
          class: "fs-tag-icon"
        }, null, 8, ["icon"])) : createCommentVNode("", true),
        createTextVNode(" " + toDisplayString(e.getLabel(u)), 1)
      ]),
      _: 2
    }, 1040, ["closable", "onClose", "onClick"]))), 128))
  ]);
}
var ah = Se(th, [["render", rh]]);
var ih = defineComponent({
  name: "FsDictCascaderFormat",
  props: {
    /**
     *   值<br/>
     *   单选时 '1,2,3' 或 [1,2,3]<br/>
     *   多选[[1,2,3],[4,5,6]]<br/>
     */
    modelValue: {
      type: [String, Array],
      default: void 0,
      require: true
    },
    /**
     *  value的分隔符<br/>
     *  多选时，如果value为string，则以该分隔符分割成多个展示<br/>
     *  传入空字符串，表示不分割<br/>
     */
    separator: { type: String, default: ",", require: false },
    /**
     * 是否多选
     */
    multiple: { type: Boolean, default: false },
    /**
     * 数据字典
     */
    dict: {
      type: Object,
      default: void 0,
      require: false
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    var o;
    const n = Gt(e, t);
    return (o = e.dict) != null && o.getNodesByValues && n.watchValue(), {
      ...n
    };
  },
  data() {
    return {};
  },
  computed: {
    labels() {
      return this.modelValue == null ? [] : this.buildValueItem(this.modelValue);
    },
    multipleLabels() {
      if (this.modelValue == null)
        return [];
      const e = [];
      for (const t of this.modelValue)
        e.push(this.buildValueItem(t));
      return e;
    }
  },
  methods: {
    getValueArr(e) {
      if (e == null)
        if (this.multiple) {
          e = [];
          for (const n of this.modelValue)
            for (const o of n)
              e.push(o);
        } else
          e = this.modelValue;
      if (e == null)
        return [];
      let t = null;
      return typeof e == "string" && !this.multiple && this.separator != null && this.separator !== "" ? t = e.split(this.separator) : e instanceof Array ? t = e : t = [e], t;
    },
    buildValueItem(e) {
      const t = this.getValueArr(e), n = this.getDict();
      if (n)
        return n.getNodesFromDataMap(t);
    }
  }
});
var sh = { key: 0 };
var lh = { key: 0 };
function uh(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("span", null, [
    e.multiple ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(e.multipleLabels, (i, s) => (openBlock(), createElementBlock("div", { key: s }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(i, (u, l2) => (openBlock(), createElementBlock("span", { key: l2 }, [
        l2 !== 0 ? (openBlock(), createElementBlock("span", sh, " / ")) : createCommentVNode("", true),
        createBaseVNode("span", null, toDisplayString(e.getLabel(u)), 1)
      ]))), 128))
    ]))), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(e.labels, (i, s) => (openBlock(), createElementBlock("span", { key: s }, [
      s !== 0 ? (openBlock(), createElementBlock("span", lh, " / ")) : createCommentVNode("", true),
      createBaseVNode("span", null, toDisplayString(e.getLabel(i)), 1)
    ]))), 128))
  ]);
}
var ch = Se(ih, [["render", uh]]);
var dh = defineComponent({
  name: "FsDictCascader",
  props: {
    /**
     * 字典配置
     */
    dict: {},
    /**
     * 选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const n = Gt(e, t), { ui: o } = w(), a = ref();
    e.dict && (a.value = o.cascader.fieldNames({
      value: e.dict.value,
      label: e.dict.label,
      children: e.dict.children
    }));
    const r = n.createComputedOptions();
    return {
      ui: o,
      ...n,
      fieldNamesBinder: a,
      computedOptions: r
    };
  }
});
function fh(e, t, n, o, a, r) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.cascader.name), mergeProps({ options: e.computedOptions }, e.fieldNamesBinder), null, 16, ["options"]);
}
var hh = Se(dh, [["render", fh]]);
var mh = defineComponent({
  name: "FsDictCheckbox",
  props: {
    /**
     * 字典
     */
    dict: {},
    /**
     * 选项，比dict.data优先级高
     */
    options: { type: Array, default: void 0, require: false },
    /**
     * 选项的组件名称
     */
    optionName: {
      type: String
    },
    /**
     * 选项的属性
     */
    optionProps: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const { ui: n } = w();
    let o = Gt(e, t, n.checkboxGroup.modelValue);
    const a = o.createComputedOptions();
    return {
      ui: n,
      ...o,
      computedOptions: a
    };
  }
});
function ph(e, t, n, o, a, r) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.checkboxGroup.name), null, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedOptions, (i) => (openBlock(), createBlock(resolveDynamicComponent(e.optionName || e.ui.checkbox.name), mergeProps({
        key: e.getValue(i),
        [e.ui.checkbox.value || ""]: e.getValue(i)
      }, e.optionProps), {
        default: withCtx(() => [
          createTextVNode(toDisplayString(e.getLabel(i)), 1)
        ]),
        _: 2
      }, 1040))), 128))
    ]),
    _: 1
  });
}
var gh = Se(mh, [["render", ph]]);
var vh = defineComponent({
  name: "FsDictSwitch",
  props: {
    /**
     * 字典第一个为开启
     * 第二个为关闭
     */
    dict: {
      type: Object
    },
    options: {},
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const { ui: n } = w();
    let o = Gt(e, t, n.switch.modelValue);
    const a = o.createComputedOptions();
    return {
      ui: n,
      ...o,
      computedOptions: a
    };
  },
  computed: {
    _active() {
      return this.computedOptions.length > 0 ? this.computedOptions[0] : {};
    },
    _inActive() {
      return this.computedOptions.length > 1 ? this.computedOptions[1] : {};
    },
    binding() {
      var t, n, o, a, r, i;
      const e = l.get();
      return {
        [e.switch.activeText]: this._active[((t = this.dict) == null ? void 0 : t.label) || "label"],
        [e.switch.inactiveText]: this._inActive[((n = this.dict) == null ? void 0 : n.label) || "label"],
        [e.switch.activeColor]: this._active[((o = this.dict) == null ? void 0 : o.color) || "color"],
        [e.switch.inactiveColor]: this._inActive[((a = this.dict) == null ? void 0 : a.color) || "color"],
        [e.switch.activeValue]: this._active[((r = this.dict) == null ? void 0 : r.value) || "value"],
        [e.switch.inactiveValue]: this._inActive[((i = this.dict) == null ? void 0 : i.value) || "value"]
      };
    }
  }
});
function bh(e, t, n, o, a, r) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.switch.name), normalizeProps(guardReactiveProps(e.binding)), null, 16);
}
var yh = Se(vh, [["render", bh]]);
var wh = defineComponent({
  name: "FsDateFormat",
  props: {
    /**
     * 日期时间值，支持long,string,date等，由dayjs转化
     */
    modelValue: { required: false },
    /**
     *  输入格式化，不传则由dayjs自动转化
     */
    valueFormat: { type: String, default: void 0, required: false },
    /**
     *  输出格式化
     */
    format: { type: String, default: "YYYY-MM-DD HH:mm:ss", required: false }
  },
  data() {
    return {
      item: {}
    };
  },
  computed: {
    doFormat() {
      if (this.modelValue == null || this.modelValue === "")
        return "";
      let e = null;
      return this.valueFormat != null ? e = (0, import_dayjs.default)(this.modelValue, this.valueFormat) : e = (0, import_dayjs.default)(this.modelValue), e.format(this.format);
    }
  },
  created() {
  },
  methods: {}
});
function _h(e, t, n, o, a, r) {
  return openBlock(), createElementBlock("span", null, toDisplayString(e.doFormat), 1);
}
var Ch = Se(wh, [["render", _h]]);
var Fh = defineComponent({
  name: "FsDictTree",
  props: {
    /**
     * 数据字典
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * placeholder
     */
    placeholder: { type: String },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  // render () {
  //   return this.renderFunc({ data: this.data, dataMap: this.dataMap, scope: this.scope, attrs: this.$attrs })
  // },
  setup(e, t) {
    const { t: n } = tt(), { ui: o } = w(), a = computed(() => e.placeholder || n("fs.component.select.placeholder"));
    let r = Gt(e, t);
    const i = r.createComputedOptions();
    return {
      ui: o,
      computedPlaceholder: a,
      ...r,
      computedOptions: i
    };
  }
});
function Sh(e, t, n, o, a, r) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.treeSelect.name), normalizeProps({
    [e.ui.treeSelect.options || ""]: e.computedOptions,
    placeholder: e.computedPlaceholder
  }), null, 16, ["placeholder"]);
}
var Eh = Se(Fh, [["render", Sh]]);
var Dh = {
  class: "fs-table-select"
};
var Rh = {
  class: "fs-table-select-current"
};
var kh = defineComponent({
  __name: "fs-table-select",
  props: {
    modelValue: {},
    createCrudOptions: {},
    crudOptionsOverride: {
      default: void 0
    },
    dict: {},
    select: {
      default: void 0
    },
    showSelect: {
      type: Boolean,
      default: true
    },
    dialog: {
      default: void 0
    },
    valuesFormat: {
      default: void 0
    },
    height: {
      default: void 0
    },
    multiple: {
      type: Boolean
    },
    crossPage: {
      type: Boolean,
      default: true
    },
    rowKey: {
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    valueType: {
      default: "value"
    }
  },
  emits: ["change", "update:modelValue"],
  setup(e, {
    expose: t,
    emit: n
  }) {
    const o = e, a = useSlots(), {
      ui: r
    } = w(), i = ref(), s = ref(), u = ref(false);
    function l2(I) {
      I == null || Array.isArray(I) && I.length == 0 ? v.value = [] : (o.multiple ? v.value = I || [] : v.value = [I], o.valueType === "object" && (v.value = v.value.map((M) => o.dict.getValue(M))));
    }
    const c = async () => {
      var I, M;
      if (!(o.disabled || o.readonly || (I = o.select) != null && I.disabled || (M = o.select) != null && M.readonly)) {
        if (o.dict == null)
          throw new Error("必须配置dict，且必须配置dict.getNodesByValues");
        u.value = true, l2(o.modelValue), await E.doRefresh();
      }
    }, d = computed(() => ({
      ...o.valuesFormat
    })), f = computed(() => {
      const I = `onUpdate:${r.select.modelValue}`;
      let M = o.modelValue;
      return o.valueType === "object" && o.modelValue && (o.multiple ? M = o.modelValue.map((N) => o.dict.getValue(N)) : M = o.dict.getValue(o.modelValue)), {
        [r.select.modelValue]: M,
        [I]: (N) => {
          n("update:modelValue", N);
        },
        [r.select.clearable]: true,
        ...r.select.buildMultiBinding(o.multiple),
        show: false,
        ...o.select
      };
    }), h2 = computed(() => {
      const I = r.dialog.buildProps({
        title: "选择",
        width: "80%"
      });
      return D(I, o.dialog);
    });
    watch(() => o.modelValue, async (I) => {
      I !== v.value && (l2(I), await nextTick(), await o.dict.appendByValues(v.value));
    });
    const v = ref([]);
    function p() {
      return o.rowKey || k.value.table.rowKey || "id";
    }
    const F = ref(false), _ = computed(() => {
      let I = r.table.buildSelectionCrudOptions({
        crossPage: o.crossPage,
        getRowKey: p,
        getPageData() {
          return k.value.data;
        },
        multiple: o.multiple,
        selectedRowKeys: v,
        onSelectedKeysChanged: async (N) => {
          v.value = [...N], await nextTick(), await o.dict.appendByValues(v.value);
        }
      });
      return D({
        table: {
          async onRefreshed() {
            r.table.setSelectedRows && (F.value = true, await nextTick(), await nextTick(), r.table.setSelectedRows({
              getRowKey: p,
              multiple: o.multiple,
              tableRef: E.getBaseTableRef(),
              selectedRowKeys: v
            }), F.value = false);
          }
        }
      }, I, o.crudOptionsOverride);
    }), {
      merge: D
    } = Fe(), {
      crudBinding: k,
      crudRef: A,
      crudExpose: E,
      context: $,
      appendCrudOptions: S,
      crudOptions: O
    } = vl({
      createCrudOptions: o.createCrudOptions,
      crudOptionsOverride: _.value
    });
    watch(() => o.crudOptionsOverride, async (I, M) => {
      var J;
      if (JSON.stringify(I) === JSON.stringify(M))
        return;
      const N = (J = k.value) == null ? void 0 : J.pagination[r.pagination.currentPage];
      S(I), A.value && (k.value.pagination[r.pagination.currentPage] = N, await E.doRefresh({
        goFirstPage: false
      }));
    });
    function B() {
      var M;
      if (o.dict.loading)
        return;
      let I = null;
      ((M = v.value) == null ? void 0 : M.length) > 0 && (I = [...v.value], o.valueType === "object" && (I = I.map((N) => o.dict.getDictMap()[N])), o.multiple !== true && (I = I[0])), n("update:modelValue", I), n("change", I), u.value = false;
    }
    const Q = ref((() => ({
      opened: u,
      open: c
    }))());
    return t(Q.value), (I, M) => {
      var ge;
      const N = resolveComponent("fs-dict-select"), J = resolveComponent("fs-values-format"), Z = resolveComponent("fs-crud");
      return openBlock(), createElementBlock("div", Dh, [(ge = unref(a)) != null && ge.default ? createCommentVNode("", true) : (openBlock(), createBlock(N, mergeProps({
        key: 0,
        ref_key: "dictSelectRef",
        ref: i,
        dict: I.dict,
        disabled: I.disabled,
        readonly: I.readonly
      }, f.value, {
        open: false,
        onClick: c
      }), null, 16, ["dict", "disabled", "readonly"])), renderSlot(I.$slots, "default", normalizeProps(guardReactiveProps(Q.value))), (openBlock(), createBlock(resolveDynamicComponent(unref(r).formItem.skipValidationWrapper), null, {
        default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(r).dialog.name), mergeProps({
          [unref(r).dialog.visible]: u.value,
          ["onUpdate:" + unref(r).dialog.visible]: M[2] || (M[2] = (z) => u.value = z)
        }, h2.value), {
          [unref(r).dialog.footerSlotName]: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(r).button.name), {
            onClick: M[1] || (M[1] = (z) => u.value = false)
          }, {
            default: withCtx(() => [createTextVNode("取消")]),
            _: 1
          })), (openBlock(), createBlock(resolveDynamicComponent(unref(r).button.name), {
            type: "primary",
            onClick: B
          }, {
            default: withCtx(() => [createTextVNode("确认")]),
            _: 1
          }))]),
          default: withCtx(() => [createBaseVNode("div", {
            style: normalizeStyle({
              width: "100%",
              height: I.height || "60vh"
            })
          }, [createVNode(Z, mergeProps({
            ref_key: "crudRef",
            ref: A
          }, unref(k)), {
            "header-top": withCtx(() => [createBaseVNode("div", Rh, [createTextVNode(" 当前选中： "), createVNode(J, mergeProps({
              ref_key: "valuesFormatRef",
              ref: s,
              modelValue: v.value,
              "onUpdate:modelValue": M[0] || (M[0] = (z) => v.value = z),
              dict: I.dict,
              closable: true
            }, d.value), null, 16, ["modelValue", "dict"])])]),
            _: 1
          }, 16)], 4)]),
          _: 2
        }, 1040))]),
        _: 1
      }))]);
    };
  }
});
var ia = Object.freeze(Object.defineProperty({
  __proto__: null,
  FsActionbar: ad,
  FsBox: gu,
  FsButton: Jl,
  FsCell: Uc,
  FsColumnsFilterLayoutDefault: Cf,
  FsComponentRender: yu,
  FsContainer: Pl,
  FsCrud: oc,
  FsDateFormat: Ch,
  FsDictCascader: hh,
  FsDictCascaderFormat: ch,
  FsDictCheckbox: gh,
  FsDictRadio: Qf,
  FsDictSelect: Jf,
  FsDictSwitch: yh,
  FsDictTree: Eh,
  FsEditable: td,
  FsEditableCell: Yc,
  FsForm: Fu,
  FsFormHelper: Nu,
  FsFormItem: Iu,
  FsFormProvider: Hu,
  FsFormWrapper: qn,
  FsIcon: Zl,
  FsIconSvg: su,
  FsIconify: nu,
  FsLabel: du,
  FsLayoutCard: Xl,
  FsLayoutDefault: Hl,
  FsLoading: fu,
  FsPage: Ms,
  FsRender: Ma,
  FsRowHandle: lc,
  FsSearch: Of,
  FsSearchLayoutDefault: zf,
  FsSearchV1: Bf,
  FsSlotRender: wu,
  FsTable: zc,
  FsTableSelect: kh,
  FsTabsFilter: Kf,
  FsToolbar: cd,
  FsValuesFormat: ah
}, Symbol.toStringTag, { value: "Module" }));
var { setDictRequest: Oh } = Cl();
var xh = {
  install(e, t = {}) {
    t.ui && l.set(t.ui);
    const { merge: n } = Fe();
    t.commonOptions && (Nn.commonOptions = t.commonOptions), t.dictRequest && Oh(t.dictRequest), t.i18n && io.setVueI18n(t.i18n);
    for (const o in ia) {
      const a = ia[o];
      e.component(o, a);
    }
    qn._context = e._context, dn.install(), e.config.globalProperties.$fsui = l.get(), n(Rl.logger, t.logger), $h(t.logger);
  }
};
function $h(e) {
  var t;
  ((t = e == null ? void 0 : e.off) == null ? void 0 : t.tableColumns) !== false && console.warn(`[fast-crud] crudBinding.value.table.columns / toolbar.columnsFilter.originalColumns 由array改成map. 请改成通过key读取，你可以全局代码搜索【value.table.columns / columnsFilter.originalColumns】来检查是否有使用它们。
      [通过 app.use(FastCrud,{logger:{off:{tableColumns:false}}}) 可关闭此警告] `);
}

export {
  Ei,
  ko,
  tt,
  Oo,
  $o,
  Ms,
  Fe,
  To,
  zs,
  Cr,
  Us,
  an,
  Ao,
  Er,
  Zo,
  vo,
  ol,
  il,
  ul,
  cl,
  dl,
  hl,
  Bh,
  ka,
  ml,
  pl,
  gl,
  vl,
  Nh,
  Gt,
  Va,
  _l,
  Cl,
  Hh,
  Dl,
  Rl,
  Pl,
  Hl,
  Xl,
  Jl,
  Zl,
  nu,
  su,
  du,
  fu,
  gu,
  yu,
  wu,
  Ma,
  Fu,
  Iu,
  Nu,
  qn,
  Hu,
  oc,
  lc,
  zc,
  Uc,
  Yc,
  td,
  ad,
  Wh,
  La,
  cd,
  Cf,
  Of,
  Bf,
  zf,
  Kf,
  Qf,
  Jf,
  ah,
  ch,
  hh,
  gh,
  yh,
  Ch,
  Eh,
  kh,
  xh
};
/*! Bundled license information:

@fast-crud/fast-crud/dist/index-bae3872a.mjs:
  (**!
   * Sortable 1.14.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-HL2MGXCM.js.map
