import {
  c
} from "./chunk-DNE5XC46.js";
import {
  _9,
  w9
} from "./chunk-HBLLDVYX.js";
import "./chunk-3VNCHJQI.js";
import "./chunk-HL2MGXCM.js";
import "./chunk-RT6XIFAZ.js";
import "./chunk-PBJIO4MK.js";
import "./chunk-TMD4VLGD.js";
import "./chunk-OBCII6EX.js";
import {
  lodash_default_default
} from "./chunk-6KFXODJP.js";
import "./chunk-XUBID5G4.js";
import "./chunk-7Q7JYBSX.js";
import {
  axios_default
} from "./chunk-26VIGQ2D.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
var init_httpExtensionConfiguration = __esm({
  "node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/extensions/index.js
var init_extensions = __esm({
  "node_modules/@smithy/protocol-http/dist-es/extensions/index.js"() {
    init_httpExtensionConfiguration();
  }
});

// node_modules/@smithy/types/dist-es/abort.js
var init_abort = __esm({
  "node_modules/@smithy/types/dist-es/abort.js"() {
  }
});

// node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
var init_auth = __esm({
  "node_modules/@smithy/types/dist-es/auth/auth.js"() {
    (function(HttpAuthLocation2) {
      HttpAuthLocation2["HEADER"] = "header";
      HttpAuthLocation2["QUERY"] = "query";
    })(HttpAuthLocation || (HttpAuthLocation = {}));
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
var init_HttpApiKeyAuth = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js"() {
    (function(HttpApiKeyAuthLocation2) {
      HttpApiKeyAuthLocation2["HEADER"] = "header";
      HttpApiKeyAuthLocation2["QUERY"] = "query";
    })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
var init_HttpAuthScheme = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js"() {
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
var init_HttpAuthSchemeProvider = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js"() {
  }
});

// node_modules/@smithy/types/dist-es/auth/HttpSigner.js
var init_HttpSigner = __esm({
  "node_modules/@smithy/types/dist-es/auth/HttpSigner.js"() {
  }
});

// node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
var init_IdentityProviderConfig = __esm({
  "node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js"() {
  }
});

// node_modules/@smithy/types/dist-es/auth/index.js
var init_auth2 = __esm({
  "node_modules/@smithy/types/dist-es/auth/index.js"() {
    init_auth();
    init_HttpApiKeyAuth();
    init_HttpAuthScheme();
    init_HttpAuthSchemeProvider();
    init_HttpSigner();
    init_IdentityProviderConfig();
  }
});

// node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
var init_blob_payload_input_types = __esm({
  "node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js"() {
  }
});

// node_modules/@smithy/types/dist-es/checksum.js
var init_checksum = __esm({
  "node_modules/@smithy/types/dist-es/checksum.js"() {
  }
});

// node_modules/@smithy/types/dist-es/client.js
var init_client = __esm({
  "node_modules/@smithy/types/dist-es/client.js"() {
  }
});

// node_modules/@smithy/types/dist-es/command.js
var init_command = __esm({
  "node_modules/@smithy/types/dist-es/command.js"() {
  }
});

// node_modules/@smithy/types/dist-es/connection/config.js
var init_config = __esm({
  "node_modules/@smithy/types/dist-es/connection/config.js"() {
  }
});

// node_modules/@smithy/types/dist-es/connection/manager.js
var init_manager = __esm({
  "node_modules/@smithy/types/dist-es/connection/manager.js"() {
  }
});

// node_modules/@smithy/types/dist-es/connection/pool.js
var init_pool = __esm({
  "node_modules/@smithy/types/dist-es/connection/pool.js"() {
  }
});

// node_modules/@smithy/types/dist-es/connection/index.js
var init_connection = __esm({
  "node_modules/@smithy/types/dist-es/connection/index.js"() {
    init_config();
    init_manager();
    init_pool();
  }
});

// node_modules/@smithy/types/dist-es/crypto.js
var init_crypto = __esm({
  "node_modules/@smithy/types/dist-es/crypto.js"() {
  }
});

// node_modules/@smithy/types/dist-es/encode.js
var init_encode = __esm({
  "node_modules/@smithy/types/dist-es/encode.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
var init_endpoint = __esm({
  "node_modules/@smithy/types/dist-es/endpoint.js"() {
    (function(EndpointURLScheme2) {
      EndpointURLScheme2["HTTP"] = "http";
      EndpointURLScheme2["HTTPS"] = "https";
    })(EndpointURLScheme || (EndpointURLScheme = {}));
  }
});

// node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
var init_EndpointRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
var init_ErrorRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
var init_RuleSetObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoints/shared.js
var init_shared = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/shared.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
var init_TreeRuleObject = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js"() {
  }
});

// node_modules/@smithy/types/dist-es/endpoints/index.js
var init_endpoints = __esm({
  "node_modules/@smithy/types/dist-es/endpoints/index.js"() {
    init_EndpointRuleObject();
    init_ErrorRuleObject();
    init_RuleSetObject();
    init_shared();
    init_TreeRuleObject();
  }
});

// node_modules/@smithy/types/dist-es/eventStream.js
var init_eventStream = __esm({
  "node_modules/@smithy/types/dist-es/eventStream.js"() {
  }
});

// node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
var init_checksum2 = __esm({
  "node_modules/@smithy/types/dist-es/extensions/checksum.js"() {
    (function(AlgorithmId2) {
      AlgorithmId2["MD5"] = "md5";
      AlgorithmId2["CRC32"] = "crc32";
      AlgorithmId2["CRC32C"] = "crc32c";
      AlgorithmId2["SHA1"] = "sha1";
      AlgorithmId2["SHA256"] = "sha256";
    })(AlgorithmId || (AlgorithmId = {}));
  }
});

// node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
var init_defaultClientConfiguration = __esm({
  "node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js"() {
    init_checksum2();
  }
});

// node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
var init_defaultExtensionConfiguration = __esm({
  "node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js"() {
  }
});

// node_modules/@smithy/types/dist-es/extensions/index.js
var init_extensions2 = __esm({
  "node_modules/@smithy/types/dist-es/extensions/index.js"() {
    init_defaultClientConfiguration();
    init_defaultExtensionConfiguration();
    init_checksum2();
  }
});

// node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
var init_http = __esm({
  "node_modules/@smithy/types/dist-es/http.js"() {
    (function(FieldPosition2) {
      FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
      FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition || (FieldPosition = {}));
  }
});

// node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
var init_httpHandlerInitialization = __esm({
  "node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js"() {
  }
});

// node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
var init_apiKeyIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js"() {
  }
});

// node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
var init_awsCredentialIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js"() {
  }
});

// node_modules/@smithy/types/dist-es/identity/identity.js
var init_identity = __esm({
  "node_modules/@smithy/types/dist-es/identity/identity.js"() {
  }
});

// node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
var init_tokenIdentity = __esm({
  "node_modules/@smithy/types/dist-es/identity/tokenIdentity.js"() {
  }
});

// node_modules/@smithy/types/dist-es/identity/index.js
var init_identity2 = __esm({
  "node_modules/@smithy/types/dist-es/identity/index.js"() {
    init_apiKeyIdentity();
    init_awsCredentialIdentity();
    init_identity();
    init_tokenIdentity();
  }
});

// node_modules/@smithy/types/dist-es/logger.js
var init_logger = __esm({
  "node_modules/@smithy/types/dist-es/logger.js"() {
  }
});

// node_modules/@smithy/types/dist-es/middleware.js
var init_middleware = __esm({
  "node_modules/@smithy/types/dist-es/middleware.js"() {
  }
});

// node_modules/@smithy/types/dist-es/pagination.js
var init_pagination = __esm({
  "node_modules/@smithy/types/dist-es/pagination.js"() {
  }
});

// node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
var init_profile = __esm({
  "node_modules/@smithy/types/dist-es/profile.js"() {
    (function(IniSectionType2) {
      IniSectionType2["PROFILE"] = "profile";
      IniSectionType2["SSO_SESSION"] = "sso-session";
      IniSectionType2["SERVICES"] = "services";
    })(IniSectionType || (IniSectionType = {}));
  }
});

// node_modules/@smithy/types/dist-es/response.js
var init_response = __esm({
  "node_modules/@smithy/types/dist-es/response.js"() {
  }
});

// node_modules/@smithy/types/dist-es/retry.js
var init_retry = __esm({
  "node_modules/@smithy/types/dist-es/retry.js"() {
  }
});

// node_modules/@smithy/types/dist-es/serde.js
var init_serde = __esm({
  "node_modules/@smithy/types/dist-es/serde.js"() {
  }
});

// node_modules/@smithy/types/dist-es/shapes.js
var init_shapes = __esm({
  "node_modules/@smithy/types/dist-es/shapes.js"() {
  }
});

// node_modules/@smithy/types/dist-es/signature.js
var init_signature = __esm({
  "node_modules/@smithy/types/dist-es/signature.js"() {
  }
});

// node_modules/@smithy/types/dist-es/stream.js
var init_stream = __esm({
  "node_modules/@smithy/types/dist-es/stream.js"() {
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
var init_streaming_blob_common_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js"() {
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
var init_streaming_blob_payload_input_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js"() {
  }
});

// node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
var init_streaming_blob_payload_output_types = __esm({
  "node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js"() {
  }
});

// node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
var init_transfer = __esm({
  "node_modules/@smithy/types/dist-es/transfer.js"() {
    (function(RequestHandlerProtocol2) {
      RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
      RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
      RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
  }
});

// node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
var init_client_payload_blob_type_narrow = __esm({
  "node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js"() {
  }
});

// node_modules/@smithy/types/dist-es/transform/no-undefined.js
var init_no_undefined = __esm({
  "node_modules/@smithy/types/dist-es/transform/no-undefined.js"() {
  }
});

// node_modules/@smithy/types/dist-es/transform/type-transform.js
var init_type_transform = __esm({
  "node_modules/@smithy/types/dist-es/transform/type-transform.js"() {
  }
});

// node_modules/@smithy/types/dist-es/uri.js
var init_uri = __esm({
  "node_modules/@smithy/types/dist-es/uri.js"() {
  }
});

// node_modules/@smithy/types/dist-es/util.js
var init_util = __esm({
  "node_modules/@smithy/types/dist-es/util.js"() {
  }
});

// node_modules/@smithy/types/dist-es/waiter.js
var init_waiter = __esm({
  "node_modules/@smithy/types/dist-es/waiter.js"() {
  }
});

// node_modules/@smithy/types/dist-es/index.js
var init_dist_es = __esm({
  "node_modules/@smithy/types/dist-es/index.js"() {
    init_abort();
    init_auth2();
    init_blob_payload_input_types();
    init_checksum();
    init_client();
    init_command();
    init_connection();
    init_crypto();
    init_encode();
    init_endpoint();
    init_endpoints();
    init_eventStream();
    init_extensions2();
    init_http();
    init_httpHandlerInitialization();
    init_identity2();
    init_logger();
    init_middleware();
    init_pagination();
    init_profile();
    init_response();
    init_retry();
    init_serde();
    init_shapes();
    init_signature();
    init_stream();
    init_streaming_blob_common_types();
    init_streaming_blob_payload_input_types();
    init_streaming_blob_payload_output_types();
    init_transfer();
    init_client_payload_blob_type_narrow();
    init_no_undefined();
    init_type_transform();
    init_uri();
    init_util();
    init_waiter();
  }
});

// node_modules/@smithy/protocol-http/dist-es/Field.js
var init_Field = __esm({
  "node_modules/@smithy/protocol-http/dist-es/Field.js"() {
    init_dist_es();
  }
});

// node_modules/@smithy/protocol-http/dist-es/Fields.js
var init_Fields = __esm({
  "node_modules/@smithy/protocol-http/dist-es/Fields.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpHandler.js
var init_httpHandler = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpHandler.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpRequest.js
var init_httpRequest = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpRequest.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var init_httpResponse = __esm({
  "node_modules/@smithy/protocol-http/dist-es/httpResponse.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
var init_isValidHostname = __esm({
  "node_modules/@smithy/protocol-http/dist-es/isValidHostname.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/types.js
var init_types = __esm({
  "node_modules/@smithy/protocol-http/dist-es/types.js"() {
  }
});

// node_modules/@smithy/protocol-http/dist-es/index.js
var init_dist_es2 = __esm({
  "node_modules/@smithy/protocol-http/dist-es/index.js"() {
    init_extensions();
    init_Field();
    init_Fields();
    init_httpHandler();
    init_httpRequest();
    init_httpResponse();
    init_isValidHostname();
    init_types();
  }
});

// node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
var init_NoOpLogger = __esm({
  "node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js"() {
  }
});

// node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var init_MiddlewareStack = __esm({
  "node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js"() {
  }
});

// node_modules/@smithy/middleware-stack/dist-es/index.js
var init_dist_es3 = __esm({
  "node_modules/@smithy/middleware-stack/dist-es/index.js"() {
    init_MiddlewareStack();
  }
});

// node_modules/@smithy/smithy-client/dist-es/client.js
var init_client2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/client.js"() {
    init_dist_es3();
  }
});

// node_modules/@smithy/util-base64/dist-es/constants.browser.js
var alphabetByEncoding, alphabetByValue;
var init_constants_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/constants.browser.js"() {
    alphabetByEncoding = {};
    alphabetByValue = new Array(64);
    for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
      const char = String.fromCharCode(i + start);
      alphabetByEncoding[char] = i;
      alphabetByValue[i] = char;
    }
    for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
      const char = String.fromCharCode(i + start);
      const index = i + 26;
      alphabetByEncoding[char] = index;
      alphabetByValue[index] = char;
    }
    for (let i = 0; i < 10; i++) {
      alphabetByEncoding[i.toString(10)] = i + 52;
      const char = i.toString(10);
      const index = i + 52;
      alphabetByEncoding[char] = index;
      alphabetByValue[index] = char;
    }
    alphabetByEncoding["+"] = 62;
    alphabetByValue[62] = "+";
    alphabetByEncoding["/"] = 63;
    alphabetByValue[63] = "/";
  }
});

// node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
var init_fromBase64_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js"() {
    init_constants_browser();
  }
});

// node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
var init_toBase64_browser = __esm({
  "node_modules/@smithy/util-base64/dist-es/toBase64.browser.js"() {
    init_constants_browser();
  }
});

// node_modules/@smithy/util-base64/dist-es/index.js
var init_dist_es4 = __esm({
  "node_modules/@smithy/util-base64/dist-es/index.js"() {
    init_fromBase64_browser();
    init_toBase64_browser();
  }
});

// node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
var fromUtf8;
var init_fromUtf8_browser = __esm({
  "node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js"() {
    fromUtf8 = (input) => new TextEncoder().encode(input);
  }
});

// node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array;
var init_toUint8Array = __esm({
  "node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    init_fromUtf8_browser();
    toUint8Array = (data) => {
      if (typeof data === "string") {
        return fromUtf8(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    };
  }
});

// node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
var init_toUtf8_browser = __esm({
  "node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js"() {
  }
});

// node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es5 = __esm({
  "node_modules/@smithy/util-utf8/dist-es/index.js"() {
    init_fromUtf8_browser();
    init_toUint8Array();
    init_toUtf8_browser();
  }
});

// node_modules/@smithy/util-stream/dist-es/blob/transforms.js
var init_transforms = __esm({
  "node_modules/@smithy/util-stream/dist-es/blob/transforms.js"() {
    init_dist_es4();
    init_dist_es5();
    init_Uint8ArrayBlobAdapter();
  }
});

// node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var init_Uint8ArrayBlobAdapter = __esm({
  "node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js"() {
    init_transforms();
  }
});

// node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
var init_getAwsChunkedEncodingStream_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js"() {
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri, hexEncode;
var init_escape_uri = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js"() {
    escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js"() {
    init_escape_uri();
  }
});

// node_modules/@smithy/util-uri-escape/dist-es/index.js
var init_dist_es6 = __esm({
  "node_modules/@smithy/util-uri-escape/dist-es/index.js"() {
    init_escape_uri();
    init_escape_uri_path();
  }
});

// node_modules/@smithy/querystring-builder/dist-es/index.js
var init_dist_es7 = __esm({
  "node_modules/@smithy/querystring-builder/dist-es/index.js"() {
    init_dist_es6();
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
var init_request_timeout = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js"() {
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport;
var init_fetch_http_handler = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js"() {
    init_dist_es2();
    init_dist_es7();
    init_request_timeout();
    keepAliveSupport = {
      supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
    };
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
var init_stream_collector = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js"() {
    init_dist_es4();
  }
});

// node_modules/@smithy/fetch-http-handler/dist-es/index.js
var init_dist_es8 = __esm({
  "node_modules/@smithy/fetch-http-handler/dist-es/index.js"() {
    init_fetch_http_handler();
    init_stream_collector();
  }
});

// node_modules/@smithy/util-hex-encoding/dist-es/index.js
function toHex(bytes) {
  let out = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    out += SHORT_TO_HEX[bytes[i]];
  }
  return out;
}
var SHORT_TO_HEX, HEX_TO_SHORT;
var init_dist_es9 = __esm({
  "node_modules/@smithy/util-hex-encoding/dist-es/index.js"() {
    SHORT_TO_HEX = {};
    HEX_TO_SHORT = {};
    for (let i = 0; i < 256; i++) {
      let encodedByte = i.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i;
    }
  }
});

// node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var init_sdk_stream_mixin_browser = __esm({
  "node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js"() {
    init_dist_es8();
    init_dist_es4();
    init_dist_es9();
    init_dist_es5();
  }
});

// node_modules/@smithy/util-stream/dist-es/index.js
var init_dist_es10 = __esm({
  "node_modules/@smithy/util-stream/dist-es/index.js"() {
    init_Uint8ArrayBlobAdapter();
    init_getAwsChunkedEncodingStream_browser();
    init_sdk_stream_mixin_browser();
  }
});

// node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var init_collect_stream_body = __esm({
  "node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js"() {
    init_dist_es10();
  }
});

// node_modules/@smithy/smithy-client/dist-es/command.js
var init_command2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/command.js"() {
    init_dist_es3();
    init_dist_es();
  }
});

// node_modules/@smithy/smithy-client/dist-es/constants.js
var init_constants = __esm({
  "node_modules/@smithy/smithy-client/dist-es/constants.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var init_create_aggregated_client = __esm({
  "node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var MAX_FLOAT;
var init_parse_utils = __esm({
  "node_modules/@smithy/smithy-client/dist-es/parse-utils.js"() {
    MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  }
});

// node_modules/@smithy/smithy-client/dist-es/date-utils.js
var RFC3339, RFC3339_WITH_OFFSET, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, FIFTY_YEARS_IN_MILLIS;
var init_date_utils = __esm({
  "node_modules/@smithy/smithy-client/dist-es/date-utils.js"() {
    init_parse_utils();
    RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
    FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
  }
});

// node_modules/@smithy/smithy-client/dist-es/exceptions.js
var init_exceptions = __esm({
  "node_modules/@smithy/smithy-client/dist-es/exceptions.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var init_default_error_handler = __esm({
  "node_modules/@smithy/smithy-client/dist-es/default-error-handler.js"() {
    init_exceptions();
  }
});

// node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var init_defaults_mode = __esm({
  "node_modules/@smithy/smithy-client/dist-es/defaults-mode.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var init_emitWarningIfUnsupportedVersion = __esm({
  "node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
var init_checksum3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js"() {
    init_dist_es();
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
var init_retry2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/retry.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var init_defaultExtensionConfiguration2 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js"() {
    init_checksum3();
    init_retry2();
  }
});

// node_modules/@smithy/smithy-client/dist-es/extensions/index.js
var init_extensions3 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extensions/index.js"() {
    init_defaultExtensionConfiguration2();
  }
});

// node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
var init_extended_encode_uri_component = __esm({
  "node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
var init_get_array_if_single_item = __esm({
  "node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
var init_get_value_from_text_node = __esm({
  "node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var StringWrapper;
var init_lazy_json = __esm({
  "node_modules/@smithy/smithy-client/dist-es/lazy-json.js"() {
    StringWrapper = function() {
      const Class = Object.getPrototypeOf(this).constructor;
      const Constructor = Function.bind.apply(String, [null, ...arguments]);
      const instance = new Constructor();
      Object.setPrototypeOf(instance, Class.prototype);
      return instance;
    };
    StringWrapper.prototype = Object.create(String.prototype, {
      constructor: {
        value: StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    Object.setPrototypeOf(StringWrapper, String);
  }
});

// node_modules/@smithy/smithy-client/dist-es/object-mapping.js
var init_object_mapping = __esm({
  "node_modules/@smithy/smithy-client/dist-es/object-mapping.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/resolve-path.js
var init_resolve_path = __esm({
  "node_modules/@smithy/smithy-client/dist-es/resolve-path.js"() {
    init_extended_encode_uri_component();
  }
});

// node_modules/@smithy/smithy-client/dist-es/ser-utils.js
var init_ser_utils = __esm({
  "node_modules/@smithy/smithy-client/dist-es/ser-utils.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/serde-json.js
var init_serde_json = __esm({
  "node_modules/@smithy/smithy-client/dist-es/serde-json.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/split-every.js
var init_split_every = __esm({
  "node_modules/@smithy/smithy-client/dist-es/split-every.js"() {
  }
});

// node_modules/@smithy/smithy-client/dist-es/index.js
var init_dist_es11 = __esm({
  "node_modules/@smithy/smithy-client/dist-es/index.js"() {
    init_NoOpLogger();
    init_client2();
    init_collect_stream_body();
    init_command2();
    init_constants();
    init_create_aggregated_client();
    init_date_utils();
    init_default_error_handler();
    init_defaults_mode();
    init_emitWarningIfUnsupportedVersion();
    init_extensions3();
    init_exceptions();
    init_extended_encode_uri_component();
    init_get_array_if_single_item();
    init_get_value_from_text_node();
    init_lazy_json();
    init_object_mapping();
    init_parse_utils();
    init_resolve_path();
    init_ser_utils();
    init_serde_json();
    init_split_every();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
var init_check_content_length_header = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js"() {
    init_dist_es2();
    init_dist_es11();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
var init_region_redirect_endpoint_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js"() {
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
var init_region_redirect_middleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js"() {
    init_region_redirect_endpoint_middleware();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
var S3ExpressIdentityCache;
var init_S3ExpressIdentityCache = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js"() {
    S3ExpressIdentityCache = class _S3ExpressIdentityCache {
      constructor(data = {}) {
        this.data = data;
        this.lastPurgeTime = Date.now();
      }
      get(key) {
        const entry = this.data[key];
        if (!entry) {
          return;
        }
        return entry;
      }
      set(key, entry) {
        this.data[key] = entry;
        return entry;
      }
      delete(key) {
        delete this.data[key];
      }
      async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + _S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
          return;
        }
        for (const key in this.data) {
          const entry = this.data[key];
          if (!entry.isRefreshing) {
            const credential = await entry.identity;
            if (credential.expiration) {
              if (credential.expiration.getTime() < now) {
                delete this.data[key];
              }
            }
          }
        }
      }
    };
    S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
var S3ExpressIdentityCacheEntry;
var init_S3ExpressIdentityCacheEntry = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js"() {
    S3ExpressIdentityCacheEntry = class {
      constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
      }
      get identity() {
        this.accessed = Date.now();
        return this._identity;
      }
    };
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
var S3ExpressIdentityProviderImpl;
var init_S3ExpressIdentityProviderImpl = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js"() {
    init_S3ExpressIdentityCache();
    init_S3ExpressIdentityCacheEntry();
    S3ExpressIdentityProviderImpl = class _S3ExpressIdentityProviderImpl {
      constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache;
      }
      async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache } = this;
        const entry = cache.get(key);
        if (entry) {
          return entry.identity.then((identity) => {
            var _a2, _b;
            const isExpired = (((_a2 = identity.expiration) == null ? void 0 : _a2.getTime()) ?? 0) < Date.now();
            if (isExpired) {
              return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
            }
            const isExpiringSoon = (((_b = identity.expiration) == null ? void 0 : _b.getTime()) ?? 0) < Date.now() + _S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
            if (isExpiringSoon && !entry.isRefreshing) {
              entry.isRefreshing = true;
              this.getIdentity(key).then((id2) => {
                cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id2)));
              });
            }
            return identity;
          });
        }
        return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
      }
      async getIdentity(key) {
        var _a2, _b;
        await this.cache.purgeExpired().catch((error) => {
          console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
        });
        const session = await this.createSessionFn(key);
        if (!((_a2 = session.Credentials) == null ? void 0 : _a2.AccessKeyId) || !((_b = session.Credentials) == null ? void 0 : _b.SecretAccessKey)) {
          throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity = {
          accessKeyId: session.Credentials.AccessKeyId,
          secretAccessKey: session.Credentials.SecretAccessKey,
          sessionToken: session.Credentials.SessionToken,
          expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
        };
        return identity;
      }
    };
    S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;
  }
});

// node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b2) {
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
          return t;
        if (y = 0, t)
          op2 = [op2[0] & 2, t.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t = op2;
            break;
          case 4:
            _2.label++;
            return { value: op2[1], done: false };
          case 5:
            _2.label++;
            y = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
              _2.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op2;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op2);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _2);
      } catch (e) {
        op2 = [6, e];
        y = 0;
      } finally {
        f2 = t = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
function __createBinding(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p in m2)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m2[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i = 0; i < arguments.length; i++)
    ar2 = ar2.concat(__read(arguments[i]));
  return ar2;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a = arguments[i], j2 = 0, jl2 = a.length; j2 < jl2; j2++, k2++)
      r[k2] = a[j2];
  return r;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n, v2, a, b2]) > 1 || resume(n, v2);
        });
      };
  }
  function resume(n, v2) {
    try {
      step(g[n](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f2) {
    i[n] = o[n] ? function(v2) {
      return (p = !p) ? { value: __await(o[n](v2)), done: n === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (Object.hasOwnProperty.call(mod, k2))
        result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (b3.hasOwnProperty(p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js
var fromUtf82, toUtf82;
var init_pureJs = __esm({
  "node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js"() {
    fromUtf82 = (input) => {
      const bytes = [];
      for (let i = 0, len = input.length; i < len; i++) {
        const value = input.charCodeAt(i);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    toUtf82 = (input) => {
      let decoded = "";
      for (let i = 0, len = input.length; i < len; i++) {
        const byte = input[i];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i], input[++i], input[++i]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);
        }
      }
      return decoded;
    };
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js
function fromUtf83(input) {
  return new TextEncoder().encode(input);
}
function toUtf83(input) {
  return new TextDecoder("utf-8").decode(input);
}
var init_whatwgEncodingApi = __esm({
  "node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js"() {
  }
});

// node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  fromUtf8: () => fromUtf84,
  toUtf8: () => toUtf84
});
var fromUtf84, toUtf84;
var init_dist_es12 = __esm({
  "node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js"() {
    init_pureJs();
    init_whatwgEncodingApi();
    fromUtf84 = (input) => typeof TextEncoder === "function" ? fromUtf83(input) : fromUtf82(input);
    toUtf84 = (input) => typeof TextDecoder === "function" ? toUtf83(input) : toUtf82(input);
  }
});

// node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = (init_dist_es12(), __toCommonJS(dist_es_exports));
    var fromUtf85 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf85(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer;
  }
});

// node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData;
  }
});

// node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint8;
  }
});

// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS({
  "node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    var index_1 = require_build2();
    var AwsCrc32 = (
      /** @class */
      function() {
        function AwsCrc322() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc322.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc322.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc322.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc322;
      }()
    );
    exports.AwsCrc32 = AwsCrc32;
  }
});

// node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS({
  "node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    exports.crc32 = crc32;
    var Crc323 = (
      /** @class */
      function() {
        function Crc324() {
          this.checksum = 4294967295;
        }
        Crc324.prototype.update = function(data) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
                _a2.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc324.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc324;
      }()
    );
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/Int64.js
var init_Int64 = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/Int64.js"() {
    init_dist_es9();
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HEADER_VALUE_TYPE;
var init_HeaderMarshaller = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js"() {
    init_dist_es9();
    init_Int64();
    (function(HEADER_VALUE_TYPE2) {
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var import_crc32, PRELUDE_MEMBER_LENGTH, PRELUDE_LENGTH, CHECKSUM_LENGTH, MINIMUM_MESSAGE_LENGTH;
var init_splitMessage = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js"() {
    import_crc32 = __toESM(require_build2());
    PRELUDE_MEMBER_LENGTH = 4;
    PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    CHECKSUM_LENGTH = 4;
    MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc322;
var init_EventStreamCodec = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js"() {
    import_crc322 = __toESM(require_build2());
    init_HeaderMarshaller();
    init_splitMessage();
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/Message.js
var init_Message = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/Message.js"() {
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream;
var init_MessageDecoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js"() {
    MessageDecoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream;
var init_MessageEncoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js"() {
    MessageEncoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream;
var init_SmithyMessageDecoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js"() {
    SmithyMessageDecoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream;
var init_SmithyMessageEncoderStream = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js"() {
    SmithyMessageEncoderStream = class {
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk);
          yield payloadBuf;
        }
      }
    };
  }
});

// node_modules/@smithy/eventstream-codec/dist-es/index.js
var init_dist_es13 = __esm({
  "node_modules/@smithy/eventstream-codec/dist-es/index.js"() {
    init_EventStreamCodec();
    init_HeaderMarshaller();
    init_Int64();
    init_Message();
    init_MessageDecoderStream();
    init_MessageEncoderStream();
    init_SmithyMessageDecoderStream();
    init_SmithyMessageEncoderStream();
  }
});

// node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
var init_getSmithyContext = __esm({
  "node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js"() {
    init_dist_es();
  }
});

// node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js"() {
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es14 = __esm({
  "node_modules/@smithy/util-middleware/dist-es/index.js"() {
    init_getSmithyContext();
    init_normalizeProvider();
  }
});

// node_modules/@smithy/signature-v4/dist-es/constants.js
var AMZ_DATE_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER, GENERATED_HEADERS, SIGNATURE_HEADER, SHA256_HEADER, TOKEN_HEADER, UNSIGNED_PAYLOAD, MAX_PRESIGNED_TTL;
var init_constants2 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/constants.js"() {
    AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    AUTH_HEADER = "authorization";
    AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    DATE_HEADER = "date";
    GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    SHA256_HEADER = "x-amz-content-sha256";
    TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  }
});

// node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var init_credentialDerivation = __esm({
  "node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js"() {
    init_dist_es9();
    init_dist_es5();
    init_constants2();
  }
});

// node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var init_getCanonicalHeaders = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js"() {
    init_constants2();
  }
});

// node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery;
var init_getCanonicalQuery = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js"() {
    init_dist_es6();
    init_constants2();
    getCanonicalQuery = ({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
          serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[key] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).sort().join("&");
        }
      }
      return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    };
  }
});

// node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer;
var init_dist_es15 = __esm({
  "node_modules/@smithy/is-array-buffer/dist-es/index.js"() {
    isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  }
});

// node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash;
var init_getPayloadHash = __esm({
  "node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js"() {
    init_dist_es15();
    init_dist_es9();
    init_dist_es5();
    init_constants2();
    getPayloadHash = async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var init_headerUtil = __esm({
  "node_modules/@smithy/signature-v4/dist-es/headerUtil.js"() {
  }
});

// node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
var cloneRequest, cloneQuery;
var init_cloneRequest = __esm({
  "node_modules/@smithy/signature-v4/dist-es/cloneRequest.js"() {
    cloneRequest = ({ headers, query, ...rest }) => ({
      ...rest,
      headers: { ...headers },
      query: query ? cloneQuery(query) : void 0
    });
    cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
});

// node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery;
var init_moveHeadersToQuery = __esm({
  "node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js"() {
    init_cloneRequest();
    moveHeadersToQuery = (request, options = {}) => {
      var _a2;
      const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
      for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !((_a2 = options.unhoistableHeaders) == null ? void 0 : _a2.has(lname))) {
          query[name] = headers[name];
          delete headers[name];
        }
      }
      return {
        ...request,
        headers,
        query
      };
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
var prepareRequest;
var init_prepareRequest = __esm({
  "node_modules/@smithy/signature-v4/dist-es/prepareRequest.js"() {
    init_cloneRequest();
    init_constants2();
    prepareRequest = (request) => {
      request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
      for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request.headers[headerName];
        }
      }
      return request;
    };
  }
});

// node_modules/@smithy/signature-v4/dist-es/utilDate.js
var init_utilDate = __esm({
  "node_modules/@smithy/signature-v4/dist-es/utilDate.js"() {
  }
});

// node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var init_SignatureV4 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/SignatureV4.js"() {
    init_dist_es13();
    init_dist_es9();
    init_dist_es14();
    init_dist_es5();
    init_constants2();
    init_credentialDerivation();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_headerUtil();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_utilDate();
  }
});

// node_modules/@smithy/signature-v4/dist-es/index.js
var init_dist_es16 = __esm({
  "node_modules/@smithy/signature-v4/dist-es/index.js"() {
    init_SignatureV4();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_credentialDerivation();
  }
});

// node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var init_booleanSelector = __esm({
  "node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js"() {
  }
});

// node_modules/@smithy/util-config-provider/dist-es/numberSelector.js
var init_numberSelector = __esm({
  "node_modules/@smithy/util-config-provider/dist-es/numberSelector.js"() {
  }
});

// node_modules/@smithy/util-config-provider/dist-es/types.js
var SelectorType;
var init_types2 = __esm({
  "node_modules/@smithy/util-config-provider/dist-es/types.js"() {
    (function(SelectorType2) {
      SelectorType2["ENV"] = "env";
      SelectorType2["CONFIG"] = "shared config entry";
    })(SelectorType || (SelectorType = {}));
  }
});

// node_modules/@smithy/util-config-provider/dist-es/index.js
var init_dist_es17 = __esm({
  "node_modules/@smithy/util-config-provider/dist-es/index.js"() {
    init_booleanSelector();
    init_numberSelector();
    init_types2();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var SESSION_TOKEN_QUERY_PARAM, SESSION_TOKEN_HEADER;
var init_constants3 = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js"() {
    init_dist_es17();
    SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
    SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
var init_SignatureV4S3Express = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js"() {
    init_dist_es16();
    init_constants3();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
var init_s3ExpressMiddleware = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js"() {
    init_dist_es2();
    init_constants3();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
var init_s3_express = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js"() {
    init_S3ExpressIdentityCache();
    init_S3ExpressIdentityCacheEntry();
    init_S3ExpressIdentityProviderImpl();
    init_SignatureV4S3Express();
    init_constants3();
    init_s3ExpressMiddleware();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
var init_s3Configuration = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js"() {
    init_s3_express();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
var init_throw_200_exceptions = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js"() {
    init_dist_es2();
  }
});

// node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var init_dist_es18 = __esm({
  "node_modules/@aws-sdk/util-arn-parser/dist-es/index.js"() {
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
var init_validate_bucket_name = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js"() {
    init_dist_es18();
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
var init_dist_es19 = __esm({
  "node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js"() {
    init_check_content_length_header();
    init_region_redirect_endpoint_middleware();
    init_region_redirect_middleware();
    init_s3_express();
    init_s3Configuration();
    init_throw_200_exceptions();
    init_validate_bucket_name();
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
var signatureV4CrtContainer;
var init_signature_v4_crt_container = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js"() {
    signatureV4CrtContainer = {
      CrtSignerV4: null
    };
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var init_SignatureV4MultiRegion = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js"() {
    init_dist_es19();
    init_signature_v4_crt_container();
  }
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js
var init_dist_es20 = __esm({
  "node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js"() {
    init_SignatureV4MultiRegion();
    init_signature_v4_crt_container();
  }
});

// node_modules/@smithy/property-provider/dist-es/ProviderError.js
var init_ProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/ProviderError.js"() {
  }
});

// node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var init_CredentialsProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js"() {
    init_ProviderError();
  }
});

// node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var init_TokenProviderError = __esm({
  "node_modules/@smithy/property-provider/dist-es/TokenProviderError.js"() {
    init_ProviderError();
  }
});

// node_modules/@smithy/property-provider/dist-es/chain.js
var init_chain = __esm({
  "node_modules/@smithy/property-provider/dist-es/chain.js"() {
    init_ProviderError();
  }
});

// node_modules/@smithy/property-provider/dist-es/fromStatic.js
var init_fromStatic = __esm({
  "node_modules/@smithy/property-provider/dist-es/fromStatic.js"() {
  }
});

// node_modules/@smithy/property-provider/dist-es/memoize.js
var init_memoize = __esm({
  "node_modules/@smithy/property-provider/dist-es/memoize.js"() {
  }
});

// node_modules/@smithy/property-provider/dist-es/index.js
var init_dist_es21 = __esm({
  "node_modules/@smithy/property-provider/dist-es/index.js"() {
    init_CredentialsProviderError();
    init_ProviderError();
    init_TokenProviderError();
    init_chain();
    init_fromStatic();
    init_memoize();
  }
});

// node_modules/@smithy/node-config-provider/dist-es/fromEnv.js
var init_fromEnv = __esm({
  "node_modules/@smithy/node-config-provider/dist-es/fromEnv.js"() {
    init_dist_es21();
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js
var import_os, import_path;
var init_getHomeDir = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js"() {
    import_os = __toESM(require_os());
    import_path = __toESM(require_path());
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
var init_getProfileName = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js"() {
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
var import_crypto, import_path2;
var init_getSSOTokenFilepath = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js"() {
    import_crypto = __toESM(require_crypto());
    import_path2 = __toESM(require_path());
    init_getHomeDir();
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
var import_fs, readFile;
var init_getSSOTokenFromFile = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js"() {
    import_fs = __toESM(require_fs());
    init_getSSOTokenFilepath();
    ({ readFile } = import_fs.promises);
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js
var init_getConfigData = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigData.js"() {
    init_dist_es();
    init_loadSharedConfigFiles();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js
var import_path3;
var init_getConfigFilepath = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js"() {
    import_path3 = __toESM(require_path());
    init_getHomeDir();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
var import_path4;
var init_getCredentialsFilepath = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js"() {
    import_path4 = __toESM(require_path());
    init_getHomeDir();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js
var init_parseIni = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js"() {
    init_dist_es();
    init_loadSharedConfigFiles();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js
var import_fs2, readFile2;
var init_slurpFile = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js"() {
    import_fs2 = __toESM(require_fs());
    ({ readFile: readFile2 } = import_fs2.promises);
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
var init_loadSharedConfigFiles = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js"() {
    init_getConfigData();
    init_getConfigFilepath();
    init_getCredentialsFilepath();
    init_parseIni();
    init_slurpFile();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js
var init_getSsoSessionData = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js"() {
    init_dist_es();
    init_loadSharedConfigFiles();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var init_loadSsoSessionData = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js"() {
    init_getConfigFilepath();
    init_getSsoSessionData();
    init_parseIni();
    init_slurpFile();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
var init_mergeConfigFiles = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js"() {
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js
var init_parseKnownFiles = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js"() {
    init_loadSharedConfigFiles();
    init_mergeConfigFiles();
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/types.js
var init_types3 = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/types.js"() {
  }
});

// node_modules/@smithy/shared-ini-file-loader/dist-es/index.js
var init_dist_es22 = __esm({
  "node_modules/@smithy/shared-ini-file-loader/dist-es/index.js"() {
    init_getHomeDir();
    init_getProfileName();
    init_getSSOTokenFilepath();
    init_getSSOTokenFromFile();
    init_loadSharedConfigFiles();
    init_loadSsoSessionData();
    init_parseKnownFiles();
    init_types3();
  }
});

// node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js
var init_fromSharedConfigFiles = __esm({
  "node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js"() {
    init_dist_es21();
    init_dist_es22();
  }
});

// node_modules/@smithy/node-config-provider/dist-es/fromStatic.js
var init_fromStatic2 = __esm({
  "node_modules/@smithy/node-config-provider/dist-es/fromStatic.js"() {
    init_dist_es21();
  }
});

// node_modules/@smithy/node-config-provider/dist-es/configLoader.js
var init_configLoader = __esm({
  "node_modules/@smithy/node-config-provider/dist-es/configLoader.js"() {
    init_dist_es21();
    init_fromEnv();
    init_fromSharedConfigFiles();
    init_fromStatic2();
  }
});

// node_modules/@smithy/node-config-provider/dist-es/index.js
var init_dist_es23 = __esm({
  "node_modules/@smithy/node-config-provider/dist-es/index.js"() {
    init_configLoader();
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/@aws-sdk/util-user-agent-node/dist-es/crt-availability.js
var crtAvailability;
var init_crt_availability = __esm({
  "node_modules/@aws-sdk/util-user-agent-node/dist-es/crt-availability.js"() {
    crtAvailability = {
      isCrtAvailable: false
    };
  }
});

// node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var init_is_crt_available = __esm({
  "node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js"() {
    init_crt_availability();
  }
});

// node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var import_os2, import_process;
var init_dist_es24 = __esm({
  "node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js"() {
    init_dist_es23();
    import_os2 = __toESM(require_os());
    import_process = __toESM(require_browser());
    init_is_crt_available();
    init_crt_availability();
  }
});

// node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
var init_dist_es25 = __esm({
  "node_modules/@smithy/querystring-parser/dist-es/index.js"() {
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m2 = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m2 ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e)) < 1) {
          e--;
          c2 *= 2;
        }
        if (e + eBias >= 1) {
          value += rt2 / c2;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e++;
          c2 /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
      }
      e = e << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b2) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b2)
        return 0;
      let x2 = a.length;
      let y = b2.length;
      for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
        if (a[i] !== b2[i]) {
          x2 = a[i];
          y = b2[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m2) {
      const i = b2[n];
      b2[n] = b2[m2];
      b2[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x2 = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x2, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val2, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val2 === "string") {
        val2 = Buffer2.from(val2, encoding);
      }
      if (Buffer2.isBuffer(val2)) {
        if (val2.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val2, byteOffset, encoding, dir);
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val2, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val2, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val2], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val2.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val2.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val2, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val2 = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val2 = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength2] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val2 = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength2);
      return val2;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val2 = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val2 += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength2);
      return val2;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val2 = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val2) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val2 = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val2) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 6] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 5] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 4] = lo2;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset] = hi2;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val2.length === 1) {
          const code = val2.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val2 = code;
          }
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      } else if (typeof val2 === "boolean") {
        val2 = Number(val2);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      let i;
      if (typeof val2 === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val2;
        }
      } else {
        const bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E2(sym, getMessage, Base2) {
      errors[sym] = class NodeError extends Base2 {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val2) {
      let res = "";
      let i = val2.length;
      const start = val2[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val2.slice(i - 3, i)}${res}`;
      }
      return `${val2.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi2, lo2;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i);
        hi2 = c2 >> 8;
        lo2 = c2 % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/aws-crt/dist.browser/browser/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/polyfills.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = __importDefault2(require_buffer());
    var process_1 = __importDefault2(require_browser());
    if (window) {
      window.Buffer = buffer_1.default.Buffer;
      window.process = process_1.default;
      window.global = window;
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/aws-crt/dist.browser/common/promise.js
var require_promise = __commonJS({
  "node_modules/aws-crt/dist.browser/common/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newLiftedPromise = exports.makeSelfCleaningPromise = void 0;
    function makeSelfCleaningPromise(promise, cleaner) {
      if (!cleaner) {
        return promise;
      }
      return promise.finally(function() {
        cleaner();
      });
    }
    exports.makeSelfCleaningPromise = makeSelfCleaningPromise;
    function newLiftedPromise(promiseBody) {
      var localResolve = void 0;
      var localReject = void 0;
      var promise = new Promise(function(resolve, reject) {
        localResolve = resolve;
        localReject = reject;
      });
      if (!localResolve || !localReject) {
        throw new Error("Failed to bind resolve and reject when making lifted promise");
      }
      if (promiseBody) {
        promiseBody(localResolve, localReject);
      }
      return {
        promise,
        resolve: localResolve,
        reject: localReject
      };
    }
    exports.newLiftedPromise = newLiftedPromise;
  }
});

// node_modules/aws-crt/dist.browser/common/cancel.js
var require_cancel = __commonJS({
  "node_modules/aws-crt/dist.browser/common/cancel.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newCancellablePromiseFromNextEvent = exports.CancelController = exports.EVENT_NAME = void 0;
    var events_1 = require_events();
    var promise = __importStar2(require_promise());
    exports.EVENT_NAME = "cancelled";
    var CancelController = (
      /** @class */
      function() {
        function CancelController2(options) {
          this.cancelled = false;
          if (options && options.emitterFactory) {
            this.emitter = options.emitterFactory();
          } else {
            this.emitter = new events_1.EventEmitter();
          }
        }
        CancelController2.prototype.cancel = function() {
          if (!this.cancelled) {
            this.cancelled = true;
            this.emitter.emit(exports.EVENT_NAME);
            this.emitter.removeAllListeners(exports.EVENT_NAME);
          }
        };
        CancelController2.prototype.hasBeenCancelled = function() {
          return this.cancelled;
        };
        CancelController2.prototype.addListener = function(listener) {
          var _this = this;
          if (this.cancelled) {
            listener();
            return void 0;
          }
          this.emitter.on(exports.EVENT_NAME, listener);
          return function() {
            _this.emitter.removeListener(exports.EVENT_NAME, listener);
          };
        };
        return CancelController2;
      }()
    );
    exports.CancelController = CancelController;
    function newCancellablePromiseFromNextEvent(config) {
      var onEvent = void 0;
      var cancelRemoveListener = void 0;
      var liftedPromise = promise.newLiftedPromise();
      onEvent = function(eventData) {
        try {
          if (config.eventDataTransformer) {
            liftedPromise.resolve(config.eventDataTransformer(eventData));
          } else {
            liftedPromise.resolve(eventData);
          }
        } catch (err) {
          liftedPromise.reject(err);
        }
      };
      config.emitter.addListener(config.eventName, onEvent);
      if (config.cancelController) {
        cancelRemoveListener = config.cancelController.addListener(function() {
          liftedPromise.reject(config.cancelMessage);
        });
      }
      return promise.makeSelfCleaningPromise(liftedPromise.promise, function() {
        if (onEvent) {
          config.emitter.removeListener(config.eventName, onEvent);
        }
        if (cancelRemoveListener) {
          cancelRemoveListener();
        }
      });
    }
    exports.newCancellablePromiseFromNextEvent = newCancellablePromiseFromNextEvent;
  }
});

// node_modules/aws-crt/package.json
var require_package = __commonJS({
  "node_modules/aws-crt/package.json"(exports, module) {
    module.exports = {
      name: "aws-crt",
      version: "1.20.1",
      description: "NodeJS/browser bindings to the aws-c-* libraries",
      homepage: "https://github.com/awslabs/aws-crt-nodejs",
      repository: {
        type: "git",
        url: "git+https://github.com/awslabs/aws-crt-nodejs.git"
      },
      contributors: [
        "AWS Common Runtime Team <aws-sdk-common-runtime@amazon.com>"
      ],
      license: "Apache-2.0",
      main: "./dist/index.js",
      browser: "./dist.browser/browser.js",
      types: "./dist/index.d.ts",
      scripts: {
        tsc: "node ./scripts/tsc.js",
        test: "npm run test:native",
        "test:node": "npm run test:native",
        "test:native": "npx jest --runInBand --verbose --config test/native/jest.config.js --forceExit",
        "test:browser": "npx jest --runInBand --verbose --config test/browser/jest.config.js --forceExit",
        "test:browser:ci": "npm run install:puppeteer && npm run test:browser",
        "install:puppeteer": "npm install --save-dev jest-puppeteer puppeteer @types/puppeteer",
        prepare: "node ./scripts/tsc.js && node ./scripts/install.js",
        install: "node ./scripts/install.js"
      },
      devDependencies: {
        "@types/crypto-js": "^3.1.43",
        "@types/jest": "^27.0.1",
        "@types/node": "^10.17.54",
        "@types/prettier": "2.6.0",
        "@types/puppeteer": "^5.4.7",
        "@types/uuid": "^3.4.8",
        "@types/ws": "^7.4.7",
        "aws-sdk": "^2.848.0",
        "https-proxy-agent": "^5.0.1",
        jest: "^27.2.1",
        "jest-puppeteer": "^5.0.4",
        "jest-runtime": "^27.2.1",
        puppeteer: "^3.3.0",
        "ts-jest": "^27.0.5",
        typedoc: "^0.22.18",
        "typedoc-plugin-merge-modules": "^3.1.0",
        typescript: "^4.7.4",
        uuid: "^8.3.2",
        yargs: "^17.2.1",
        "cmake-js": "^7.2.1",
        tar: "^6.1.11"
      },
      dependencies: {
        "@aws-sdk/util-utf8-browser": "^3.109.0",
        "@httptoolkit/websocket-stream": "^6.0.1",
        axios: "^1.6.0",
        buffer: "^6.0.3",
        "crypto-js": "^4.2.0",
        mqtt: "^4.3.7",
        process: "^0.11.10"
      }
    };
  }
});

// node_modules/aws-crt/dist.browser/common/platform.js
var require_platform = __commonJS({
  "node_modules/aws-crt/dist.browser/common/platform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crt_version = exports.package_info = exports.is_browser = exports.is_nodejs = void 0;
    function is_nodejs() {
      return typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node !== "undefined";
    }
    exports.is_nodejs = is_nodejs;
    function is_browser() {
      return !is_nodejs();
    }
    exports.is_browser = is_browser;
    function package_info() {
      try {
        var pkg = require_package();
        return pkg;
      } catch (err) {
        return {
          name: "aws-crt-nodejs",
          version: "UNKNOWN"
        };
      }
    }
    exports.package_info = package_info;
    function crt_version() {
      var pkg = package_info();
      return pkg.version;
    }
    exports.crt_version = crt_version;
  }
});

// node_modules/aws-crt/dist.browser/common/resource_safety.js
var require_resource_safety = __commonJS({
  "node_modules/aws-crt/dist.browser/common/resource_safety.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator9 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op2) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
              return t;
            if (y = 0, t)
              op2 = [op2[0] & 2, t.value];
            switch (op2[0]) {
              case 0:
              case 1:
                t = op2;
                break;
              case 4:
                _2.label++;
                return { value: op2[1], done: false };
              case 5:
                _2.label++;
                y = op2[1];
                op2 = [0];
                continue;
              case 7:
                op2 = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                  _2.label = op2[1];
                  break;
                }
                if (op2[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op2;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op2);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op2 = body.call(thisArg, _2);
          } catch (e) {
            op2 = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op2[0] & 5)
          throw op2[1];
        return { value: op2[0] ? op2[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    function using(resource, func) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator9(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, , 2, 3]);
              return [4, func(resource)];
            case 1:
              _a2.sent();
              return [3, 3];
            case 2:
              resource.close();
              return [
                7
                /*endfinally*/
              ];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.using = using;
  }
});

// node_modules/aws-crt/dist.browser/common/io.js
var require_io = __commonJS({
  "node_modules/aws-crt/dist.browser/common/io.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;
    var TlsVersion;
    (function(TlsVersion2) {
      TlsVersion2[TlsVersion2["SSLv3"] = 0] = "SSLv3";
      TlsVersion2[TlsVersion2["TLSv1"] = 1] = "TLSv1";
      TlsVersion2[TlsVersion2["TLSv1_1"] = 2] = "TLSv1_1";
      TlsVersion2[TlsVersion2["TLSv1_2"] = 3] = "TLSv1_2";
      TlsVersion2[TlsVersion2["TLSv1_3"] = 4] = "TLSv1_3";
      TlsVersion2[TlsVersion2["Default"] = 128] = "Default";
    })(TlsVersion = exports.TlsVersion || (exports.TlsVersion = {}));
    var SocketType;
    (function(SocketType2) {
      SocketType2[SocketType2["STREAM"] = 0] = "STREAM";
      SocketType2[SocketType2["DGRAM"] = 1] = "DGRAM";
    })(SocketType = exports.SocketType || (exports.SocketType = {}));
    var SocketDomain;
    (function(SocketDomain2) {
      SocketDomain2[SocketDomain2["IPV4"] = 0] = "IPV4";
      SocketDomain2[SocketDomain2["IPV6"] = 1] = "IPV6";
      SocketDomain2[SocketDomain2["LOCAL"] = 2] = "LOCAL";
    })(SocketDomain = exports.SocketDomain || (exports.SocketDomain = {}));
  }
});

// node_modules/aws-crt/dist.browser/browser/io.js
var require_io2 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/io.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketOptions = exports.ClientTlsContext = exports.TlsContext = exports.TlsConnectionOptions = exports.ClientBootstrap = exports.InputStream = exports.is_alpn_available = exports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;
    var io_1 = require_io();
    Object.defineProperty(exports, "TlsVersion", { enumerable: true, get: function() {
      return io_1.TlsVersion;
    } });
    Object.defineProperty(exports, "SocketType", { enumerable: true, get: function() {
      return io_1.SocketType;
    } });
    Object.defineProperty(exports, "SocketDomain", { enumerable: true, get: function() {
      return io_1.SocketDomain;
    } });
    var io_2 = require_io();
    function is_alpn_available() {
      return false;
    }
    exports.is_alpn_available = is_alpn_available;
    var InputStream = (
      /** @class */
      function() {
        function InputStream2(data) {
          this.data = data;
        }
        return InputStream2;
      }()
    );
    exports.InputStream = InputStream;
    var ClientBootstrap = (
      /** @class */
      function() {
        function ClientBootstrap2() {
        }
        return ClientBootstrap2;
      }()
    );
    exports.ClientBootstrap = ClientBootstrap;
    var TlsConnectionOptions = (
      /** @class */
      function() {
        function TlsConnectionOptions2(tls_ctx, server_name, alpn_list) {
          if (alpn_list === void 0) {
            alpn_list = [];
          }
          this.tls_ctx = tls_ctx;
          this.server_name = server_name;
          this.alpn_list = alpn_list;
        }
        return TlsConnectionOptions2;
      }()
    );
    exports.TlsConnectionOptions = TlsConnectionOptions;
    var TlsContext = (
      /** @class */
      function() {
        function TlsContext2() {
        }
        return TlsContext2;
      }()
    );
    exports.TlsContext = TlsContext;
    var ClientTlsContext = (
      /** @class */
      function(_super) {
        __extends19(ClientTlsContext2, _super);
        function ClientTlsContext2(options) {
          return _super.call(this) || this;
        }
        return ClientTlsContext2;
      }(TlsContext)
    );
    exports.ClientTlsContext = ClientTlsContext;
    var SocketOptions = (
      /** @class */
      function() {
        function SocketOptions2(type, domain, connect_timeout_ms, keepalive, keep_alive_interval_sec, keep_alive_timeout_sec, keep_alive_max_failed_probes) {
          if (type === void 0) {
            type = io_2.SocketType.STREAM;
          }
          if (domain === void 0) {
            domain = io_2.SocketDomain.IPV6;
          }
          if (connect_timeout_ms === void 0) {
            connect_timeout_ms = 5e3;
          }
          if (keepalive === void 0) {
            keepalive = false;
          }
          if (keep_alive_interval_sec === void 0) {
            keep_alive_interval_sec = 0;
          }
          if (keep_alive_timeout_sec === void 0) {
            keep_alive_timeout_sec = 0;
          }
          if (keep_alive_max_failed_probes === void 0) {
            keep_alive_max_failed_probes = 0;
          }
          this.type = type;
          this.domain = domain;
          this.connect_timeout_ms = connect_timeout_ms;
          this.keepalive = keepalive;
          this.keep_alive_interval_sec = keep_alive_interval_sec;
          this.keep_alive_timeout_sec = keep_alive_timeout_sec;
          this.keep_alive_max_failed_probes = keep_alive_max_failed_probes;
        }
        return SocketOptions2;
      }()
    );
    exports.SocketOptions = SocketOptions;
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v2) {
          var entry = {
            data: v2,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v2) {
          var entry = {
            data: v2,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join4(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c2 = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c2;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c2 = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c2;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/mqtt/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base2);
      NodeError.prototype.name = Base2.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn2, msg) {
      if (config("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_2) {
        return false;
      }
      var val2 = global.localStorage[name];
      if (null == val2)
        return false;
      return String(val2).toLowerCase() === "true";
    }
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process.nextTick(cb, er2);
    }
    function validChunk(stream, state, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er2);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er2)
        onwriteError(stream, state, sync, er2, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v2 = 0; v2 < keys.length; v2++) {
        method = keys[v2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v2;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j2 = buf.length - 1;
      if (j2 < i)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c2 = r.charCodeAt(r.length - 1);
          if (c2 >= 55296 && c2 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs2, x2) {
      for (var i = 0, l2 = xs2.length; i < l2; i++) {
        if (xs2[i] === x2)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er2, data) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from, to2) {
      return from.pipe(to2);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/mqtt/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/mqtt/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/mqtt/lib/store.js
var require_store = __commonJS({
  "node_modules/mqtt/lib/store.js"(exports, module) {
    "use strict";
    var xtend = require_immutable();
    var Readable = require_readable_browser().Readable;
    var streamsOpts = { objectMode: true };
    var defaultStoreOptions = {
      clean: true
    };
    function Store(options) {
      if (!(this instanceof Store)) {
        return new Store(options);
      }
      this.options = options || {};
      this.options = xtend(defaultStoreOptions, options);
      this._inflights = /* @__PURE__ */ new Map();
    }
    Store.prototype.put = function(packet, cb) {
      this._inflights.set(packet.messageId, packet);
      if (cb) {
        cb();
      }
      return this;
    };
    Store.prototype.createStream = function() {
      const stream = new Readable(streamsOpts);
      const values = [];
      let destroyed = false;
      let i = 0;
      this._inflights.forEach(function(value, key) {
        values.push(value);
      });
      stream._read = function() {
        if (!destroyed && i < values.length) {
          this.push(values[i++]);
        } else {
          this.push(null);
        }
      };
      stream.destroy = function() {
        if (destroyed) {
          return;
        }
        const self2 = this;
        destroyed = true;
        setTimeout(function() {
          self2.emit("close");
        }, 0);
      };
      return stream;
    };
    Store.prototype.del = function(packet, cb) {
      packet = this._inflights.get(packet.messageId);
      if (packet) {
        this._inflights.delete(packet.messageId);
        cb(null, packet);
      } else if (cb) {
        cb(new Error("missing packet"));
      }
      return this;
    };
    Store.prototype.get = function(packet, cb) {
      packet = this._inflights.get(packet.messageId);
      if (packet) {
        cb(null, packet);
      } else if (cb) {
        cb(new Error("missing packet"));
      }
      return this;
    };
    Store.prototype.close = function(cb) {
      if (this.options.clean) {
        this._inflights = null;
      }
      if (cb) {
        cb();
      }
    };
    module.exports = Store;
  }
});

// node_modules/mqtt/lib/topic-alias-recv.js
var require_topic_alias_recv = __commonJS({
  "node_modules/mqtt/lib/topic-alias-recv.js"(exports, module) {
    "use strict";
    function TopicAliasRecv(max) {
      if (!(this instanceof TopicAliasRecv)) {
        return new TopicAliasRecv(max);
      }
      this.aliasToTopic = {};
      this.max = max;
    }
    TopicAliasRecv.prototype.put = function(topic, alias) {
      if (alias === 0 || alias > this.max) {
        return false;
      }
      this.aliasToTopic[alias] = topic;
      this.length = Object.keys(this.aliasToTopic).length;
      return true;
    };
    TopicAliasRecv.prototype.getTopicByAlias = function(alias) {
      return this.aliasToTopic[alias];
    };
    TopicAliasRecv.prototype.clear = function() {
      this.aliasToTopic = {};
    };
    module.exports = TopicAliasRecv;
  }
});

// node_modules/mqtt/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/mqtt/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/mqtt/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/mqtt/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l2 = arguments.length; i < l2; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l2 = arguments.length; i < l2; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l2 = arguments.length; i < l2; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn2.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn2.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn2, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn2(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn2, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn2(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to2 < from || to2 < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to2; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to2 < from || to2 < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to2; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er2) {
    }
  }
});

// node_modules/mqtt/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/mqtt/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc2 = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc2 !== "function" ? naiveLength : lc2;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn2, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn2, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k2) => k2.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k2) => k2.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l2 = arr.length - 1; l2 >= 0; l2--) {
          const hit = arr[l2];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn2, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn2.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js
var __extends2, ContainerIterator, Base, Container;
var init_ContainerBase = __esm({
  "node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js"() {
    __extends2 = function() {
      var extendStatics2 = function(n, t) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var r in t2)
            if (Object.prototype.hasOwnProperty.call(t2, r))
              n2[r] = t2[r];
        };
        return extendStatics2(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics2(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    ContainerIterator = function() {
      function ContainerIterator2(n) {
        if (n === void 0) {
          n = 0;
        }
        this.iteratorType = n;
      }
      ContainerIterator2.prototype.equals = function(n) {
        return this.o === n.o;
      };
      return ContainerIterator2;
    }();
    Base = function() {
      function Base2() {
        this.M = 0;
      }
      Object.defineProperty(Base2.prototype, "length", {
        get: function() {
          return this.M;
        },
        enumerable: false,
        configurable: true
      });
      Base2.prototype.size = function() {
        return this.M;
      };
      Base2.prototype.empty = function() {
        return this.M === 0;
      };
      return Base2;
    }();
    Container = function(n) {
      __extends2(Container2, n);
      function Container2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return Container2;
    }(Base);
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js
var __extends3, Stack, Stack_default;
var init_Stack = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js"() {
    init_ContainerBase();
    __extends3 = function() {
      var extendStatics2 = function(t, n) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, n2) {
          t2.__proto__ = n2;
        } || function(t2, n2) {
          for (var i in n2)
            if (Object.prototype.hasOwnProperty.call(n2, i))
              t2[i] = n2[i];
        };
        return extendStatics2(t, n);
      };
      return function(t, n) {
        if (typeof n !== "function" && n !== null)
          throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics2(t, n);
        function __() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    }();
    Stack = function(t) {
      __extends3(Stack2, t);
      function Stack2(n) {
        if (n === void 0) {
          n = [];
        }
        var i = t.call(this) || this;
        i.nt = [];
        var r = i;
        n.forEach(function(t2) {
          r.push(t2);
        });
        return i;
      }
      Stack2.prototype.clear = function() {
        this.M = 0;
        this.nt = [];
      };
      Stack2.prototype.push = function(t2) {
        this.nt.push(t2);
        this.M += 1;
        return this.M;
      };
      Stack2.prototype.pop = function() {
        if (this.M === 0)
          return;
        this.M -= 1;
        return this.nt.pop();
      };
      Stack2.prototype.top = function() {
        return this.nt[this.M - 1];
      };
      return Stack2;
    }(Base);
    Stack_default = Stack;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js
var __extends4, Queue, Queue_default;
var init_Queue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js"() {
    init_ContainerBase();
    __extends4 = function() {
      var extendStatics2 = function(t, i) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var n in i2)
            if (Object.prototype.hasOwnProperty.call(i2, n))
              t2[n] = i2[n];
        };
        return extendStatics2(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics2(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    Queue = function(t) {
      __extends4(Queue2, t);
      function Queue2(i) {
        if (i === void 0) {
          i = [];
        }
        var n = t.call(this) || this;
        n.A = 0;
        n.tt = [];
        var e = n;
        i.forEach(function(t2) {
          e.push(t2);
        });
        return n;
      }
      Queue2.prototype.clear = function() {
        this.tt = [];
        this.M = this.A = 0;
      };
      Queue2.prototype.push = function(t2) {
        var i = this.tt.length;
        if (this.A / i > 0.5 && this.A + this.M >= i && i > 4096) {
          var n = this.M;
          for (var e = 0; e < n; ++e) {
            this.tt[e] = this.tt[this.A + e];
          }
          this.A = 0;
          this.tt[this.M] = t2;
        } else
          this.tt[this.A + this.M] = t2;
        return ++this.M;
      };
      Queue2.prototype.pop = function() {
        if (this.M === 0)
          return;
        var t2 = this.tt[this.A++];
        this.M -= 1;
        return t2;
      };
      Queue2.prototype.front = function() {
        if (this.M === 0)
          return;
        return this.tt[this.A];
      };
      return Queue2;
    }(Base);
    Queue_default = Queue;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js
var __extends5, __read2, __spreadArray, PriorityQueue, PriorityQueue_default;
var init_PriorityQueue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js"() {
    init_ContainerBase();
    __extends5 = function() {
      var extendStatics2 = function(i, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(i2, r2) {
          i2.__proto__ = r2;
        } || function(i2, r2) {
          for (var t in r2)
            if (Object.prototype.hasOwnProperty.call(r2, t))
              i2[t] = r2[t];
        };
        return extendStatics2(i, r);
      };
      return function(i, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(i, r);
        function __() {
          this.constructor = i;
        }
        i.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __read2 = function(i, r) {
      var t = typeof Symbol === "function" && i[Symbol.iterator];
      if (!t)
        return i;
      var e = t.call(i), n, u = [], s;
      try {
        while ((r === void 0 || r-- > 0) && !(n = e.next()).done)
          u.push(n.value);
      } catch (i2) {
        s = {
          error: i2
        };
      } finally {
        try {
          if (n && !n.done && (t = e["return"]))
            t.call(e);
        } finally {
          if (s)
            throw s.error;
        }
      }
      return u;
    };
    __spreadArray = function(i, r, t) {
      if (t || arguments.length === 2)
        for (var e = 0, n = r.length, u; e < n; e++) {
          if (u || !(e in r)) {
            if (!u)
              u = Array.prototype.slice.call(r, 0, e);
            u[e] = r[e];
          }
        }
      return i.concat(u || Array.prototype.slice.call(r));
    };
    PriorityQueue = function(i) {
      __extends5(PriorityQueue2, i);
      function PriorityQueue2(r, t, e) {
        if (r === void 0) {
          r = [];
        }
        if (t === void 0) {
          t = function(i2, r2) {
            if (i2 > r2)
              return -1;
            if (i2 < r2)
              return 1;
            return 0;
          };
        }
        if (e === void 0) {
          e = true;
        }
        var n = i.call(this) || this;
        n.$ = t;
        if (Array.isArray(r)) {
          n.ii = e ? __spreadArray([], __read2(r), false) : r;
        } else {
          n.ii = [];
          var u = n;
          r.forEach(function(i2) {
            u.ii.push(i2);
          });
        }
        n.M = n.ii.length;
        var s = n.M >> 1;
        for (var o = n.M - 1 >> 1; o >= 0; --o) {
          n.ri(o, s);
        }
        return n;
      }
      PriorityQueue2.prototype.ti = function(i2) {
        var r = this.ii[i2];
        while (i2 > 0) {
          var t = i2 - 1 >> 1;
          var e = this.ii[t];
          if (this.$(e, r) <= 0)
            break;
          this.ii[i2] = e;
          i2 = t;
        }
        this.ii[i2] = r;
      };
      PriorityQueue2.prototype.ri = function(i2, r) {
        var t = this.ii[i2];
        while (i2 < r) {
          var e = i2 << 1 | 1;
          var n = e + 1;
          var u = this.ii[e];
          if (n < this.M && this.$(u, this.ii[n]) > 0) {
            e = n;
            u = this.ii[n];
          }
          if (this.$(u, t) >= 0)
            break;
          this.ii[i2] = u;
          i2 = e;
        }
        this.ii[i2] = t;
      };
      PriorityQueue2.prototype.clear = function() {
        this.M = 0;
        this.ii.length = 0;
      };
      PriorityQueue2.prototype.push = function(i2) {
        this.ii.push(i2);
        this.ti(this.M);
        this.M += 1;
      };
      PriorityQueue2.prototype.pop = function() {
        if (this.M === 0)
          return;
        var i2 = this.ii[0];
        var r = this.ii.pop();
        this.M -= 1;
        if (this.M) {
          this.ii[0] = r;
          this.ri(0, this.M >> 1);
        }
        return i2;
      };
      PriorityQueue2.prototype.top = function() {
        return this.ii[0];
      };
      PriorityQueue2.prototype.find = function(i2) {
        return this.ii.indexOf(i2) >= 0;
      };
      PriorityQueue2.prototype.remove = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0)
          return false;
        if (r === 0) {
          this.pop();
        } else if (r === this.M - 1) {
          this.ii.pop();
          this.M -= 1;
        } else {
          this.ii.splice(r, 1, this.ii.pop());
          this.M -= 1;
          this.ti(r);
          this.ri(r, this.M >> 1);
        }
        return true;
      };
      PriorityQueue2.prototype.updateItem = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0)
          return false;
        this.ti(r);
        this.ri(r, this.M >> 1);
        return true;
      };
      PriorityQueue2.prototype.toArray = function() {
        return __spreadArray([], __read2(this.ii), false);
      };
      return PriorityQueue2;
    }(Base);
    PriorityQueue_default = PriorityQueue;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js
var __extends6, SequentialContainer, Base_default;
var init_Base = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js"() {
    init_ContainerBase();
    __extends6 = function() {
      var extendStatics2 = function(n, t) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var e in t2)
            if (Object.prototype.hasOwnProperty.call(t2, e))
              n2[e] = t2[e];
        };
        return extendStatics2(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics2(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    SequentialContainer = function(n) {
      __extends6(SequentialContainer2, n);
      function SequentialContainer2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return SequentialContainer2;
    }(Container);
    Base_default = SequentialContainer;
  }
});

// node_modules/js-sdsl/dist/esm/utils/throwError.js
function throwIteratorAccessError() {
  throw new RangeError("Iterator access denied!");
}
var init_throwError = __esm({
  "node_modules/js-sdsl/dist/esm/utils/throwError.js"() {
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js
var __extends7, RandomIterator;
var init_RandomIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js"() {
    init_ContainerBase();
    init_throwError();
    __extends7 = function() {
      var extendStatics2 = function(t, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2)
            if (Object.prototype.hasOwnProperty.call(r2, n))
              t2[n] = r2[n];
        };
        return extendStatics2(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    RandomIterator = function(t) {
      __extends7(RandomIterator2, t);
      function RandomIterator2(r, n) {
        var o = t.call(this, n) || this;
        o.o = r;
        if (o.iteratorType === 0) {
          o.pre = function() {
            if (this.o === 0) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
          o.next = function() {
            if (this.o === this.container.size()) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
        } else {
          o.pre = function() {
            if (this.o === this.container.size() - 1) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
          o.next = function() {
            if (this.o === -1) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
        }
        return o;
      }
      Object.defineProperty(RandomIterator2.prototype, "pointer", {
        get: function() {
          return this.container.getElementByPos(this.o);
        },
        set: function(t2) {
          this.container.setElementByPos(this.o, t2);
        },
        enumerable: false,
        configurable: true
      });
      return RandomIterator2;
    }(ContainerIterator);
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js
var __extends8, __generator2, __read3, __spreadArray2, __values2, VectorIterator, Vector, Vector_default;
var init_Vector = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js"() {
    init_Base();
    init_RandomIterator();
    __extends8 = function() {
      var extendStatics2 = function(t, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2)
            if (Object.prototype.hasOwnProperty.call(r2, e))
              t2[e] = r2[e];
        };
        return extendStatics2(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator2 = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(u2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (e)
          try {
            if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done)
              return o;
            if (i = 0, o)
              u2 = [u2[0] & 2, o.value];
            switch (u2[0]) {
              case 0:
              case 1:
                o = u2;
                break;
              case 4:
                e.label++;
                return {
                  value: u2[1],
                  done: false
                };
              case 5:
                e.label++;
                i = u2[1];
                u2 = [0];
                continue;
              case 7:
                u2 = e.ops.pop();
                e.trys.pop();
                continue;
              default:
                if (!(o = e.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                  e = 0;
                  continue;
                }
                if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                  e.label = u2[1];
                  break;
                }
                if (u2[0] === 6 && e.label < o[1]) {
                  e.label = o[1];
                  o = u2;
                  break;
                }
                if (o && e.label < o[2]) {
                  e.label = o[2];
                  e.ops.push(u2);
                  break;
                }
                if (o[2])
                  e.ops.pop();
                e.trys.pop();
                continue;
            }
            u2 = r.call(t, e);
          } catch (t2) {
            u2 = [6, t2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (u2[0] & 5)
          throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __read3 = function(t, r) {
      var e = typeof Symbol === "function" && t[Symbol.iterator];
      if (!e)
        return t;
      var n = e.call(t), i, o = [], u;
      try {
        while ((r === void 0 || r-- > 0) && !(i = n.next()).done)
          o.push(i.value);
      } catch (t2) {
        u = {
          error: t2
        };
      } finally {
        try {
          if (i && !i.done && (e = n["return"]))
            e.call(n);
        } finally {
          if (u)
            throw u.error;
        }
      }
      return o;
    };
    __spreadArray2 = function(t, r, e) {
      if (e || arguments.length === 2)
        for (var n = 0, i = r.length, o; n < i; n++) {
          if (o || !(n in r)) {
            if (!o)
              o = Array.prototype.slice.call(r, 0, n);
            o[n] = r[n];
          }
        }
      return t.concat(o || Array.prototype.slice.call(r));
    };
    __values2 = function(t) {
      var r = typeof Symbol === "function" && Symbol.iterator, e = r && t[r], n = 0;
      if (e)
        return e.call(t);
      if (t && typeof t.length === "number")
        return {
          next: function() {
            if (t && n >= t.length)
              t = void 0;
            return {
              value: t && t[n++],
              done: !t
            };
          }
        };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    VectorIterator = function(t) {
      __extends8(VectorIterator2, t);
      function VectorIterator2(r, e, n) {
        var i = t.call(this, r, n) || this;
        i.container = e;
        return i;
      }
      VectorIterator2.prototype.copy = function() {
        return new VectorIterator2(this.o, this.container, this.iteratorType);
      };
      return VectorIterator2;
    }(RandomIterator);
    Vector = function(t) {
      __extends8(Vector2, t);
      function Vector2(r, e) {
        if (r === void 0) {
          r = [];
        }
        if (e === void 0) {
          e = true;
        }
        var n = t.call(this) || this;
        if (Array.isArray(r)) {
          n.J = e ? __spreadArray2([], __read3(r), false) : r;
          n.M = r.length;
        } else {
          n.J = [];
          var i = n;
          r.forEach(function(t2) {
            i.pushBack(t2);
          });
        }
        return n;
      }
      Vector2.prototype.clear = function() {
        this.M = 0;
        this.J.length = 0;
      };
      Vector2.prototype.begin = function() {
        return new VectorIterator(0, this);
      };
      Vector2.prototype.end = function() {
        return new VectorIterator(this.M, this);
      };
      Vector2.prototype.rBegin = function() {
        return new VectorIterator(this.M - 1, this, 1);
      };
      Vector2.prototype.rEnd = function() {
        return new VectorIterator(-1, this, 1);
      };
      Vector2.prototype.front = function() {
        return this.J[0];
      };
      Vector2.prototype.back = function() {
        return this.J[this.M - 1];
      };
      Vector2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        return this.J[t2];
      };
      Vector2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J.splice(t2, 1);
        this.M -= 1;
        return this.M;
      };
      Vector2.prototype.eraseElementByValue = function(t2) {
        var r = 0;
        for (var e = 0; e < this.M; ++e) {
          if (this.J[e] !== t2) {
            this.J[r++] = this.J[e];
          }
        }
        this.M = this.J.length = r;
        return this.M;
      };
      Vector2.prototype.eraseElementByIterator = function(t2) {
        var r = t2.o;
        t2 = t2.next();
        this.eraseElementByPos(r);
        return t2;
      };
      Vector2.prototype.pushBack = function(t2) {
        this.J.push(t2);
        this.M += 1;
        return this.M;
      };
      Vector2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        this.M -= 1;
        return this.J.pop();
      };
      Vector2.prototype.setElementByPos = function(t2, r) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J[t2] = r;
      };
      Vector2.prototype.insert = function(t2, r, e) {
        var n;
        if (e === void 0) {
          e = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        (n = this.J).splice.apply(n, __spreadArray2([t2, 0], __read3(new Array(e).fill(r)), false));
        this.M += e;
        return this.M;
      };
      Vector2.prototype.find = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          if (this.J[r] === t2) {
            return new VectorIterator(r, this);
          }
        }
        return this.end();
      };
      Vector2.prototype.reverse = function() {
        this.J.reverse();
      };
      Vector2.prototype.unique = function() {
        var t2 = 1;
        for (var r = 1; r < this.M; ++r) {
          if (this.J[r] !== this.J[r - 1]) {
            this.J[t2++] = this.J[r];
          }
        }
        this.M = this.J.length = t2;
        return this.M;
      };
      Vector2.prototype.sort = function(t2) {
        this.J.sort(t2);
      };
      Vector2.prototype.forEach = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          t2(this.J[r], r, this);
        }
      };
      Vector2.prototype[Symbol.iterator] = function() {
        return (function() {
          return __generator2(this, function(t2) {
            switch (t2.label) {
              case 0:
                return [5, __values2(this.J)];
              case 1:
                t2.sent();
                return [2];
            }
          });
        }).bind(this)();
      };
      return Vector2;
    }(Base_default);
    Vector_default = Vector;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js
var __extends9, __generator3, LinkListIterator, LinkList, LinkList_default;
var init_LinkList = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js"() {
    init_Base();
    init_ContainerBase();
    init_throwError();
    __extends9 = function() {
      var extendStatics2 = function(t, i) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics2(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics2(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    __generator3 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (e[0] & 1)
            throw e[1];
          return e[1];
        },
        trys: [],
        ops: []
      }, n, s, e, h;
      return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
      }), h;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(h2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (n = 1, s && (e = h2[0] & 2 ? s["return"] : h2[0] ? s["throw"] || ((e = s["return"]) && e.call(s), 0) : s.next) && !(e = e.call(s, h2[1])).done)
              return e;
            if (s = 0, e)
              h2 = [h2[0] & 2, e.value];
            switch (h2[0]) {
              case 0:
              case 1:
                e = h2;
                break;
              case 4:
                r.label++;
                return {
                  value: h2[1],
                  done: false
                };
              case 5:
                r.label++;
                s = h2[1];
                h2 = [0];
                continue;
              case 7:
                h2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(e = r.trys, e = e.length > 0 && e[e.length - 1]) && (h2[0] === 6 || h2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (h2[0] === 3 && (!e || h2[1] > e[0] && h2[1] < e[3])) {
                  r.label = h2[1];
                  break;
                }
                if (h2[0] === 6 && r.label < e[1]) {
                  r.label = e[1];
                  e = h2;
                  break;
                }
                if (e && r.label < e[2]) {
                  r.label = e[2];
                  r.ops.push(h2);
                  break;
                }
                if (e[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            h2 = i.call(t, r);
          } catch (t2) {
            h2 = [6, t2];
            s = 0;
          } finally {
            n = e = 0;
          }
        if (h2[0] & 5)
          throw h2[1];
        return {
          value: h2[0] ? h2[1] : void 0,
          done: true
        };
      }
    };
    LinkListIterator = function(t) {
      __extends9(LinkListIterator2, t);
      function LinkListIterator2(i, r, n, s) {
        var e = t.call(this, s) || this;
        e.o = i;
        e.h = r;
        e.container = n;
        if (e.iteratorType === 0) {
          e.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          e.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return e;
      }
      Object.defineProperty(LinkListIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.p;
        },
        set: function(t2) {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          this.o.p = t2;
        },
        enumerable: false,
        configurable: true
      });
      LinkListIterator2.prototype.copy = function() {
        return new LinkListIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return LinkListIterator2;
    }(ContainerIterator);
    LinkList = function(t) {
      __extends9(LinkList2, t);
      function LinkList2(i) {
        if (i === void 0) {
          i = [];
        }
        var r = t.call(this) || this;
        r.h = {};
        r.H = r.l = r.h.L = r.h.m = r.h;
        var n = r;
        i.forEach(function(t2) {
          n.pushBack(t2);
        });
        return r;
      }
      LinkList2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      LinkList2.prototype.F = function(t2, i) {
        var r = i.m;
        var n = {
          p: t2,
          L: i,
          m: r
        };
        i.m = n;
        r.L = n;
        if (i === this.h) {
          this.H = n;
        }
        if (r === this.h) {
          this.l = n;
        }
        this.M += 1;
      };
      LinkList2.prototype.clear = function() {
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      LinkList2.prototype.begin = function() {
        return new LinkListIterator(this.H, this.h, this);
      };
      LinkList2.prototype.end = function() {
        return new LinkListIterator(this.h, this.h, this);
      };
      LinkList2.prototype.rBegin = function() {
        return new LinkListIterator(this.l, this.h, this, 1);
      };
      LinkList2.prototype.rEnd = function() {
        return new LinkListIterator(this.h, this.h, this, 1);
      };
      LinkList2.prototype.front = function() {
        return this.H.p;
      };
      LinkList2.prototype.back = function() {
        return this.l.p;
      };
      LinkList2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        return i.p;
      };
      LinkList2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      LinkList2.prototype.eraseElementByValue = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            this.G(i);
          }
          i = i.m;
        }
        return this.M;
      };
      LinkList2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        t2 = t2.next();
        this.G(i);
        return t2;
      };
      LinkList2.prototype.pushBack = function(t2) {
        this.F(t2, this.l);
        return this.M;
      };
      LinkList2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        var t2 = this.l.p;
        this.G(this.l);
        return t2;
      };
      LinkList2.prototype.pushFront = function(t2) {
        this.F(t2, this.h);
        return this.M;
      };
      LinkList2.prototype.popFront = function() {
        if (this.M === 0)
          return;
        var t2 = this.H.p;
        this.G(this.H);
        return t2;
      };
      LinkList2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        r.p = i;
      };
      LinkList2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (r <= 0)
          return this.M;
        if (t2 === 0) {
          while (r--)
            this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--)
            this.pushBack(i);
        } else {
          var n = this.H;
          for (var s = 1; s < t2; ++s) {
            n = n.m;
          }
          var e = n.m;
          this.M += r;
          while (r--) {
            n.m = {
              p: i,
              L: n
            };
            n.m.L = n;
            n = n.m;
          }
          n.m = e;
          e.L = n;
        }
        return this.M;
      };
      LinkList2.prototype.find = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            return new LinkListIterator(i, this.h, this);
          }
          i = i.m;
        }
        return this.end();
      };
      LinkList2.prototype.reverse = function() {
        if (this.M <= 1)
          return;
        var t2 = this.H;
        var i = this.l;
        var r = 0;
        while (r << 1 < this.M) {
          var n = t2.p;
          t2.p = i.p;
          i.p = n;
          t2 = t2.m;
          i = i.L;
          r += 1;
        }
      };
      LinkList2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = this.H;
        while (t2 !== this.h) {
          var i = t2;
          while (i.m !== this.h && i.p === i.m.p) {
            i = i.m;
            this.M -= 1;
          }
          t2.m = i.m;
          t2.m.L = t2;
          t2 = t2.m;
        }
        return this.M;
      };
      LinkList2.prototype.sort = function(t2) {
        if (this.M <= 1)
          return;
        var i = [];
        this.forEach(function(t3) {
          i.push(t3);
        });
        i.sort(t2);
        var r = this.H;
        i.forEach(function(t3) {
          r.p = t3;
          r = r.m;
        });
      };
      LinkList2.prototype.merge = function(t2) {
        var i = this;
        if (this.M === 0) {
          t2.forEach(function(t3) {
            i.pushBack(t3);
          });
        } else {
          var r = this.H;
          t2.forEach(function(t3) {
            while (r !== i.h && r.p <= t3) {
              r = r.m;
            }
            i.F(t3, r.L);
          });
        }
        return this.M;
      };
      LinkList2.prototype.forEach = function(t2) {
        var i = this.H;
        var r = 0;
        while (i !== this.h) {
          t2(i.p, r++, this);
          i = i.m;
        }
      };
      LinkList2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator3(this, function(i) {
            switch (i.label) {
              case 0:
                if (this.M === 0)
                  return [2];
                t2 = this.H;
                i.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, t2.p];
              case 2:
                i.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }).bind(this)();
      };
      return LinkList2;
    }(Base_default);
    LinkList_default = LinkList;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js
var __extends10, __generator4, __read4, __spreadArray3, DequeIterator, Deque, Deque_default;
var init_Deque = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js"() {
    init_Base();
    init_RandomIterator();
    __extends10 = function() {
      var extendStatics2 = function(t, i) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics2(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics2(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    __generator4 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (h[0] & 1)
            throw h[1];
          return h[1];
        },
        trys: [],
        ops: []
      }, e, s, h, n;
      return n = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (n[Symbol.iterator] = function() {
        return this;
      }), n;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(n2) {
        if (e)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (e = 1, s && (h = n2[0] & 2 ? s["return"] : n2[0] ? s["throw"] || ((h = s["return"]) && h.call(s), 0) : s.next) && !(h = h.call(s, n2[1])).done)
              return h;
            if (s = 0, h)
              n2 = [n2[0] & 2, h.value];
            switch (n2[0]) {
              case 0:
              case 1:
                h = n2;
                break;
              case 4:
                r.label++;
                return {
                  value: n2[1],
                  done: false
                };
              case 5:
                r.label++;
                s = n2[1];
                n2 = [0];
                continue;
              case 7:
                n2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(h = r.trys, h = h.length > 0 && h[h.length - 1]) && (n2[0] === 6 || n2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (n2[0] === 3 && (!h || n2[1] > h[0] && n2[1] < h[3])) {
                  r.label = n2[1];
                  break;
                }
                if (n2[0] === 6 && r.label < h[1]) {
                  r.label = h[1];
                  h = n2;
                  break;
                }
                if (h && r.label < h[2]) {
                  r.label = h[2];
                  r.ops.push(n2);
                  break;
                }
                if (h[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            n2 = i.call(t, r);
          } catch (t2) {
            n2 = [6, t2];
            s = 0;
          } finally {
            e = h = 0;
          }
        if (n2[0] & 5)
          throw n2[1];
        return {
          value: n2[0] ? n2[1] : void 0,
          done: true
        };
      }
    };
    __read4 = function(t, i) {
      var r = typeof Symbol === "function" && t[Symbol.iterator];
      if (!r)
        return t;
      var e = r.call(t), s, h = [], n;
      try {
        while ((i === void 0 || i-- > 0) && !(s = e.next()).done)
          h.push(s.value);
      } catch (t2) {
        n = {
          error: t2
        };
      } finally {
        try {
          if (s && !s.done && (r = e["return"]))
            r.call(e);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return h;
    };
    __spreadArray3 = function(t, i, r) {
      if (r || arguments.length === 2)
        for (var e = 0, s = i.length, h; e < s; e++) {
          if (h || !(e in i)) {
            if (!h)
              h = Array.prototype.slice.call(i, 0, e);
            h[e] = i[e];
          }
        }
      return t.concat(h || Array.prototype.slice.call(i));
    };
    DequeIterator = function(t) {
      __extends10(DequeIterator2, t);
      function DequeIterator2(i, r, e) {
        var s = t.call(this, i, e) || this;
        s.container = r;
        return s;
      }
      DequeIterator2.prototype.copy = function() {
        return new DequeIterator2(this.o, this.container, this.iteratorType);
      };
      return DequeIterator2;
    }(RandomIterator);
    Deque = function(t) {
      __extends10(Deque2, t);
      function Deque2(i, r) {
        if (i === void 0) {
          i = [];
        }
        if (r === void 0) {
          r = 1 << 12;
        }
        var e = t.call(this) || this;
        e.A = 0;
        e.S = 0;
        e.R = 0;
        e.k = 0;
        e.C = 0;
        e.j = [];
        var s = function() {
          if (typeof i.length === "number")
            return i.length;
          if (typeof i.size === "number")
            return i.size;
          if (typeof i.size === "function")
            return i.size();
          throw new TypeError("Cannot get the length or size of the container");
        }();
        e.B = r;
        e.C = Math.max(Math.ceil(s / e.B), 1);
        for (var h = 0; h < e.C; ++h) {
          e.j.push(new Array(e.B));
        }
        var n = Math.ceil(s / e.B);
        e.A = e.R = (e.C >> 1) - (n >> 1);
        e.S = e.k = e.B - s % e.B >> 1;
        var u = e;
        i.forEach(function(t2) {
          u.pushBack(t2);
        });
        return e;
      }
      Deque2.prototype.O = function() {
        var t2 = [];
        var i = Math.max(this.C >> 1, 1);
        for (var r = 0; r < i; ++r) {
          t2[r] = new Array(this.B);
        }
        for (var r = this.A; r < this.C; ++r) {
          t2[t2.length] = this.j[r];
        }
        for (var r = 0; r < this.R; ++r) {
          t2[t2.length] = this.j[r];
        }
        t2[t2.length] = __spreadArray3([], __read4(this.j[this.R]), false);
        this.A = i;
        this.R = t2.length - 1;
        for (var r = 0; r < i; ++r) {
          t2[t2.length] = new Array(this.B);
        }
        this.j = t2;
        this.C = t2.length;
      };
      Deque2.prototype.T = function(t2) {
        var i = this.S + t2 + 1;
        var r = i % this.B;
        var e = r - 1;
        var s = this.A + (i - r) / this.B;
        if (r === 0)
          s -= 1;
        s %= this.C;
        if (e < 0)
          e += this.B;
        return {
          curNodeBucketIndex: s,
          curNodePointerIndex: e
        };
      };
      Deque2.prototype.clear = function() {
        this.j = [new Array(this.B)];
        this.C = 1;
        this.A = this.R = this.M = 0;
        this.S = this.k = this.B >> 1;
      };
      Deque2.prototype.begin = function() {
        return new DequeIterator(0, this);
      };
      Deque2.prototype.end = function() {
        return new DequeIterator(this.M, this);
      };
      Deque2.prototype.rBegin = function() {
        return new DequeIterator(this.M - 1, this, 1);
      };
      Deque2.prototype.rEnd = function() {
        return new DequeIterator(-1, this, 1);
      };
      Deque2.prototype.front = function() {
        if (this.M === 0)
          return;
        return this.j[this.A][this.S];
      };
      Deque2.prototype.back = function() {
        if (this.M === 0)
          return;
        return this.j[this.R][this.k];
      };
      Deque2.prototype.pushBack = function(t2) {
        if (this.M) {
          if (this.k < this.B - 1) {
            this.k += 1;
          } else if (this.R < this.C - 1) {
            this.R += 1;
            this.k = 0;
          } else {
            this.R = 0;
            this.k = 0;
          }
          if (this.R === this.A && this.k === this.S)
            this.O();
        }
        this.M += 1;
        this.j[this.R][this.k] = t2;
        return this.M;
      };
      Deque2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        var t2 = this.j[this.R][this.k];
        if (this.M !== 1) {
          if (this.k > 0) {
            this.k -= 1;
          } else if (this.R > 0) {
            this.R -= 1;
            this.k = this.B - 1;
          } else {
            this.R = this.C - 1;
            this.k = this.B - 1;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.pushFront = function(t2) {
        if (this.M) {
          if (this.S > 0) {
            this.S -= 1;
          } else if (this.A > 0) {
            this.A -= 1;
            this.S = this.B - 1;
          } else {
            this.A = this.C - 1;
            this.S = this.B - 1;
          }
          if (this.A === this.R && this.S === this.k)
            this.O();
        }
        this.M += 1;
        this.j[this.A][this.S] = t2;
        return this.M;
      };
      Deque2.prototype.popFront = function() {
        if (this.M === 0)
          return;
        var t2 = this.j[this.A][this.S];
        if (this.M !== 1) {
          if (this.S < this.B - 1) {
            this.S += 1;
          } else if (this.A < this.C - 1) {
            this.A += 1;
            this.S = 0;
          } else {
            this.A = 0;
            this.S = 0;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        return this.j[r][e];
      };
      Deque2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.T(t2), e = r.curNodeBucketIndex, s = r.curNodePointerIndex;
        this.j[e][s] = i;
      };
      Deque2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (t2 === 0) {
          while (r--)
            this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--)
            this.pushBack(i);
        } else {
          var e = [];
          for (var s = t2; s < this.M; ++s) {
            e.push(this.getElementByPos(s));
          }
          this.cut(t2 - 1);
          for (var s = 0; s < r; ++s)
            this.pushBack(i);
          for (var s = 0; s < e.length; ++s)
            this.pushBack(e[s]);
        }
        return this.M;
      };
      Deque2.prototype.cut = function(t2) {
        if (t2 < 0) {
          this.clear();
          return 0;
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        this.R = r;
        this.k = e;
        this.M = t2 + 1;
        return this.M;
      };
      Deque2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        if (t2 === 0)
          this.popFront();
        else if (t2 === this.M - 1)
          this.popBack();
        else {
          var i = [];
          for (var r = t2 + 1; r < this.M; ++r) {
            i.push(this.getElementByPos(r));
          }
          this.cut(t2);
          this.popBack();
          var e = this;
          i.forEach(function(t3) {
            e.pushBack(t3);
          });
        }
        return this.M;
      };
      Deque2.prototype.eraseElementByValue = function(t2) {
        if (this.M === 0)
          return 0;
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== t2)
            i.push(e);
        }
        var s = i.length;
        for (var r = 0; r < s; ++r)
          this.setElementByPos(r, i[r]);
        return this.cut(s - 1);
      };
      Deque2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        this.eraseElementByPos(i);
        t2 = t2.next();
        return t2;
      };
      Deque2.prototype.find = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          if (this.getElementByPos(i) === t2) {
            return new DequeIterator(i, this);
          }
        }
        return this.end();
      };
      Deque2.prototype.reverse = function() {
        var t2 = 0;
        var i = this.M - 1;
        while (t2 < i) {
          var r = this.getElementByPos(t2);
          this.setElementByPos(t2, this.getElementByPos(i));
          this.setElementByPos(i, r);
          t2 += 1;
          i -= 1;
        }
      };
      Deque2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = 1;
        var i = this.getElementByPos(0);
        for (var r = 1; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== i) {
            i = e;
            this.setElementByPos(t2++, e);
          }
        }
        while (this.M > t2)
          this.popBack();
        return this.M;
      };
      Deque2.prototype.sort = function(t2) {
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          i.push(this.getElementByPos(r));
        }
        i.sort(t2);
        for (var r = 0; r < this.M; ++r)
          this.setElementByPos(r, i[r]);
      };
      Deque2.prototype.shrinkToFit = function() {
        if (this.M === 0)
          return;
        var t2 = [];
        this.forEach(function(i2) {
          t2.push(i2);
        });
        this.C = Math.max(Math.ceil(this.M / this.B), 1);
        this.M = this.A = this.R = this.S = this.k = 0;
        this.j = [];
        for (var i = 0; i < this.C; ++i) {
          this.j.push(new Array(this.B));
        }
        for (var i = 0; i < t2.length; ++i)
          this.pushBack(t2[i]);
      };
      Deque2.prototype.forEach = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          t2(this.getElementByPos(i), i, this);
        }
      };
      Deque2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator4(this, function(i) {
            switch (i.label) {
              case 0:
                t2 = 0;
                i.label = 1;
              case 1:
                if (!(t2 < this.M))
                  return [3, 4];
                return [4, this.getElementByPos(t2)];
              case 2:
                i.sent();
                i.label = 3;
              case 3:
                ++t2;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        }).bind(this)();
      };
      return Deque2;
    }(Base_default);
    Deque_default = Deque;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js
var __extends11, TreeNode, TreeNodeEnableIndex;
var init_TreeNode = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js"() {
    __extends11 = function() {
      var extendStatics2 = function(e, n) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, n2) {
          e2.__proto__ = n2;
        } || function(e2, n2) {
          for (var t in n2)
            if (Object.prototype.hasOwnProperty.call(n2, t))
              e2[t] = n2[t];
        };
        return extendStatics2(e, n);
      };
      return function(e, n) {
        if (typeof n !== "function" && n !== null)
          throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics2(e, n);
        function __() {
          this.constructor = e;
        }
        e.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    }();
    TreeNode = function() {
      function TreeNode2(e, n) {
        this.ee = 1;
        this.u = void 0;
        this.p = void 0;
        this.K = void 0;
        this.N = void 0;
        this.rr = void 0;
        this.u = e;
        this.p = n;
      }
      TreeNode2.prototype.L = function() {
        var e = this;
        if (e.ee === 1 && e.rr.rr === e) {
          e = e.N;
        } else if (e.K) {
          e = e.K;
          while (e.N) {
            e = e.N;
          }
        } else {
          var n = e.rr;
          while (n.K === e) {
            e = n;
            n = e.rr;
          }
          e = n;
        }
        return e;
      };
      TreeNode2.prototype.m = function() {
        var e = this;
        if (e.N) {
          e = e.N;
          while (e.K) {
            e = e.K;
          }
          return e;
        } else {
          var n = e.rr;
          while (n.N === e) {
            e = n;
            n = e.rr;
          }
          if (e.N !== n) {
            return n;
          } else
            return e;
        }
      };
      TreeNode2.prototype.ne = function() {
        var e = this.rr;
        var n = this.N;
        var t = n.K;
        if (e.rr === this)
          e.rr = n;
        else if (e.K === this)
          e.K = n;
        else
          e.N = n;
        n.rr = e;
        n.K = this;
        this.rr = n;
        this.N = t;
        if (t)
          t.rr = this;
        return n;
      };
      TreeNode2.prototype.te = function() {
        var e = this.rr;
        var n = this.K;
        var t = n.N;
        if (e.rr === this)
          e.rr = n;
        else if (e.K === this)
          e.K = n;
        else
          e.N = n;
        n.rr = e;
        n.N = this;
        this.rr = n;
        this.K = t;
        if (t)
          t.rr = this;
        return n;
      };
      return TreeNode2;
    }();
    TreeNodeEnableIndex = function(e) {
      __extends11(TreeNodeEnableIndex2, e);
      function TreeNodeEnableIndex2() {
        var n = e !== null && e.apply(this, arguments) || this;
        n.tr = 1;
        return n;
      }
      TreeNodeEnableIndex2.prototype.ne = function() {
        var n = e.prototype.ne.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.te = function() {
        var n = e.prototype.te.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.ie = function() {
        this.tr = 1;
        if (this.K) {
          this.tr += this.K.tr;
        }
        if (this.N) {
          this.tr += this.N.tr;
        }
      };
      return TreeNodeEnableIndex2;
    }(TreeNode);
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js
var __extends12, __read5, __values3, TreeContainer, Base_default2;
var init_Base2 = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js"() {
    init_TreeNode();
    init_ContainerBase();
    init_throwError();
    __extends12 = function() {
      var extendStatics2 = function(e, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, r2) {
          e2.__proto__ = r2;
        } || function(e2, r2) {
          for (var i in r2)
            if (Object.prototype.hasOwnProperty.call(r2, i))
              e2[i] = r2[i];
        };
        return extendStatics2(e, r);
      };
      return function(e, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(e, r);
        function __() {
          this.constructor = e;
        }
        e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __read5 = function(e, r) {
      var i = typeof Symbol === "function" && e[Symbol.iterator];
      if (!i)
        return e;
      var t = i.call(e), n, s = [], f2;
      try {
        while ((r === void 0 || r-- > 0) && !(n = t.next()).done)
          s.push(n.value);
      } catch (e2) {
        f2 = {
          error: e2
        };
      } finally {
        try {
          if (n && !n.done && (i = t["return"]))
            i.call(t);
        } finally {
          if (f2)
            throw f2.error;
        }
      }
      return s;
    };
    __values3 = function(e) {
      var r = typeof Symbol === "function" && Symbol.iterator, i = r && e[r], t = 0;
      if (i)
        return i.call(e);
      if (e && typeof e.length === "number")
        return {
          next: function() {
            if (e && t >= e.length)
              e = void 0;
            return {
              value: e && e[t++],
              done: !e
            };
          }
        };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    TreeContainer = function(e) {
      __extends12(TreeContainer2, e);
      function TreeContainer2(r, i) {
        if (r === void 0) {
          r = function(e2, r2) {
            if (e2 < r2)
              return -1;
            if (e2 > r2)
              return 1;
            return 0;
          };
        }
        if (i === void 0) {
          i = false;
        }
        var t = e.call(this) || this;
        t.W = void 0;
        t.$ = r;
        if (i) {
          t.re = TreeNodeEnableIndex;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2) {
              var n = t2.rr;
              while (n !== this.h) {
                n.tr += 1;
                n = n.rr;
              }
              var s = this.fe(t2);
              if (s) {
                var f2 = s, h = f2.parentNode, u = f2.grandParent, a = f2.curNode;
                h.ie();
                u.ie();
                a.ie();
              }
            }
            return this.M;
          };
          t.G = function(e2) {
            var r2 = this.he(e2);
            while (r2 !== this.h) {
              r2.tr -= 1;
              r2 = r2.rr;
            }
          };
        } else {
          t.re = TreeNode;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2)
              this.fe(t2);
            return this.M;
          };
          t.G = t.he;
        }
        t.h = new t.re();
        return t;
      }
      TreeContainer2.prototype.U = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            e2 = e2.N;
          } else if (t > 0) {
            i = e2;
            e2 = e2.K;
          } else
            return e2;
        }
        return i;
      };
      TreeContainer2.prototype.X = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t <= 0) {
            e2 = e2.N;
          } else {
            i = e2;
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.Y = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else if (t > 0) {
            e2 = e2.K;
          } else
            return e2;
        }
        return i;
      };
      TreeContainer2.prototype.Z = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else {
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.ue = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r === this.h)
            return;
          if (e2.ee === 1) {
            e2.ee = 0;
            return;
          }
          if (e2 === r.K) {
            var i = r.N;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.ne();
              } else
                r.ne();
            } else {
              if (i.N && i.N.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.N.ee = 0;
                if (r === this.W) {
                  this.W = r.ne();
                } else
                  r.ne();
                return;
              } else if (i.K && i.K.ee === 1) {
                i.ee = 1;
                i.K.ee = 0;
                i.te();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          } else {
            var i = r.K;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.te();
              } else
                r.te();
            } else {
              if (i.K && i.K.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.K.ee = 0;
                if (r === this.W) {
                  this.W = r.te();
                } else
                  r.te();
                return;
              } else if (i.N && i.N.ee === 1) {
                i.ee = 1;
                i.N.ee = 0;
                i.ne();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          }
        }
      };
      TreeContainer2.prototype.he = function(e2) {
        var r, i;
        if (this.M === 1) {
          this.clear();
          return this.h;
        }
        var t = e2;
        while (t.K || t.N) {
          if (t.N) {
            t = t.N;
            while (t.K)
              t = t.K;
          } else {
            t = t.K;
          }
          r = __read5([t.u, e2.u], 2), e2.u = r[0], t.u = r[1];
          i = __read5([t.p, e2.p], 2), e2.p = i[0], t.p = i[1];
          e2 = t;
        }
        if (this.h.K === t) {
          this.h.K = t.rr;
        } else if (this.h.N === t) {
          this.h.N = t.rr;
        }
        this.ue(t);
        var n = t.rr;
        if (t === n.K) {
          n.K = void 0;
        } else
          n.N = void 0;
        this.M -= 1;
        this.W.ee = 0;
        return n;
      };
      TreeContainer2.prototype.ae = function(e2, r) {
        if (e2 === void 0)
          return false;
        var i = this.ae(e2.K, r);
        if (i)
          return true;
        if (r(e2))
          return true;
        return this.ae(e2.N, r);
      };
      TreeContainer2.prototype.fe = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r.ee === 0)
            return;
          var i = r.rr;
          if (r === i.K) {
            var t = i.N;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W)
                return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.N) {
              e2.ee = 0;
              if (e2.K)
                e2.K.rr = r;
              if (e2.N)
                e2.N.rr = i;
              r.N = e2.K;
              i.K = e2.N;
              e2.K = r;
              e2.N = i;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else
                  n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.te();
              } else
                i.te();
              i.ee = 1;
            }
          } else {
            var t = i.K;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W)
                return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.K) {
              e2.ee = 0;
              if (e2.K)
                e2.K.rr = i;
              if (e2.N)
                e2.N.rr = r;
              i.N = e2.K;
              r.K = e2.N;
              e2.K = i;
              e2.N = r;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else
                  n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.ne();
              } else
                i.ne();
              i.ee = 1;
            }
          }
          return;
        }
      };
      TreeContainer2.prototype.se = function(e2, r, i) {
        if (this.W === void 0) {
          this.M += 1;
          this.W = new this.re(e2, r);
          this.W.ee = 0;
          this.W.rr = this.h;
          this.h.rr = this.W;
          this.h.K = this.W;
          this.h.N = this.W;
          return;
        }
        var t;
        var n = this.h.K;
        var s = this.$(n.u, e2);
        if (s === 0) {
          n.p = r;
          return;
        } else if (s > 0) {
          n.K = new this.re(e2, r);
          n.K.rr = n;
          t = n.K;
          this.h.K = t;
        } else {
          var f2 = this.h.N;
          var h = this.$(f2.u, e2);
          if (h === 0) {
            f2.p = r;
            return;
          } else if (h < 0) {
            f2.N = new this.re(e2, r);
            f2.N.rr = f2;
            t = f2.N;
            this.h.N = t;
          } else {
            if (i !== void 0) {
              var u = i.o;
              if (u !== this.h) {
                var a = this.$(u.u, e2);
                if (a === 0) {
                  u.p = r;
                  return;
                } else if (a > 0) {
                  var o = u.L();
                  var l2 = this.$(o.u, e2);
                  if (l2 === 0) {
                    o.p = r;
                    return;
                  } else if (l2 < 0) {
                    t = new this.re(e2, r);
                    if (o.N === void 0) {
                      o.N = t;
                      t.rr = o;
                    } else {
                      u.K = t;
                      t.rr = u;
                    }
                  }
                }
              }
            }
            if (t === void 0) {
              t = this.W;
              while (true) {
                var v2 = this.$(t.u, e2);
                if (v2 > 0) {
                  if (t.K === void 0) {
                    t.K = new this.re(e2, r);
                    t.K.rr = t;
                    t = t.K;
                    break;
                  }
                  t = t.K;
                } else if (v2 < 0) {
                  if (t.N === void 0) {
                    t.N = new this.re(e2, r);
                    t.N.rr = t;
                    t = t.N;
                    break;
                  }
                  t = t.N;
                } else {
                  t.p = r;
                  return;
                }
              }
            }
          }
        }
        this.M += 1;
        return t;
      };
      TreeContainer2.prototype.g = function(e2, r) {
        while (e2) {
          var i = this.$(e2.u, r);
          if (i < 0) {
            e2 = e2.N;
          } else if (i > 0) {
            e2 = e2.K;
          } else
            return e2;
        }
        return e2 || this.h;
      };
      TreeContainer2.prototype.clear = function() {
        this.M = 0;
        this.W = void 0;
        this.h.rr = void 0;
        this.h.K = this.h.N = void 0;
      };
      TreeContainer2.prototype.updateKeyByIterator = function(e2, r) {
        var i = e2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        if (this.M === 1) {
          i.u = r;
          return true;
        }
        if (i === this.h.K) {
          if (this.$(i.m().u, r) > 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        if (i === this.h.N) {
          if (this.$(i.L().u, r) < 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        var t = i.L().u;
        if (this.$(t, r) >= 0)
          return false;
        var n = i.m().u;
        if (this.$(n, r) <= 0)
          return false;
        i.u = r;
        return true;
      };
      TreeContainer2.prototype.eraseElementByPos = function(e2) {
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var r = 0;
        var i = this;
        this.ae(this.W, function(t) {
          if (e2 === r) {
            i.G(t);
            return true;
          }
          r += 1;
          return false;
        });
        return this.M;
      };
      TreeContainer2.prototype.eraseElementByKey = function(e2) {
        if (this.M === 0)
          return false;
        var r = this.g(this.W, e2);
        if (r === this.h)
          return false;
        this.G(r);
        return true;
      };
      TreeContainer2.prototype.eraseElementByIterator = function(e2) {
        var r = e2.o;
        if (r === this.h) {
          throwIteratorAccessError();
        }
        var i = r.N === void 0;
        var t = e2.iteratorType === 0;
        if (t) {
          if (i)
            e2.next();
        } else {
          if (!i || r.K === void 0)
            e2.next();
        }
        this.G(r);
        return e2;
      };
      TreeContainer2.prototype.forEach = function(e2) {
        var r, i;
        var t = 0;
        try {
          for (var n = __values3(this), s = n.next(); !s.done; s = n.next()) {
            var f2 = s.value;
            e2(f2, t++, this);
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (s && !s.done && (i = n.return))
              i.call(n);
          } finally {
            if (r)
              throw r.error;
          }
        }
      };
      TreeContainer2.prototype.getElementByPos = function(e2) {
        var r, i;
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var t;
        var n = 0;
        try {
          for (var s = __values3(this), f2 = s.next(); !f2.done; f2 = s.next()) {
            var h = f2.value;
            if (n === e2) {
              t = h;
              break;
            }
            n += 1;
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (f2 && !f2.done && (i = s.return))
              i.call(s);
          } finally {
            if (r)
              throw r.error;
          }
        }
        return t;
      };
      TreeContainer2.prototype.getHeight = function() {
        if (this.M === 0)
          return 0;
        var traversal = function(e2) {
          if (!e2)
            return 0;
          return Math.max(traversal(e2.K), traversal(e2.N)) + 1;
        };
        return traversal(this.W);
      };
      return TreeContainer2;
    }(Container);
    Base_default2 = TreeContainer;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js
var __extends13, TreeIterator, TreeIterator_default;
var init_TreeIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js"() {
    init_ContainerBase();
    init_throwError();
    __extends13 = function() {
      var extendStatics2 = function(r, t) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, t2) {
          r2.__proto__ = t2;
        } || function(r2, t2) {
          for (var e in t2)
            if (Object.prototype.hasOwnProperty.call(t2, e))
              r2[e] = t2[e];
        };
        return extendStatics2(r, t);
      };
      return function(r, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics2(r, t);
        function __() {
          this.constructor = r;
        }
        r.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    TreeIterator = function(r) {
      __extends13(TreeIterator2, r);
      function TreeIterator2(t, e, i) {
        var n = r.call(this, i) || this;
        n.o = t;
        n.h = e;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o === this.h.K) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o === this.h.N) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
        }
        return n;
      }
      Object.defineProperty(TreeIterator2.prototype, "index", {
        get: function() {
          var r2 = this.o;
          var t = this.h.rr;
          if (r2 === this.h) {
            if (t) {
              return t.tr - 1;
            }
            return 0;
          }
          var e = 0;
          if (r2.K) {
            e += r2.K.tr;
          }
          while (r2 !== t) {
            var i = r2.rr;
            if (r2 === i.N) {
              e += 1;
              if (i.K) {
                e += i.K.tr;
              }
            }
            r2 = i;
          }
          return e;
        },
        enumerable: false,
        configurable: true
      });
      return TreeIterator2;
    }(ContainerIterator);
    TreeIterator_default = TreeIterator;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js
var __extends14, __generator5, __values4, OrderedSetIterator, OrderedSet, OrderedSet_default;
var init_OrderedSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js"() {
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends14 = function() {
      var extendStatics2 = function(e, t) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, t2) {
          e2.__proto__ = t2;
        } || function(e2, t2) {
          for (var r in t2)
            if (Object.prototype.hasOwnProperty.call(t2, r))
              e2[r] = t2[r];
        };
        return extendStatics2(e, t);
      };
      return function(e, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics2(e, t);
        function __() {
          this.constructor = e;
        }
        e.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    __generator5 = function(e, t) {
      var r = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(e2) {
        return function(t2) {
          return step([e2, t2]);
        };
      }
      function step(u2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done)
              return o;
            if (i = 0, o)
              u2 = [u2[0] & 2, o.value];
            switch (u2[0]) {
              case 0:
              case 1:
                o = u2;
                break;
              case 4:
                r.label++;
                return {
                  value: u2[1],
                  done: false
                };
              case 5:
                r.label++;
                i = u2[1];
                u2 = [0];
                continue;
              case 7:
                u2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(o = r.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                  r.label = u2[1];
                  break;
                }
                if (u2[0] === 6 && r.label < o[1]) {
                  r.label = o[1];
                  o = u2;
                  break;
                }
                if (o && r.label < o[2]) {
                  r.label = o[2];
                  r.ops.push(u2);
                  break;
                }
                if (o[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            u2 = t.call(e, r);
          } catch (e2) {
            u2 = [6, e2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (u2[0] & 5)
          throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __values4 = function(e) {
      var t = typeof Symbol === "function" && Symbol.iterator, r = t && e[t], n = 0;
      if (r)
        return r.call(e);
      if (e && typeof e.length === "number")
        return {
          next: function() {
            if (e && n >= e.length)
              e = void 0;
            return {
              value: e && e[n++],
              done: !e
            };
          }
        };
      throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedSetIterator = function(e) {
      __extends14(OrderedSetIterator2, e);
      function OrderedSetIterator2(t, r, n, i) {
        var o = e.call(this, t, r, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      OrderedSetIterator2.prototype.copy = function() {
        return new OrderedSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedSetIterator2;
    }(TreeIterator_default);
    OrderedSet = function(e) {
      __extends14(OrderedSet2, e);
      function OrderedSet2(t, r, n) {
        if (t === void 0) {
          t = [];
        }
        var i = e.call(this, r, n) || this;
        var o = i;
        t.forEach(function(e2) {
          o.insert(e2);
        });
        return i;
      }
      OrderedSet2.prototype.P = function(e2) {
        return __generator5(this, function(t) {
          switch (t.label) {
            case 0:
              if (e2 === void 0)
                return [2];
              return [5, __values4(this.P(e2.K))];
            case 1:
              t.sent();
              return [4, e2.u];
            case 2:
              t.sent();
              return [5, __values4(this.P(e2.N))];
            case 3:
              t.sent();
              return [2];
          }
        });
      };
      OrderedSet2.prototype.begin = function() {
        return new OrderedSetIterator(this.h.K || this.h, this.h, this);
      };
      OrderedSet2.prototype.end = function() {
        return new OrderedSetIterator(this.h, this.h, this);
      };
      OrderedSet2.prototype.rBegin = function() {
        return new OrderedSetIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.rEnd = function() {
        return new OrderedSetIterator(this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.front = function() {
        return this.h.K ? this.h.K.u : void 0;
      };
      OrderedSet2.prototype.back = function() {
        return this.h.N ? this.h.N.u : void 0;
      };
      OrderedSet2.prototype.insert = function(e2, t) {
        return this.v(e2, void 0, t);
      };
      OrderedSet2.prototype.find = function(e2) {
        var t = this.g(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.lowerBound = function(e2) {
        var t = this.U(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.upperBound = function(e2) {
        var t = this.X(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseLowerBound = function(e2) {
        var t = this.Y(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseUpperBound = function(e2) {
        var t = this.Z(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.union = function(e2) {
        var t = this;
        e2.forEach(function(e3) {
          t.insert(e3);
        });
        return this.M;
      };
      OrderedSet2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedSet2;
    }(Base_default2);
    OrderedSet_default = OrderedSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js
var __extends15, __generator6, __values5, OrderedMapIterator, OrderedMap, OrderedMap_default;
var init_OrderedMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js"() {
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends15 = function() {
      var extendStatics2 = function(r, e) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, e2) {
          r2.__proto__ = e2;
        } || function(r2, e2) {
          for (var t in e2)
            if (Object.prototype.hasOwnProperty.call(e2, t))
              r2[t] = e2[t];
        };
        return extendStatics2(r, e);
      };
      return function(r, e) {
        if (typeof e !== "function" && e !== null)
          throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        extendStatics2(r, e);
        function __() {
          this.constructor = r;
        }
        r.prototype = e === null ? Object.create(e) : (__.prototype = e.prototype, new __());
      };
    }();
    __generator6 = function(r, e) {
      var t = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(r2) {
        return function(e2) {
          return step([r2, e2]);
        };
      }
      function step(a2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (t)
          try {
            if (n = 1, i && (o = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, a2[1])).done)
              return o;
            if (i = 0, o)
              a2 = [a2[0] & 2, o.value];
            switch (a2[0]) {
              case 0:
              case 1:
                o = a2;
                break;
              case 4:
                t.label++;
                return {
                  value: a2[1],
                  done: false
                };
              case 5:
                t.label++;
                i = a2[1];
                a2 = [0];
                continue;
              case 7:
                a2 = t.ops.pop();
                t.trys.pop();
                continue;
              default:
                if (!(o = t.trys, o = o.length > 0 && o[o.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                  t = 0;
                  continue;
                }
                if (a2[0] === 3 && (!o || a2[1] > o[0] && a2[1] < o[3])) {
                  t.label = a2[1];
                  break;
                }
                if (a2[0] === 6 && t.label < o[1]) {
                  t.label = o[1];
                  o = a2;
                  break;
                }
                if (o && t.label < o[2]) {
                  t.label = o[2];
                  t.ops.push(a2);
                  break;
                }
                if (o[2])
                  t.ops.pop();
                t.trys.pop();
                continue;
            }
            a2 = e.call(r, t);
          } catch (r2) {
            a2 = [6, r2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (a2[0] & 5)
          throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    __values5 = function(r) {
      var e = typeof Symbol === "function" && Symbol.iterator, t = e && r[e], n = 0;
      if (t)
        return t.call(r);
      if (r && typeof r.length === "number")
        return {
          next: function() {
            if (r && n >= r.length)
              r = void 0;
            return {
              value: r && r[n++],
              done: !r
            };
          }
        };
      throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedMapIterator = function(r) {
      __extends15(OrderedMapIterator2, r);
      function OrderedMapIterator2(e, t, n, i) {
        var o = r.call(this, e, t, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var r2 = this;
          return new Proxy([], {
            get: function(e, t) {
              if (t === "0")
                return r2.o.u;
              else if (t === "1")
                return r2.o.p;
            },
            set: function(e, t, n) {
              if (t !== "1") {
                throw new TypeError("props must be 1");
              }
              r2.o.p = n;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      OrderedMapIterator2.prototype.copy = function() {
        return new OrderedMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedMapIterator2;
    }(TreeIterator_default);
    OrderedMap = function(r) {
      __extends15(OrderedMap2, r);
      function OrderedMap2(e, t, n) {
        if (e === void 0) {
          e = [];
        }
        var i = r.call(this, t, n) || this;
        var o = i;
        e.forEach(function(r2) {
          o.setElement(r2[0], r2[1]);
        });
        return i;
      }
      OrderedMap2.prototype.P = function(r2) {
        return __generator6(this, function(e) {
          switch (e.label) {
            case 0:
              if (r2 === void 0)
                return [2];
              return [5, __values5(this.P(r2.K))];
            case 1:
              e.sent();
              return [4, [r2.u, r2.p]];
            case 2:
              e.sent();
              return [5, __values5(this.P(r2.N))];
            case 3:
              e.sent();
              return [2];
          }
        });
      };
      OrderedMap2.prototype.begin = function() {
        return new OrderedMapIterator(this.h.K || this.h, this.h, this);
      };
      OrderedMap2.prototype.end = function() {
        return new OrderedMapIterator(this.h, this.h, this);
      };
      OrderedMap2.prototype.rBegin = function() {
        return new OrderedMapIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.rEnd = function() {
        return new OrderedMapIterator(this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.front = function() {
        if (this.M === 0)
          return;
        var r2 = this.h.K;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.back = function() {
        if (this.M === 0)
          return;
        var r2 = this.h.N;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.lowerBound = function(r2) {
        var e = this.U(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.upperBound = function(r2) {
        var e = this.X(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseLowerBound = function(r2) {
        var e = this.Y(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseUpperBound = function(r2) {
        var e = this.Z(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.setElement = function(r2, e, t) {
        return this.v(r2, e, t);
      };
      OrderedMap2.prototype.find = function(r2) {
        var e = this.g(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.getElementByKey = function(r2) {
        var e = this.g(this.W, r2);
        return e.p;
      };
      OrderedMap2.prototype.union = function(r2) {
        var e = this;
        r2.forEach(function(r3) {
          e.setElement(r3[0], r3[1]);
        });
        return this.M;
      };
      OrderedMap2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedMap2;
    }(Base_default2);
    OrderedMap_default = OrderedMap;
  }
});

// node_modules/js-sdsl/dist/esm/utils/checkObject.js
function checkObject(t) {
  var e = typeof t;
  return e === "object" && t !== null || e === "function";
}
var init_checkObject = __esm({
  "node_modules/js-sdsl/dist/esm/utils/checkObject.js"() {
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js
var __extends16, HashContainerIterator, HashContainer;
var init_Base3 = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js"() {
    init_ContainerBase();
    init_checkObject();
    init_throwError();
    __extends16 = function() {
      var extendStatics2 = function(t, i) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics2(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics2(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    HashContainerIterator = function(t) {
      __extends16(HashContainerIterator2, t);
      function HashContainerIterator2(i, r, e) {
        var n = t.call(this, e) || this;
        n.o = i;
        n.h = r;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return n;
      }
      return HashContainerIterator2;
    }(ContainerIterator);
    HashContainer = function(t) {
      __extends16(HashContainer2, t);
      function HashContainer2() {
        var i = t.call(this) || this;
        i._ = [];
        i.I = {};
        i.HASH_TAG = Symbol("@@HASH_TAG");
        Object.setPrototypeOf(i.I, null);
        i.h = {};
        i.h.L = i.h.m = i.H = i.l = i.h;
        return i;
      }
      HashContainer2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      HashContainer2.prototype.v = function(t2, i, r) {
        if (r === void 0)
          r = checkObject(t2);
        var e;
        if (r) {
          var n = t2[this.HASH_TAG];
          if (n !== void 0) {
            this._[n].p = i;
            return this.M;
          }
          Object.defineProperty(t2, this.HASH_TAG, {
            value: this._.length,
            configurable: true
          });
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this._.push(e);
        } else {
          var s = this.I[t2];
          if (s) {
            s.p = i;
            return this.M;
          }
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this.I[t2] = e;
        }
        if (this.M === 0) {
          this.H = e;
          this.h.m = e;
        } else {
          this.l.m = e;
        }
        this.l = e;
        this.h.L = e;
        return ++this.M;
      };
      HashContainer2.prototype.g = function(t2, i) {
        if (i === void 0)
          i = checkObject(t2);
        if (i) {
          var r = t2[this.HASH_TAG];
          if (r === void 0)
            return this.h;
          return this._[r];
        } else {
          return this.I[t2] || this.h;
        }
      };
      HashContainer2.prototype.clear = function() {
        var t2 = this.HASH_TAG;
        this._.forEach(function(i) {
          delete i.u[t2];
        });
        this._ = [];
        this.I = {};
        Object.setPrototypeOf(this.I, null);
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      HashContainer2.prototype.eraseElementByKey = function(t2, i) {
        var r;
        if (i === void 0)
          i = checkObject(t2);
        if (i) {
          var e = t2[this.HASH_TAG];
          if (e === void 0)
            return false;
          delete t2[this.HASH_TAG];
          r = this._[e];
          delete this._[e];
        } else {
          r = this.I[t2];
          if (r === void 0)
            return false;
          delete this.I[t2];
        }
        this.G(r);
        return true;
      };
      HashContainer2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        this.G(i);
        return t2.next();
      };
      HashContainer2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      return HashContainer2;
    }(Container);
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js
var __extends17, __generator7, HashSetIterator, HashSet, HashSet_default;
var init_HashSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js"() {
    init_Base3();
    init_throwError();
    __extends17 = function() {
      var extendStatics2 = function(t, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2)
            if (Object.prototype.hasOwnProperty.call(r2, e))
              t2[e] = r2[e];
        };
        return extendStatics2(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator7 = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (s[0] & 1)
            throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      }, n, i, s, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(a2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (e)
          try {
            if (n = 1, i && (s = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((s = i["return"]) && s.call(i), 0) : i.next) && !(s = s.call(i, a2[1])).done)
              return s;
            if (i = 0, s)
              a2 = [a2[0] & 2, s.value];
            switch (a2[0]) {
              case 0:
              case 1:
                s = a2;
                break;
              case 4:
                e.label++;
                return {
                  value: a2[1],
                  done: false
                };
              case 5:
                e.label++;
                i = a2[1];
                a2 = [0];
                continue;
              case 7:
                a2 = e.ops.pop();
                e.trys.pop();
                continue;
              default:
                if (!(s = e.trys, s = s.length > 0 && s[s.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                  e = 0;
                  continue;
                }
                if (a2[0] === 3 && (!s || a2[1] > s[0] && a2[1] < s[3])) {
                  e.label = a2[1];
                  break;
                }
                if (a2[0] === 6 && e.label < s[1]) {
                  e.label = s[1];
                  s = a2;
                  break;
                }
                if (s && e.label < s[2]) {
                  e.label = s[2];
                  e.ops.push(a2);
                  break;
                }
                if (s[2])
                  e.ops.pop();
                e.trys.pop();
                continue;
            }
            a2 = r.call(t, e);
          } catch (t2) {
            a2 = [6, t2];
            i = 0;
          } finally {
            n = s = 0;
          }
        if (a2[0] & 5)
          throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    HashSetIterator = function(t) {
      __extends17(HashSetIterator2, t);
      function HashSetIterator2(r, e, n, i) {
        var s = t.call(this, r, e, i) || this;
        s.container = n;
        return s;
      }
      Object.defineProperty(HashSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      HashSetIterator2.prototype.copy = function() {
        return new HashSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashSetIterator2;
    }(HashContainerIterator);
    HashSet = function(t) {
      __extends17(HashSet2, t);
      function HashSet2(r) {
        if (r === void 0) {
          r = [];
        }
        var e = t.call(this) || this;
        var n = e;
        r.forEach(function(t2) {
          n.insert(t2);
        });
        return e;
      }
      HashSet2.prototype.begin = function() {
        return new HashSetIterator(this.H, this.h, this);
      };
      HashSet2.prototype.end = function() {
        return new HashSetIterator(this.h, this.h, this);
      };
      HashSet2.prototype.rBegin = function() {
        return new HashSetIterator(this.l, this.h, this, 1);
      };
      HashSet2.prototype.rEnd = function() {
        return new HashSetIterator(this.h, this.h, this, 1);
      };
      HashSet2.prototype.front = function() {
        return this.H.u;
      };
      HashSet2.prototype.back = function() {
        return this.l.u;
      };
      HashSet2.prototype.insert = function(t2, r) {
        return this.v(t2, void 0, r);
      };
      HashSet2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return r.u;
      };
      HashSet2.prototype.find = function(t2, r) {
        var e = this.g(t2, r);
        return new HashSetIterator(e, this.h, this);
      };
      HashSet2.prototype.forEach = function(t2) {
        var r = 0;
        var e = this.H;
        while (e !== this.h) {
          t2(e.u, r++, this);
          e = e.m;
        }
      };
      HashSet2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator7(this, function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, t2.u];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }).bind(this)();
      };
      return HashSet2;
    }(HashContainer);
    HashSet_default = HashSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js
var __extends18, __generator8, HashMapIterator, HashMap, HashMap_default;
var init_HashMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js"() {
    init_Base3();
    init_checkObject();
    init_throwError();
    __extends18 = function() {
      var extendStatics2 = function(t, r) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2)
            if (Object.prototype.hasOwnProperty.call(r2, n))
              t2[n] = r2[n];
        };
        return extendStatics2(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics2(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator8 = function(t, r) {
      var n = {
        label: 0,
        sent: function() {
          if (a[0] & 1)
            throw a[1];
          return a[1];
        },
        trys: [],
        ops: []
      }, e, i, a, s;
      return s = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (s[Symbol.iterator] = function() {
        return this;
      }), s;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(s2) {
        if (e)
          throw new TypeError("Generator is already executing.");
        while (n)
          try {
            if (e = 1, i && (a = s2[0] & 2 ? i["return"] : s2[0] ? i["throw"] || ((a = i["return"]) && a.call(i), 0) : i.next) && !(a = a.call(i, s2[1])).done)
              return a;
            if (i = 0, a)
              s2 = [s2[0] & 2, a.value];
            switch (s2[0]) {
              case 0:
              case 1:
                a = s2;
                break;
              case 4:
                n.label++;
                return {
                  value: s2[1],
                  done: false
                };
              case 5:
                n.label++;
                i = s2[1];
                s2 = [0];
                continue;
              case 7:
                s2 = n.ops.pop();
                n.trys.pop();
                continue;
              default:
                if (!(a = n.trys, a = a.length > 0 && a[a.length - 1]) && (s2[0] === 6 || s2[0] === 2)) {
                  n = 0;
                  continue;
                }
                if (s2[0] === 3 && (!a || s2[1] > a[0] && s2[1] < a[3])) {
                  n.label = s2[1];
                  break;
                }
                if (s2[0] === 6 && n.label < a[1]) {
                  n.label = a[1];
                  a = s2;
                  break;
                }
                if (a && n.label < a[2]) {
                  n.label = a[2];
                  n.ops.push(s2);
                  break;
                }
                if (a[2])
                  n.ops.pop();
                n.trys.pop();
                continue;
            }
            s2 = r.call(t, n);
          } catch (t2) {
            s2 = [6, t2];
            i = 0;
          } finally {
            e = a = 0;
          }
        if (s2[0] & 5)
          throw s2[1];
        return {
          value: s2[0] ? s2[1] : void 0,
          done: true
        };
      }
    };
    HashMapIterator = function(t) {
      __extends18(HashMapIterator2, t);
      function HashMapIterator2(r, n, e, i) {
        var a = t.call(this, r, n, i) || this;
        a.container = e;
        return a;
      }
      Object.defineProperty(HashMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var t2 = this;
          return new Proxy([], {
            get: function(r, n) {
              if (n === "0")
                return t2.o.u;
              else if (n === "1")
                return t2.o.p;
            },
            set: function(r, n, e) {
              if (n !== "1") {
                throw new TypeError("props must be 1");
              }
              t2.o.p = e;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      HashMapIterator2.prototype.copy = function() {
        return new HashMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashMapIterator2;
    }(HashContainerIterator);
    HashMap = function(t) {
      __extends18(HashMap2, t);
      function HashMap2(r) {
        if (r === void 0) {
          r = [];
        }
        var n = t.call(this) || this;
        var e = n;
        r.forEach(function(t2) {
          e.setElement(t2[0], t2[1]);
        });
        return n;
      }
      HashMap2.prototype.begin = function() {
        return new HashMapIterator(this.H, this.h, this);
      };
      HashMap2.prototype.end = function() {
        return new HashMapIterator(this.h, this.h, this);
      };
      HashMap2.prototype.rBegin = function() {
        return new HashMapIterator(this.l, this.h, this, 1);
      };
      HashMap2.prototype.rEnd = function() {
        return new HashMapIterator(this.h, this.h, this, 1);
      };
      HashMap2.prototype.front = function() {
        if (this.M === 0)
          return;
        return [this.H.u, this.H.p];
      };
      HashMap2.prototype.back = function() {
        if (this.M === 0)
          return;
        return [this.l.u, this.l.p];
      };
      HashMap2.prototype.setElement = function(t2, r, n) {
        return this.v(t2, r, n);
      };
      HashMap2.prototype.getElementByKey = function(t2, r) {
        if (r === void 0)
          r = checkObject(t2);
        if (r) {
          var n = t2[this.HASH_TAG];
          return n !== void 0 ? this._[n].p : void 0;
        }
        var e = this.I[t2];
        return e ? e.p : void 0;
      };
      HashMap2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return [r.u, r.p];
      };
      HashMap2.prototype.find = function(t2, r) {
        var n = this.g(t2, r);
        return new HashMapIterator(n, this.h, this);
      };
      HashMap2.prototype.forEach = function(t2) {
        var r = 0;
        var n = this.H;
        while (n !== this.h) {
          t2([n.u, n.p], r++, this);
          n = n.m;
        }
      };
      HashMap2.prototype[Symbol.iterator] = function() {
        return (function() {
          var t2;
          return __generator8(this, function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, [t2.u, t2.p]];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }).bind(this)();
      };
      return HashMap2;
    }(HashContainer);
    HashMap_default = HashMap;
  }
});

// node_modules/js-sdsl/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Deque: () => Deque_default,
  HashMap: () => HashMap_default,
  HashSet: () => HashSet_default,
  LinkList: () => LinkList_default,
  OrderedMap: () => OrderedMap_default,
  OrderedSet: () => OrderedSet_default,
  PriorityQueue: () => PriorityQueue_default,
  Queue: () => Queue_default,
  Stack: () => Stack_default,
  Vector: () => Vector_default
});
var init_esm = __esm({
  "node_modules/js-sdsl/dist/esm/index.js"() {
    init_Stack();
    init_Queue();
    init_PriorityQueue();
    init_Vector();
    init_LinkList();
    init_Deque();
    init_OrderedSet();
    init_OrderedMap();
    init_HashSet();
    init_HashMap();
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m2 = s * 60;
    var h = m2 * 60;
    var d = h * 24;
    var w2 = d * 7;
    var y = d * 365.25;
    module.exports = function(val2, options) {
      options = options || {};
      var type = typeof val2;
      if (type === "string" && val2.length > 0) {
        return parse(val2);
      } else if (type === "number" && isFinite(val2)) {
        return options.long ? fmtLong(val2) : fmtShort(val2);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val2)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val2 = args[index];
              match = formatter.call(self2, val2);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val2) {
        if (val2 instanceof Error) {
          return val2.stack || val2.message;
        }
        return val2;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/number-allocator/lib/number-allocator.js
var require_number_allocator = __commonJS({
  "node_modules/number-allocator/lib/number-allocator.js"(exports, module) {
    "use strict";
    var SortedSet = (init_esm(), __toCommonJS(esm_exports)).OrderedSet;
    var debugTrace = require_browser3()("number-allocator:trace");
    var debugError = require_browser3()("number-allocator:error");
    function Interval(low, high) {
      this.low = low;
      this.high = high;
    }
    Interval.prototype.equals = function(other) {
      return this.low === other.low && this.high === other.high;
    };
    Interval.prototype.compare = function(other) {
      if (this.low < other.low && this.high < other.low)
        return -1;
      if (other.low < this.low && other.high < this.low)
        return 1;
      return 0;
    };
    function NumberAllocator(min, max) {
      if (!(this instanceof NumberAllocator)) {
        return new NumberAllocator(min, max);
      }
      this.min = min;
      this.max = max;
      this.ss = new SortedSet(
        [],
        (lhs, rhs) => {
          return lhs.compare(rhs);
        }
      );
      debugTrace("Create");
      this.clear();
    }
    NumberAllocator.prototype.firstVacant = function() {
      if (this.ss.size() === 0)
        return null;
      return this.ss.front().low;
    };
    NumberAllocator.prototype.alloc = function() {
      if (this.ss.size() === 0) {
        debugTrace("alloc():empty");
        return null;
      }
      const it2 = this.ss.begin();
      const low = it2.pointer.low;
      const high = it2.pointer.high;
      const num = low;
      if (num + 1 <= high) {
        this.ss.updateKeyByIterator(it2, new Interval(low + 1, high));
      } else {
        this.ss.eraseElementByPos(0);
      }
      debugTrace("alloc():" + num);
      return num;
    };
    NumberAllocator.prototype.use = function(num) {
      const key = new Interval(num, num);
      const it2 = this.ss.lowerBound(key);
      if (!it2.equals(this.ss.end())) {
        const low = it2.pointer.low;
        const high = it2.pointer.high;
        if (it2.pointer.equals(key)) {
          this.ss.eraseElementByIterator(it2);
          debugTrace("use():" + num);
          return true;
        }
        if (low > num)
          return false;
        if (low === num) {
          this.ss.updateKeyByIterator(it2, new Interval(low + 1, high));
          debugTrace("use():" + num);
          return true;
        }
        if (high === num) {
          this.ss.updateKeyByIterator(it2, new Interval(low, high - 1));
          debugTrace("use():" + num);
          return true;
        }
        this.ss.updateKeyByIterator(it2, new Interval(num + 1, high));
        this.ss.insert(new Interval(low, num - 1));
        debugTrace("use():" + num);
        return true;
      }
      debugTrace("use():failed");
      return false;
    };
    NumberAllocator.prototype.free = function(num) {
      if (num < this.min || num > this.max) {
        debugError("free():" + num + " is out of range");
        return;
      }
      const key = new Interval(num, num);
      const it2 = this.ss.upperBound(key);
      if (it2.equals(this.ss.end())) {
        if (it2.equals(this.ss.begin())) {
          this.ss.insert(key);
          return;
        }
        it2.pre();
        const low = it2.pointer.high;
        const high = it2.pointer.high;
        if (high + 1 === num) {
          this.ss.updateKeyByIterator(it2, new Interval(low, num));
        } else {
          this.ss.insert(key);
        }
      } else {
        if (it2.equals(this.ss.begin())) {
          if (num + 1 === it2.pointer.low) {
            const high = it2.pointer.high;
            this.ss.updateKeyByIterator(it2, new Interval(num, high));
          } else {
            this.ss.insert(key);
          }
        } else {
          const rLow = it2.pointer.low;
          const rHigh = it2.pointer.high;
          it2.pre();
          const lLow = it2.pointer.low;
          const lHigh = it2.pointer.high;
          if (lHigh + 1 === num) {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it2);
              this.ss.updateKeyByIterator(it2, new Interval(lLow, rHigh));
            } else {
              this.ss.updateKeyByIterator(it2, new Interval(lLow, num));
            }
          } else {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it2.next());
              this.ss.insert(new Interval(num, rHigh));
            } else {
              this.ss.insert(key);
            }
          }
        }
      }
      debugTrace("free():" + num);
    };
    NumberAllocator.prototype.clear = function() {
      debugTrace("clear()");
      this.ss.clear();
      this.ss.insert(new Interval(this.min, this.max));
    };
    NumberAllocator.prototype.intervalCount = function() {
      return this.ss.size();
    };
    NumberAllocator.prototype.dump = function() {
      console.log("length:" + this.ss.size());
      for (const element of this.ss) {
        console.log(element);
      }
    };
    module.exports = NumberAllocator;
  }
});

// node_modules/number-allocator/index.js
var require_number_allocator2 = __commonJS({
  "node_modules/number-allocator/index.js"(exports, module) {
    var NumberAllocator = require_number_allocator();
    module.exports.NumberAllocator = NumberAllocator;
  }
});

// node_modules/mqtt/lib/topic-alias-send.js
var require_topic_alias_send = __commonJS({
  "node_modules/mqtt/lib/topic-alias-send.js"(exports, module) {
    "use strict";
    var LruMap = require_lru_cache();
    var NumberAllocator = require_number_allocator2().NumberAllocator;
    function TopicAliasSend(max) {
      if (!(this instanceof TopicAliasSend)) {
        return new TopicAliasSend(max);
      }
      if (max > 0) {
        this.aliasToTopic = new LruMap({ max });
        this.topicToAlias = {};
        this.numberAllocator = new NumberAllocator(1, max);
        this.max = max;
        this.length = 0;
      }
    }
    TopicAliasSend.prototype.put = function(topic, alias) {
      if (alias === 0 || alias > this.max) {
        return false;
      }
      const entry = this.aliasToTopic.get(alias);
      if (entry) {
        delete this.topicToAlias[entry];
      }
      this.aliasToTopic.set(alias, topic);
      this.topicToAlias[topic] = alias;
      this.numberAllocator.use(alias);
      this.length = this.aliasToTopic.length;
      return true;
    };
    TopicAliasSend.prototype.getTopicByAlias = function(alias) {
      return this.aliasToTopic.get(alias);
    };
    TopicAliasSend.prototype.getAliasByTopic = function(topic) {
      const alias = this.topicToAlias[topic];
      if (typeof alias !== "undefined") {
        this.aliasToTopic.get(alias);
      }
      return alias;
    };
    TopicAliasSend.prototype.clear = function() {
      this.aliasToTopic.reset();
      this.topicToAlias = {};
      this.numberAllocator.clear();
      this.length = 0;
    };
    TopicAliasSend.prototype.getLruAlias = function() {
      const alias = this.numberAllocator.firstVacant();
      if (alias)
        return alias;
      return this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
    };
    module.exports = TopicAliasSend;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/bl/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/bl/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b2) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b2)
        return 0;
      var x2 = a.length;
      var y = b2.length;
      for (var i = 0, len = Math.min(x2, y); i < len; ++i) {
        if (a[i] !== b2[i]) {
          x2 = a[i];
          y = b2[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m2) {
      var i = b2[n];
      b2[n] = b2[m2];
      b2[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x2, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val2, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val2 === "string") {
        val2 = Buffer2.from(val2, encoding);
      }
      if (Buffer2.isBuffer(val2)) {
        if (val2.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val2, byteOffset, encoding, dir);
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val2, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val2, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val2], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val2, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val2.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val2.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val2, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val2, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val2, byteOffset, encoding) {
      return this.indexOf(val2, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val2, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val2, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val2 = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val2 += this[offset + --byteLength2] * mul;
      }
      return val2;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val2 = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val2 += this[offset + i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength2);
      return val2;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val2 = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val2 += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val2 >= mul)
        val2 -= Math.pow(2, 8 * byteLength2);
      return val2;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset] | this[offset + 1] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val2 = this[offset + 1] | this[offset] << 8;
      return val2 & 32768 ? val2 | 4294901760 : val2;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val2, start, end, encoding) {
      if (typeof val2 === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val2.length === 1) {
          var code = val2.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val2 = code;
          }
        }
      } else if (typeof val2 === "number") {
        val2 = val2 & 255;
      } else if (typeof val2 === "boolean") {
        val2 = Number(val2);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val2)
        val2 = 0;
      var i;
      if (typeof val2 === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val2;
        }
      } else {
        var bytes = Buffer2.isBuffer(val2) ? val2 : Buffer2.from(val2, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val2 + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi2, lo2;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i);
        hi2 = c2 >> 8;
        lo2 = c2 % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table;
    }();
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer2();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v2) {
          var entry = {
            data: v2,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v2) {
          var entry = {
            data: v2,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join4(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c2 = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c2;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c2 = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c2;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/bl/node_modules/readable-stream/errors-browser.js
var require_errors_browser2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base2);
      NodeError.prototype.name = Base2.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream = require_stream_browser2();
    var Buffer2 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process.nextTick(cb, er2);
    }
    function validChunk(stream, state, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er2);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er2)
        onwriteError(stream, state, sync, er2, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v2 = 0; v2 < keys.length; v2++) {
        method = keys[v2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v2;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser2();
    var Buffer2 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator2();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser2();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs2, x2) {
      for (var i = 0, l2 = xs2.length; i < l2; i++) {
        if (xs2[i] === x2)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er2, data) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform2();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from, to2) {
      return from.pipe(to2);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/bl/node_modules/readable-stream/readable-browser.js
var require_readable_browser2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable2();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable2();
    exports.Duplex = require_stream_duplex2();
    exports.Transform = require_stream_transform2();
    exports.PassThrough = require_stream_passthrough2();
    exports.finished = require_end_of_stream2();
    exports.pipeline = require_pipeline2();
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer2();
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t2 = tot + this._bufs[i].length;
        if (offset < _t2 || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t2;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l2 = this._bufs[i].length - start;
        if (bytes > l2) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l2;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l2;
          break;
        }
        bytes -= l2;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m2 in methods) {
        (function(m3) {
          if (methods[m3] === null) {
            BufferList.prototype[m3] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m3](0, byteLength);
            };
          } else {
            BufferList.prototype[m3] = function(offset = 0) {
              return this.slice(offset, offset + methods[m3])[m3](0);
            };
          }
        })(m2);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b2) {
      return b2 instanceof BufferList || BufferList.isBufferList(b2);
    };
    BufferList.isBufferList = function isBufferList(b2) {
      return b2 != null && b2[symbol];
    };
    module.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module) {
    "use strict";
    var DuplexStream = require_readable_browser2().Duplex;
    var inherits = require_inherits_browser();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = (function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b2) {
      return b2 instanceof BufferListStream || b2 instanceof BufferList || BufferListStream.isBufferList(b2);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module.exports = BufferListStream;
    module.exports.BufferListStream = BufferListStream;
    module.exports.BufferList = BufferList;
  }
});

// node_modules/mqtt-packet/packet.js
var require_packet = __commonJS({
  "node_modules/mqtt-packet/packet.js"(exports, module) {
    var Packet = class {
      constructor() {
        this.cmd = null;
        this.retain = false;
        this.qos = 0;
        this.dup = false;
        this.length = -1;
        this.topic = null;
        this.payload = null;
      }
    };
    module.exports = Packet;
  }
});

// node_modules/mqtt-packet/constants.js
var require_constants = __commonJS({
  "node_modules/mqtt-packet/constants.js"(exports, module) {
    var protocol = module.exports;
    protocol.types = {
      0: "reserved",
      1: "connect",
      2: "connack",
      3: "publish",
      4: "puback",
      5: "pubrec",
      6: "pubrel",
      7: "pubcomp",
      8: "subscribe",
      9: "suback",
      10: "unsubscribe",
      11: "unsuback",
      12: "pingreq",
      13: "pingresp",
      14: "disconnect",
      15: "auth"
    };
    protocol.codes = {};
    for (const k2 in protocol.types) {
      const v2 = protocol.types[k2];
      protocol.codes[v2] = k2;
    }
    protocol.CMD_SHIFT = 4;
    protocol.CMD_MASK = 240;
    protocol.DUP_MASK = 8;
    protocol.QOS_MASK = 3;
    protocol.QOS_SHIFT = 1;
    protocol.RETAIN_MASK = 1;
    protocol.VARBYTEINT_MASK = 127;
    protocol.VARBYTEINT_FIN_MASK = 128;
    protocol.VARBYTEINT_MAX = 268435455;
    protocol.SESSIONPRESENT_MASK = 1;
    protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);
    protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT]);
    protocol.USERNAME_MASK = 128;
    protocol.PASSWORD_MASK = 64;
    protocol.WILL_RETAIN_MASK = 32;
    protocol.WILL_QOS_MASK = 24;
    protocol.WILL_QOS_SHIFT = 3;
    protocol.WILL_FLAG_MASK = 4;
    protocol.CLEAN_SESSION_MASK = 2;
    protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT]);
    protocol.properties = {
      sessionExpiryInterval: 17,
      willDelayInterval: 24,
      receiveMaximum: 33,
      maximumPacketSize: 39,
      topicAliasMaximum: 34,
      requestResponseInformation: 25,
      requestProblemInformation: 23,
      userProperties: 38,
      authenticationMethod: 21,
      authenticationData: 22,
      payloadFormatIndicator: 1,
      messageExpiryInterval: 2,
      contentType: 3,
      responseTopic: 8,
      correlationData: 9,
      maximumQoS: 36,
      retainAvailable: 37,
      assignedClientIdentifier: 18,
      reasonString: 31,
      wildcardSubscriptionAvailable: 40,
      subscriptionIdentifiersAvailable: 41,
      sharedSubscriptionAvailable: 42,
      serverKeepAlive: 19,
      responseInformation: 26,
      serverReference: 28,
      topicAlias: 35,
      subscriptionIdentifier: 11
    };
    protocol.propertiesCodes = {};
    for (const prop in protocol.properties) {
      const id2 = protocol.properties[prop];
      protocol.propertiesCodes[id2] = prop;
    }
    protocol.propertiesTypes = {
      sessionExpiryInterval: "int32",
      willDelayInterval: "int32",
      receiveMaximum: "int16",
      maximumPacketSize: "int32",
      topicAliasMaximum: "int16",
      requestResponseInformation: "byte",
      requestProblemInformation: "byte",
      userProperties: "pair",
      authenticationMethod: "string",
      authenticationData: "binary",
      payloadFormatIndicator: "byte",
      messageExpiryInterval: "int32",
      contentType: "string",
      responseTopic: "string",
      correlationData: "binary",
      maximumQoS: "int8",
      retainAvailable: "byte",
      assignedClientIdentifier: "string",
      reasonString: "string",
      wildcardSubscriptionAvailable: "byte",
      subscriptionIdentifiersAvailable: "byte",
      sharedSubscriptionAvailable: "byte",
      serverKeepAlive: "int16",
      responseInformation: "string",
      serverReference: "string",
      topicAlias: "int16",
      subscriptionIdentifier: "var"
    };
    function genHeader(type) {
      return [0, 1, 2].map((qos) => {
        return [0, 1].map((dup) => {
          return [0, 1].map((retain) => {
            const buf = Buffer.alloc(1);
            buf.writeUInt8(
              protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain,
              0,
              true
            );
            return buf;
          });
        });
      });
    }
    protocol.PUBLISH_HEADER = genHeader("publish");
    protocol.SUBSCRIBE_HEADER = genHeader("subscribe");
    protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_NL_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
    protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
    protocol.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
    protocol.SUBSCRIBE_OPTIONS_NL = 4;
    protocol.SUBSCRIBE_OPTIONS_RAP = 8;
    protocol.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
    protocol.UNSUBSCRIBE_HEADER = genHeader("unsubscribe");
    protocol.ACKS = {
      unsuback: genHeader("unsuback"),
      puback: genHeader("puback"),
      pubcomp: genHeader("pubcomp"),
      pubrel: genHeader("pubrel"),
      pubrec: genHeader("pubrec")
    };
    protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT]);
    protocol.VERSION3 = Buffer.from([3]);
    protocol.VERSION4 = Buffer.from([4]);
    protocol.VERSION5 = Buffer.from([5]);
    protocol.VERSION131 = Buffer.from([131]);
    protocol.VERSION132 = Buffer.from([132]);
    protocol.QOS = [0, 1, 2].map((qos) => {
      return Buffer.from([qos]);
    });
    protocol.EMPTY = {
      pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),
      pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),
      disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])
    };
  }
});

// node_modules/mqtt-packet/parser.js
var require_parser = __commonJS({
  "node_modules/mqtt-packet/parser.js"(exports, module) {
    var bl2 = require_bl();
    var EventEmitter = require_events();
    var Packet = require_packet();
    var constants = require_constants();
    var debug = require_browser3()("mqtt-packet:parser");
    var Parser = class _Parser extends EventEmitter {
      constructor() {
        super();
        this.parser = this.constructor.parser;
      }
      static parser(opt) {
        if (!(this instanceof _Parser))
          return new _Parser().parser(opt);
        this.settings = opt || {};
        this._states = [
          "_parseHeader",
          "_parseLength",
          "_parsePayload",
          "_newPacket"
        ];
        this._resetState();
        return this;
      }
      _resetState() {
        debug("_resetState: resetting packet, error, _list, and _stateCounter");
        this.packet = new Packet();
        this.error = null;
        this._list = bl2();
        this._stateCounter = 0;
      }
      parse(buf) {
        if (this.error)
          this._resetState();
        this._list.append(buf);
        debug("parse: current state: %s", this._states[this._stateCounter]);
        while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {
          this._stateCounter++;
          debug("parse: state complete. _stateCounter is now: %d", this._stateCounter);
          debug("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length);
          if (this._stateCounter >= this._states.length)
            this._stateCounter = 0;
        }
        debug("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length);
        return this._list.length;
      }
      _parseHeader() {
        const zero = this._list.readUInt8(0);
        this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];
        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;
        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;
        this.packet.dup = (zero & constants.DUP_MASK) !== 0;
        debug("_parseHeader: packet: %o", this.packet);
        this._list.consume(1);
        return true;
      }
      _parseLength() {
        const result = this._parseVarByteNum(true);
        if (result) {
          this.packet.length = result.value;
          this._list.consume(result.bytes);
        }
        debug("_parseLength %d", result.value);
        return !!result;
      }
      _parsePayload() {
        debug("_parsePayload: payload %O", this._list);
        let result = false;
        if (this.packet.length === 0 || this._list.length >= this.packet.length) {
          this._pos = 0;
          switch (this.packet.cmd) {
            case "connect":
              this._parseConnect();
              break;
            case "connack":
              this._parseConnack();
              break;
            case "publish":
              this._parsePublish();
              break;
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              this._parseConfirmation();
              break;
            case "subscribe":
              this._parseSubscribe();
              break;
            case "suback":
              this._parseSuback();
              break;
            case "unsubscribe":
              this._parseUnsubscribe();
              break;
            case "unsuback":
              this._parseUnsuback();
              break;
            case "pingreq":
            case "pingresp":
              break;
            case "disconnect":
              this._parseDisconnect();
              break;
            case "auth":
              this._parseAuth();
              break;
            default:
              this._emitError(new Error("Not supported"));
          }
          result = true;
        }
        debug("_parsePayload complete result: %s", result);
        return result;
      }
      _parseConnect() {
        debug("_parseConnect");
        let topic;
        let payload;
        let password;
        let username;
        const flags = {};
        const packet = this.packet;
        const protocolId = this._parseString();
        if (protocolId === null)
          return this._emitError(new Error("Cannot parse protocolId"));
        if (protocolId !== "MQTT" && protocolId !== "MQIsdp") {
          return this._emitError(new Error("Invalid protocolId"));
        }
        packet.protocolId = protocolId;
        if (this._pos >= this._list.length)
          return this._emitError(new Error("Packet too short"));
        packet.protocolVersion = this._list.readUInt8(this._pos);
        if (packet.protocolVersion >= 128) {
          packet.bridgeMode = true;
          packet.protocolVersion = packet.protocolVersion - 128;
        }
        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
          return this._emitError(new Error("Invalid protocol version"));
        }
        this._pos++;
        if (this._pos >= this._list.length) {
          return this._emitError(new Error("Packet too short"));
        }
        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;
        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;
        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;
        if (flags.will) {
          packet.will = {};
          packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;
          packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;
        }
        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;
        this._pos++;
        packet.keepalive = this._parseNum();
        if (packet.keepalive === -1)
          return this._emitError(new Error("Packet too short"));
        if (packet.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        const clientId = this._parseString();
        if (clientId === null)
          return this._emitError(new Error("Packet too short"));
        packet.clientId = clientId;
        debug("_parseConnect: packet.clientId: %s", packet.clientId);
        if (flags.will) {
          if (packet.protocolVersion === 5) {
            const willProperties = this._parseProperties();
            if (Object.getOwnPropertyNames(willProperties).length) {
              packet.will.properties = willProperties;
            }
          }
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse will topic"));
          packet.will.topic = topic;
          debug("_parseConnect: packet.will.topic: %s", packet.will.topic);
          payload = this._parseBuffer();
          if (payload === null)
            return this._emitError(new Error("Cannot parse will payload"));
          packet.will.payload = payload;
          debug("_parseConnect: packet.will.paylaod: %s", packet.will.payload);
        }
        if (flags.username) {
          username = this._parseString();
          if (username === null)
            return this._emitError(new Error("Cannot parse username"));
          packet.username = username;
          debug("_parseConnect: packet.username: %s", packet.username);
        }
        if (flags.password) {
          password = this._parseBuffer();
          if (password === null)
            return this._emitError(new Error("Cannot parse password"));
          packet.password = password;
        }
        this.settings = packet;
        debug("_parseConnect: complete");
        return packet;
      }
      _parseConnack() {
        debug("_parseConnack");
        const packet = this.packet;
        if (this._list.length < 1)
          return null;
        packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);
        if (this.settings.protocolVersion === 5) {
          if (this._list.length >= 2) {
            packet.reasonCode = this._list.readUInt8(this._pos++);
          } else {
            packet.reasonCode = 0;
          }
        } else {
          if (this._list.length < 2)
            return null;
          packet.returnCode = this._list.readUInt8(this._pos++);
        }
        if (packet.returnCode === -1 || packet.reasonCode === -1)
          return this._emitError(new Error("Cannot parse return code"));
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseConnack: complete");
      }
      _parsePublish() {
        debug("_parsePublish");
        const packet = this.packet;
        packet.topic = this._parseString();
        if (packet.topic === null)
          return this._emitError(new Error("Cannot parse topic"));
        if (packet.qos > 0) {
          if (!this._parseMessageId()) {
            return;
          }
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        packet.payload = this._list.slice(this._pos, packet.length);
        debug("_parsePublish: payload from buffer list: %o", packet.payload);
      }
      _parseSubscribe() {
        debug("_parseSubscribe");
        const packet = this.packet;
        let topic;
        let options;
        let qos;
        let rh2;
        let rap;
        let nl2;
        let subscription;
        if (packet.qos !== 1) {
          return this._emitError(new Error("Wrong subscribe header"));
        }
        packet.subscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < packet.length) {
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          if (this._pos >= packet.length)
            return this._emitError(new Error("Malformed Subscribe Payload"));
          options = this._parseByte();
          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;
          nl2 = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;
          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;
          rh2 = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;
          subscription = { topic, qos };
          if (this.settings.protocolVersion === 5) {
            subscription.nl = nl2;
            subscription.rap = rap;
            subscription.rh = rh2;
          } else if (this.settings.bridgeMode) {
            subscription.rh = 0;
            subscription.rap = true;
            subscription.nl = true;
          }
          debug("_parseSubscribe: push subscription `%s` to subscription", subscription);
          packet.subscriptions.push(subscription);
        }
      }
      _parseSuback() {
        debug("_parseSuback");
        const packet = this.packet;
        this.packet.granted = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < this.packet.length) {
          this.packet.granted.push(this._list.readUInt8(this._pos++));
        }
      }
      _parseUnsubscribe() {
        debug("_parseUnsubscribe");
        const packet = this.packet;
        packet.unsubscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < packet.length) {
          const topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          debug("_parseUnsubscribe: push topic `%s` to unsubscriptions", topic);
          packet.unsubscriptions.push(topic);
        }
      }
      _parseUnsuback() {
        debug("_parseUnsuback");
        const packet = this.packet;
        if (!this._parseMessageId())
          return this._emitError(new Error("Cannot parse messageId"));
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
          packet.granted = [];
          while (this._pos < this.packet.length) {
            this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
      }
      // parse packets like puback, pubrec, pubrel, pubcomp
      _parseConfirmation() {
        debug("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
        const packet = this.packet;
        this._parseMessageId();
        if (this.settings.protocolVersion === 5) {
          if (packet.length > 2) {
            packet.reasonCode = this._parseByte();
            debug("_parseConfirmation: packet.reasonCode `%d`", packet.reasonCode);
          } else {
            packet.reasonCode = 0;
          }
          if (packet.length > 3) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
        }
        return true;
      }
      // parse disconnect packet
      _parseDisconnect() {
        const packet = this.packet;
        debug("_parseDisconnect");
        if (this.settings.protocolVersion === 5) {
          if (this._list.length > 0) {
            packet.reasonCode = this._parseByte();
          } else {
            packet.reasonCode = 0;
          }
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseDisconnect result: true");
        return true;
      }
      // parse auth packet
      _parseAuth() {
        debug("_parseAuth");
        const packet = this.packet;
        if (this.settings.protocolVersion !== 5) {
          return this._emitError(new Error("Not supported auth packet for this version MQTT"));
        }
        packet.reasonCode = this._parseByte();
        const properties = this._parseProperties();
        if (Object.getOwnPropertyNames(properties).length) {
          packet.properties = properties;
        }
        debug("_parseAuth: result: true");
        return true;
      }
      _parseMessageId() {
        const packet = this.packet;
        packet.messageId = this._parseNum();
        if (packet.messageId === null) {
          this._emitError(new Error("Cannot parse messageId"));
          return false;
        }
        debug("_parseMessageId: packet.messageId %d", packet.messageId);
        return true;
      }
      _parseString(maybeBuffer) {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.toString("utf8", this._pos, end);
        this._pos += length;
        debug("_parseString: result: %s", result);
        return result;
      }
      _parseStringPair() {
        debug("_parseStringPair");
        return {
          name: this._parseString(),
          value: this._parseString()
        };
      }
      _parseBuffer() {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.slice(this._pos, end);
        this._pos += length;
        debug("_parseBuffer: result: %o", result);
        return result;
      }
      _parseNum() {
        if (this._list.length - this._pos < 2)
          return -1;
        const result = this._list.readUInt16BE(this._pos);
        this._pos += 2;
        debug("_parseNum: result: %s", result);
        return result;
      }
      _parse4ByteNum() {
        if (this._list.length - this._pos < 4)
          return -1;
        const result = this._list.readUInt32BE(this._pos);
        this._pos += 4;
        debug("_parse4ByteNum: result: %s", result);
        return result;
      }
      _parseVarByteNum(fullInfoFlag) {
        debug("_parseVarByteNum");
        const maxBytes = 4;
        let bytes = 0;
        let mul = 1;
        let value = 0;
        let result = false;
        let current;
        const padding = this._pos ? this._pos : 0;
        while (bytes < maxBytes && padding + bytes < this._list.length) {
          current = this._list.readUInt8(padding + bytes++);
          value += mul * (current & constants.VARBYTEINT_MASK);
          mul *= 128;
          if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
            result = true;
            break;
          }
          if (this._list.length <= bytes) {
            break;
          }
        }
        if (!result && bytes === maxBytes && this._list.length >= bytes) {
          this._emitError(new Error("Invalid variable byte integer"));
        }
        if (padding) {
          this._pos += bytes;
        }
        result = result ? fullInfoFlag ? {
          bytes,
          value
        } : value : false;
        debug("_parseVarByteNum: result: %o", result);
        return result;
      }
      _parseByte() {
        let result;
        if (this._pos < this._list.length) {
          result = this._list.readUInt8(this._pos);
          this._pos++;
        }
        debug("_parseByte: result: %o", result);
        return result;
      }
      _parseByType(type) {
        debug("_parseByType: type: %s", type);
        switch (type) {
          case "byte": {
            return this._parseByte() !== 0;
          }
          case "int8": {
            return this._parseByte();
          }
          case "int16": {
            return this._parseNum();
          }
          case "int32": {
            return this._parse4ByteNum();
          }
          case "var": {
            return this._parseVarByteNum();
          }
          case "string": {
            return this._parseString();
          }
          case "pair": {
            return this._parseStringPair();
          }
          case "binary": {
            return this._parseBuffer();
          }
        }
      }
      _parseProperties() {
        debug("_parseProperties");
        const length = this._parseVarByteNum();
        const start = this._pos;
        const end = start + length;
        const result = {};
        while (this._pos < end) {
          const type = this._parseByte();
          if (!type) {
            this._emitError(new Error("Cannot parse property code type"));
            return false;
          }
          const name = constants.propertiesCodes[type];
          if (!name) {
            this._emitError(new Error("Unknown property"));
            return false;
          }
          if (name === "userProperties") {
            if (!result[name]) {
              result[name] = /* @__PURE__ */ Object.create(null);
            }
            const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);
            if (result[name][currentUserProperty.name]) {
              if (Array.isArray(result[name][currentUserProperty.name])) {
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              } else {
                const currentValue = result[name][currentUserProperty.name];
                result[name][currentUserProperty.name] = [currentValue];
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              }
            } else {
              result[name][currentUserProperty.name] = currentUserProperty.value;
            }
            continue;
          }
          if (result[name]) {
            if (Array.isArray(result[name])) {
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            } else {
              result[name] = [result[name]];
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            }
          } else {
            result[name] = this._parseByType(constants.propertiesTypes[name]);
          }
        }
        return result;
      }
      _newPacket() {
        debug("_newPacket");
        if (this.packet) {
          this._list.consume(this.packet.length);
          debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length);
          this.emit("packet", this.packet);
        }
        debug("_newPacket: new packet");
        this.packet = new Packet();
        this._pos = 0;
        return true;
      }
      _emitError(err) {
        debug("_emitError");
        this.error = err;
        this.emit("error", err);
      }
    };
    module.exports = Parser;
  }
});

// node_modules/mqtt-packet/numbers.js
var require_numbers = __commonJS({
  "node_modules/mqtt-packet/numbers.js"(exports, module) {
    var max = 65536;
    var cache = {};
    var SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1));
    function generateBuffer(i) {
      const buffer = Buffer.allocUnsafe(2);
      buffer.writeUInt8(i >> 8, 0);
      buffer.writeUInt8(i & 255, 0 + 1);
      return buffer;
    }
    function generateCache() {
      for (let i = 0; i < max; i++) {
        cache[i] = generateBuffer(i);
      }
    }
    function genBufVariableByteInt(num) {
      const maxLength = 4;
      let digit = 0;
      let pos = 0;
      const buffer = Buffer.allocUnsafe(maxLength);
      do {
        digit = num % 128 | 0;
        num = num / 128 | 0;
        if (num > 0)
          digit = digit | 128;
        buffer.writeUInt8(digit, pos++);
      } while (num > 0 && pos < maxLength);
      if (num > 0) {
        pos = 0;
      }
      return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);
    }
    function generate4ByteBuffer(num) {
      const buffer = Buffer.allocUnsafe(4);
      buffer.writeUInt32BE(num, 0);
      return buffer;
    }
    module.exports = {
      cache,
      generateCache,
      generateNumber: generateBuffer,
      genBufVariableByteInt,
      generate4ByteBuffer
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = process;
    }
    function nextTick(fn2, arg1, arg2, arg3) {
      if (typeof fn2 !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn2);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn2.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn2.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn2.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn2.apply(null, args);
          });
      }
    }
  }
});

// node_modules/mqtt-packet/writeToStream.js
var require_writeToStream = __commonJS({
  "node_modules/mqtt-packet/writeToStream.js"(exports, module) {
    var protocol = require_constants();
    var empty = Buffer.allocUnsafe(0);
    var zeroBuf = Buffer.from([0]);
    var numbers = require_numbers();
    var nextTick = require_process_nextick_args().nextTick;
    var debug = require_browser3()("mqtt-packet:writeToStream");
    var numCache = numbers.cache;
    var generateNumber = numbers.generateNumber;
    var generateCache = numbers.generateCache;
    var genBufVariableByteInt = numbers.genBufVariableByteInt;
    var generate4ByteBuffer = numbers.generate4ByteBuffer;
    var writeNumber = writeNumberCached;
    var toGenerate = true;
    function generate(packet, stream, opts) {
      debug("generate called");
      if (stream.cork) {
        stream.cork();
        nextTick(uncork, stream);
      }
      if (toGenerate) {
        toGenerate = false;
        generateCache();
      }
      debug("generate: packet.cmd: %s", packet.cmd);
      switch (packet.cmd) {
        case "connect":
          return connect(packet, stream, opts);
        case "connack":
          return connack(packet, stream, opts);
        case "publish":
          return publish(packet, stream, opts);
        case "puback":
        case "pubrec":
        case "pubrel":
        case "pubcomp":
          return confirmation(packet, stream, opts);
        case "subscribe":
          return subscribe(packet, stream, opts);
        case "suback":
          return suback(packet, stream, opts);
        case "unsubscribe":
          return unsubscribe(packet, stream, opts);
        case "unsuback":
          return unsuback(packet, stream, opts);
        case "pingreq":
        case "pingresp":
          return emptyPacket(packet, stream, opts);
        case "disconnect":
          return disconnect(packet, stream, opts);
        case "auth":
          return auth(packet, stream, opts);
        default:
          stream.emit("error", new Error("Unknown command"));
          return false;
      }
    }
    Object.defineProperty(generate, "cacheNumbers", {
      get() {
        return writeNumber === writeNumberCached;
      },
      set(value) {
        if (value) {
          if (!numCache || Object.keys(numCache).length === 0)
            toGenerate = true;
          writeNumber = writeNumberCached;
        } else {
          toGenerate = false;
          writeNumber = writeNumberGenerated;
        }
      }
    });
    function uncork(stream) {
      stream.uncork();
    }
    function connect(packet, stream, opts) {
      const settings = packet || {};
      const protocolId = settings.protocolId || "MQTT";
      let protocolVersion = settings.protocolVersion || 4;
      const will = settings.will;
      let clean = settings.clean;
      const keepalive = settings.keepalive || 0;
      const clientId = settings.clientId || "";
      const username = settings.username;
      const password = settings.password;
      const properties = settings.properties;
      if (clean === void 0)
        clean = true;
      let length = 0;
      if (!protocolId || typeof protocolId !== "string" && !Buffer.isBuffer(protocolId)) {
        stream.emit("error", new Error("Invalid protocolId"));
        return false;
      } else
        length += protocolId.length + 2;
      if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
        stream.emit("error", new Error("Invalid protocol version"));
        return false;
      } else
        length += 1;
      if ((typeof clientId === "string" || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {
        length += Buffer.byteLength(clientId) + 2;
      } else {
        if (protocolVersion < 4) {
          stream.emit("error", new Error("clientId must be supplied before 3.1.1"));
          return false;
        }
        if (clean * 1 === 0) {
          stream.emit("error", new Error("clientId must be given if cleanSession set to 0"));
          return false;
        }
      }
      if (typeof keepalive !== "number" || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {
        stream.emit("error", new Error("Invalid keepalive"));
        return false;
      } else
        length += 2;
      length += 1;
      if (protocolVersion === 5) {
        var propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (will) {
        if (typeof will !== "object") {
          stream.emit("error", new Error("Invalid will"));
          return false;
        }
        if (!will.topic || typeof will.topic !== "string") {
          stream.emit("error", new Error("Invalid will topic"));
          return false;
        } else {
          length += Buffer.byteLength(will.topic) + 2;
        }
        length += 2;
        if (will.payload) {
          if (will.payload.length >= 0) {
            if (typeof will.payload === "string") {
              length += Buffer.byteLength(will.payload);
            } else {
              length += will.payload.length;
            }
          } else {
            stream.emit("error", new Error("Invalid will payload"));
            return false;
          }
        }
        var willProperties = {};
        if (protocolVersion === 5) {
          willProperties = getProperties(stream, will.properties);
          if (!willProperties) {
            return false;
          }
          length += willProperties.length;
        }
      }
      let providedUsername = false;
      if (username != null) {
        if (isStringOrBuffer(username)) {
          providedUsername = true;
          length += Buffer.byteLength(username) + 2;
        } else {
          stream.emit("error", new Error("Invalid username"));
          return false;
        }
      }
      if (password != null) {
        if (!providedUsername) {
          stream.emit("error", new Error("Username is required to use password"));
          return false;
        }
        if (isStringOrBuffer(password)) {
          length += byteLength(password) + 2;
        } else {
          stream.emit("error", new Error("Invalid password"));
          return false;
        }
      }
      stream.write(protocol.CONNECT_HEADER);
      writeVarByteInt(stream, length);
      writeStringOrBuffer(stream, protocolId);
      if (settings.bridgeMode) {
        protocolVersion += 128;
      }
      stream.write(
        protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3
      );
      let flags = 0;
      flags |= username != null ? protocol.USERNAME_MASK : 0;
      flags |= password != null ? protocol.PASSWORD_MASK : 0;
      flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;
      flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;
      flags |= will ? protocol.WILL_FLAG_MASK : 0;
      flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;
      stream.write(Buffer.from([flags]));
      writeNumber(stream, keepalive);
      if (protocolVersion === 5) {
        propertiesData.write();
      }
      writeStringOrBuffer(stream, clientId);
      if (will) {
        if (protocolVersion === 5) {
          willProperties.write();
        }
        writeString(stream, will.topic);
        writeStringOrBuffer(stream, will.payload);
      }
      if (username != null) {
        writeStringOrBuffer(stream, username);
      }
      if (password != null) {
        writeStringOrBuffer(stream, password);
      }
      return true;
    }
    function connack(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const rc2 = version === 5 ? settings.reasonCode : settings.returnCode;
      const properties = settings.properties;
      let length = 2;
      if (typeof rc2 !== "number") {
        stream.emit("error", new Error("Invalid return code"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.CONNACK_HEADER);
      writeVarByteInt(stream, length);
      stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);
      stream.write(Buffer.from([rc2]));
      if (propertiesData != null) {
        propertiesData.write();
      }
      return true;
    }
    function publish(packet, stream, opts) {
      debug("publish: packet: %o", packet);
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const qos = settings.qos || 0;
      const retain = settings.retain ? protocol.RETAIN_MASK : 0;
      const topic = settings.topic;
      const payload = settings.payload || empty;
      const id2 = settings.messageId;
      const properties = settings.properties;
      let length = 0;
      if (typeof topic === "string")
        length += Buffer.byteLength(topic) + 2;
      else if (Buffer.isBuffer(topic))
        length += topic.length + 2;
      else {
        stream.emit("error", new Error("Invalid topic"));
        return false;
      }
      if (!Buffer.isBuffer(payload))
        length += Buffer.byteLength(payload);
      else
        length += payload.length;
      if (qos && typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else if (qos)
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, byteLength(topic));
      stream.write(topic);
      if (qos > 0)
        writeNumber(stream, id2);
      if (propertiesData != null) {
        propertiesData.write();
      }
      debug("publish: payload: %o", payload);
      return stream.write(payload);
    }
    function confirmation(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const type = settings.cmd || "puback";
      const id2 = settings.messageId;
      const dup = settings.dup && type === "pubrel" ? protocol.DUP_MASK : 0;
      let qos = 0;
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 3 : 2;
      if (type === "pubrel")
        qos = 1;
      if (typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        if (typeof properties === "object") {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id2);
      if (version === 5) {
        stream.write(Buffer.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    function subscribe(packet, stream, opts) {
      debug("subscribe: packet: ");
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const id2 = settings.messageId;
      const subs = settings.subscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (typeof subs === "object" && subs.length) {
        for (let i = 0; i < subs.length; i += 1) {
          const itopic = subs[i].topic;
          const iqos = subs[i].qos;
          if (typeof itopic !== "string") {
            stream.emit("error", new Error("Invalid subscriptions - invalid topic"));
            return false;
          }
          if (typeof iqos !== "number") {
            stream.emit("error", new Error("Invalid subscriptions - invalid qos"));
            return false;
          }
          if (version === 5) {
            const nl2 = subs[i].nl || false;
            if (typeof nl2 !== "boolean") {
              stream.emit("error", new Error("Invalid subscriptions - invalid No Local"));
              return false;
            }
            const rap = subs[i].rap || false;
            if (typeof rap !== "boolean") {
              stream.emit("error", new Error("Invalid subscriptions - invalid Retain as Published"));
              return false;
            }
            const rh2 = subs[i].rh || 0;
            if (typeof rh2 !== "number" || rh2 > 2) {
              stream.emit("error", new Error("Invalid subscriptions - invalid Retain Handling"));
              return false;
            }
          }
          length += Buffer.byteLength(itopic) + 2 + 1;
        }
      } else {
        stream.emit("error", new Error("Invalid subscriptions"));
        return false;
      }
      debug("subscribe: writing to stream: %o", protocol.SUBSCRIBE_HEADER);
      stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id2);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (const sub of subs) {
        const jtopic = sub.topic;
        const jqos = sub.qos;
        const jnl = +sub.nl;
        const jrap = +sub.rap;
        const jrh = sub.rh;
        let joptions;
        writeString(stream, jtopic);
        joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];
        if (version === 5) {
          joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;
          joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;
          joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;
        }
        result = stream.write(Buffer.from([joptions]));
      }
      return result;
    }
    function suback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id2 = settings.messageId;
      const granted = settings.granted;
      const properties = settings.properties;
      let length = 0;
      if (typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      if (typeof granted === "object" && granted.length) {
        for (let i = 0; i < granted.length; i += 1) {
          if (typeof granted[i] !== "number") {
            stream.emit("error", new Error("Invalid qos vector"));
            return false;
          }
          length += 1;
        }
      } else {
        stream.emit("error", new Error("Invalid qos vector"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.SUBACK_HEADER);
      writeVarByteInt(stream, length);
      writeNumber(stream, id2);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return stream.write(Buffer.from(granted));
    }
    function unsubscribe(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id2 = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const unsubs = settings.unsubscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else {
        length += 2;
      }
      if (typeof unsubs === "object" && unsubs.length) {
        for (let i = 0; i < unsubs.length; i += 1) {
          if (typeof unsubs[i] !== "string") {
            stream.emit("error", new Error("Invalid unsubscriptions"));
            return false;
          }
          length += Buffer.byteLength(unsubs[i]) + 2;
        }
      } else {
        stream.emit("error", new Error("Invalid unsubscriptions"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id2);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (let j2 = 0; j2 < unsubs.length; j2++) {
        result = writeString(stream, unsubs[j2]);
      }
      return result;
    }
    function unsuback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id2 = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const granted = settings.granted;
      const properties = settings.properties;
      const type = settings.cmd;
      const qos = 0;
      let length = 2;
      if (typeof id2 !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      }
      if (version === 5) {
        if (typeof granted === "object" && granted.length) {
          for (let i = 0; i < granted.length; i += 1) {
            if (typeof granted[i] !== "number") {
              stream.emit("error", new Error("Invalid qos vector"));
              return false;
            }
            length += 1;
          }
        } else {
          stream.emit("error", new Error("Invalid qos vector"));
          return false;
        }
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id2);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      if (version === 5) {
        stream.write(Buffer.from(granted));
      }
      return true;
    }
    function emptyPacket(packet, stream, opts) {
      return stream.write(protocol.EMPTY[packet.cmd]);
    }
    function disconnect(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(Buffer.from([protocol.codes.disconnect << 4]));
      writeVarByteInt(stream, length);
      if (version === 5) {
        stream.write(Buffer.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    function auth(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      if (version !== 5)
        stream.emit("error", new Error("Invalid mqtt version for auth packet"));
      const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
      if (!propertiesData) {
        return false;
      }
      length += propertiesData.length;
      stream.write(Buffer.from([protocol.codes.auth << 4]));
      writeVarByteInt(stream, length);
      stream.write(Buffer.from([reasonCode]));
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    var varByteIntCache = {};
    function writeVarByteInt(stream, num) {
      if (num > protocol.VARBYTEINT_MAX) {
        stream.emit("error", new Error(`Invalid variable byte integer: ${num}`));
        return false;
      }
      let buffer = varByteIntCache[num];
      if (!buffer) {
        buffer = genBufVariableByteInt(num);
        if (num < 16384)
          varByteIntCache[num] = buffer;
      }
      debug("writeVarByteInt: writing to stream: %o", buffer);
      return stream.write(buffer);
    }
    function writeString(stream, string) {
      const strlen = Buffer.byteLength(string);
      writeNumber(stream, strlen);
      debug("writeString: %s", string);
      return stream.write(string, "utf8");
    }
    function writeStringPair(stream, name, value) {
      writeString(stream, name);
      writeString(stream, value);
    }
    function writeNumberCached(stream, number) {
      debug("writeNumberCached: number: %d", number);
      debug("writeNumberCached: %o", numCache[number]);
      return stream.write(numCache[number]);
    }
    function writeNumberGenerated(stream, number) {
      const generatedNumber = generateNumber(number);
      debug("writeNumberGenerated: %o", generatedNumber);
      return stream.write(generatedNumber);
    }
    function write4ByteNumber(stream, number) {
      const generated4ByteBuffer = generate4ByteBuffer(number);
      debug("write4ByteNumber: %o", generated4ByteBuffer);
      return stream.write(generated4ByteBuffer);
    }
    function writeStringOrBuffer(stream, toWrite) {
      if (typeof toWrite === "string") {
        writeString(stream, toWrite);
      } else if (toWrite) {
        writeNumber(stream, toWrite.length);
        stream.write(toWrite);
      } else
        writeNumber(stream, 0);
    }
    function getProperties(stream, properties) {
      if (typeof properties !== "object" || properties.length != null) {
        return {
          length: 1,
          write() {
            writeProperties(stream, {}, 0);
          }
        };
      }
      let propertiesLength = 0;
      function getLengthProperty(name, value) {
        const type = protocol.propertiesTypes[name];
        let length = 0;
        switch (type) {
          case "byte": {
            if (typeof value !== "boolean") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "int8": {
            if (typeof value !== "number" || value < 0 || value > 255) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "binary": {
            if (value && value === null) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + Buffer.byteLength(value) + 2;
            break;
          }
          case "int16": {
            if (typeof value !== "number" || value < 0 || value > 65535) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2;
            break;
          }
          case "int32": {
            if (typeof value !== "number" || value < 0 || value > 4294967295) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 4;
            break;
          }
          case "var": {
            if (typeof value !== "number" || value < 0 || value > 268435455) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + Buffer.byteLength(genBufVariableByteInt(value));
            break;
          }
          case "string": {
            if (typeof value !== "string") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2 + Buffer.byteLength(value.toString());
            break;
          }
          case "pair": {
            if (typeof value !== "object") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += Object.getOwnPropertyNames(value).reduce((result, name2) => {
              const currentValue = value[name2];
              if (Array.isArray(currentValue)) {
                result += currentValue.reduce((currentLength, value2) => {
                  currentLength += 1 + 2 + Buffer.byteLength(name2.toString()) + 2 + Buffer.byteLength(value2.toString());
                  return currentLength;
                }, 0);
              } else {
                result += 1 + 2 + Buffer.byteLength(name2.toString()) + 2 + Buffer.byteLength(value[name2].toString());
              }
              return result;
            }, 0);
            break;
          }
          default: {
            stream.emit("error", new Error(`Invalid property ${name}: ${value}`));
            return false;
          }
        }
        return length;
      }
      if (properties) {
        for (const propName in properties) {
          let propLength = 0;
          let propValueLength = 0;
          const propValue = properties[propName];
          if (Array.isArray(propValue)) {
            for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
              propValueLength = getLengthProperty(propName, propValue[valueIndex]);
              if (!propValueLength) {
                return false;
              }
              propLength += propValueLength;
            }
          } else {
            propValueLength = getLengthProperty(propName, propValue);
            if (!propValueLength) {
              return false;
            }
            propLength = propValueLength;
          }
          if (!propLength)
            return false;
          propertiesLength += propLength;
        }
      }
      const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));
      return {
        length: propertiesLengthLength + propertiesLength,
        write() {
          writeProperties(stream, properties, propertiesLength);
        }
      };
    }
    function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {
      const mayEmptyProps = ["reasonString", "userProperties"];
      const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;
      let propertiesData = getProperties(stream, properties);
      if (maximumPacketSize) {
        while (length + propertiesData.length > maximumPacketSize) {
          const currentMayEmptyProp = mayEmptyProps.shift();
          if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
            delete properties[currentMayEmptyProp];
            propertiesData = getProperties(stream, properties);
          } else {
            return false;
          }
        }
      }
      return propertiesData;
    }
    function writeProperty(stream, propName, value) {
      const type = protocol.propertiesTypes[propName];
      switch (type) {
        case "byte": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          stream.write(Buffer.from([+value]));
          break;
        }
        case "int8": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          stream.write(Buffer.from([value]));
          break;
        }
        case "binary": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          writeStringOrBuffer(stream, value);
          break;
        }
        case "int16": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          writeNumber(stream, value);
          break;
        }
        case "int32": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          write4ByteNumber(stream, value);
          break;
        }
        case "var": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          writeVarByteInt(stream, value);
          break;
        }
        case "string": {
          stream.write(Buffer.from([protocol.properties[propName]]));
          writeString(stream, value);
          break;
        }
        case "pair": {
          Object.getOwnPropertyNames(value).forEach((name) => {
            const currentValue = value[name];
            if (Array.isArray(currentValue)) {
              currentValue.forEach((value2) => {
                stream.write(Buffer.from([protocol.properties[propName]]));
                writeStringPair(stream, name.toString(), value2.toString());
              });
            } else {
              stream.write(Buffer.from([protocol.properties[propName]]));
              writeStringPair(stream, name.toString(), currentValue.toString());
            }
          });
          break;
        }
        default: {
          stream.emit("error", new Error(`Invalid property ${propName} value: ${value}`));
          return false;
        }
      }
    }
    function writeProperties(stream, properties, propertiesLength) {
      writeVarByteInt(stream, propertiesLength);
      for (const propName in properties) {
        if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
          const value = properties[propName];
          if (Array.isArray(value)) {
            for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
              writeProperty(stream, propName, value[valueIndex]);
            }
          } else {
            writeProperty(stream, propName, value);
          }
        }
      }
    }
    function byteLength(bufOrString) {
      if (!bufOrString)
        return 0;
      else if (bufOrString instanceof Buffer)
        return bufOrString.length;
      else
        return Buffer.byteLength(bufOrString);
    }
    function isStringOrBuffer(field) {
      return typeof field === "string" || field instanceof Buffer;
    }
    module.exports = generate;
  }
});

// node_modules/mqtt-packet/generate.js
var require_generate = __commonJS({
  "node_modules/mqtt-packet/generate.js"(exports, module) {
    var writeToStream = require_writeToStream();
    var EventEmitter = require_events();
    function generate(packet, opts) {
      const stream = new Accumulator();
      writeToStream(packet, stream, opts);
      return stream.concat();
    }
    var Accumulator = class extends EventEmitter {
      constructor() {
        super();
        this._array = new Array(20);
        this._i = 0;
      }
      write(chunk) {
        this._array[this._i++] = chunk;
        return true;
      }
      concat() {
        let length = 0;
        const lengths = new Array(this._array.length);
        const list = this._array;
        let pos = 0;
        let i;
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string")
            lengths[i] = list[i].length;
          else
            lengths[i] = Buffer.byteLength(list[i]);
          length += lengths[i];
        }
        const result = Buffer.allocUnsafe(length);
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string") {
            list[i].copy(result, pos);
            pos += lengths[i];
          } else {
            result.write(list[i], pos);
            pos += lengths[i];
          }
        }
        return result;
      }
    };
    module.exports = generate;
  }
});

// node_modules/mqtt-packet/mqtt.js
var require_mqtt = __commonJS({
  "node_modules/mqtt-packet/mqtt.js"(exports) {
    exports.parser = require_parser().parser;
    exports.generate = require_generate();
    exports.writeToStream = require_writeToStream();
  }
});

// node_modules/mqtt/lib/default-message-id-provider.js
var require_default_message_id_provider = __commonJS({
  "node_modules/mqtt/lib/default-message-id-provider.js"(exports, module) {
    "use strict";
    function DefaultMessageIdProvider() {
      if (!(this instanceof DefaultMessageIdProvider)) {
        return new DefaultMessageIdProvider();
      }
      this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
    }
    DefaultMessageIdProvider.prototype.allocate = function() {
      const id2 = this.nextId++;
      if (this.nextId === 65536) {
        this.nextId = 1;
      }
      return id2;
    };
    DefaultMessageIdProvider.prototype.getLastAllocated = function() {
      return this.nextId === 1 ? 65535 : this.nextId - 1;
    };
    DefaultMessageIdProvider.prototype.register = function(messageId) {
      return true;
    };
    DefaultMessageIdProvider.prototype.deallocate = function(messageId) {
    };
    DefaultMessageIdProvider.prototype.clear = function() {
    };
    module.exports = DefaultMessageIdProvider;
  }
});

// node_modules/reinterval/index.js
var require_reinterval = __commonJS({
  "node_modules/reinterval/index.js"(exports, module) {
    "use strict";
    function ReInterval(callback, interval, args) {
      var self2 = this;
      this._callback = callback;
      this._args = args;
      this._interval = setInterval(callback, interval, this._args);
      this.reschedule = function(interval2) {
        if (!interval2)
          interval2 = self2._interval;
        if (self2._interval)
          clearInterval(self2._interval);
        self2._interval = setInterval(self2._callback, interval2, self2._args);
      };
      this.clear = function() {
        if (self2._interval) {
          clearInterval(self2._interval);
          self2._interval = void 0;
        }
      };
      this.destroy = function() {
        if (self2._interval) {
          clearInterval(self2._interval);
        }
        self2._callback = void 0;
        self2._interval = void 0;
        self2._args = void 0;
      };
    }
    function reInterval() {
      if (typeof arguments[0] !== "function")
        throw new Error("callback needed");
      if (typeof arguments[1] !== "number")
        throw new Error("interval needed");
      var args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new ReInterval(arguments[0], arguments[1], args);
    }
    module.exports = reInterval;
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    module.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn2) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k2 = keys[i];
          var cur = a[k2];
          if (typeof cur !== "object" || cur === null) {
            a2[k2] = cur;
          } else if (cur instanceof Date) {
            a2[k2] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k2] = copyBuffer(cur);
          } else {
            a2[k2] = fn2(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k2 in o) {
          if (Object.hasOwnProperty.call(o, k2) === false)
            continue;
          var cur = o[k2];
          if (typeof cur !== "object" || cur === null) {
            o2[k2] = cur;
          } else if (cur instanceof Date) {
            o2[k2] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k2] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k2] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k2] = copyBuffer(cur);
          } else {
            o2[k2] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k2 in o) {
          var cur = o[k2];
          if (typeof cur !== "object" || cur === null) {
            o2[k2] = cur;
          } else if (cur instanceof Date) {
            o2[k2] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k2] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k2] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k2] = copyBuffer(cur);
          } else {
            o2[k2] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn2) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k2 = keys[i];
          var cur = a[k2];
          if (typeof cur !== "object" || cur === null) {
            a2[k2] = cur;
          } else if (cur instanceof Date) {
            a2[k2] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k2] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k2] = refsNew[index];
            } else {
              a2[k2] = fn2(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k2 in o) {
          if (Object.hasOwnProperty.call(o, k2) === false)
            continue;
          var cur = o[k2];
          if (typeof cur !== "object" || cur === null) {
            o2[k2] = cur;
          } else if (cur instanceof Date) {
            o2[k2] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k2] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k2] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k2] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k2] = refsNew[i];
            } else {
              o2[k2] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k2 in o) {
          var cur = o[k2];
          if (typeof cur !== "object" || cur === null) {
            o2[k2] = cur;
          } else if (cur instanceof Date) {
            o2[k2] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k2] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k2] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k2] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k2] = refsNew[i];
            } else {
              o2[k2] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports, module) {
    "use strict";
    module.exports = require_rfdc()();
  }
});

// node_modules/mqtt/lib/validations.js
var require_validations = __commonJS({
  "node_modules/mqtt/lib/validations.js"(exports, module) {
    "use strict";
    function validateTopic(topic) {
      const parts = topic.split("/");
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] === "+") {
          continue;
        }
        if (parts[i] === "#") {
          return i === parts.length - 1;
        }
        if (parts[i].indexOf("+") !== -1 || parts[i].indexOf("#") !== -1) {
          return false;
        }
      }
      return true;
    }
    function validateTopics(topics) {
      if (topics.length === 0) {
        return "empty_topic_list";
      }
      for (let i = 0; i < topics.length; i++) {
        if (!validateTopic(topics[i])) {
          return topics[i];
        }
      }
      return null;
    }
    module.exports = {
      validateTopics
    };
  }
});

// node_modules/mqtt/lib/client.js
var require_client = __commonJS({
  "node_modules/mqtt/lib/client.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    var Store = require_store();
    var TopicAliasRecv = require_topic_alias_recv();
    var TopicAliasSend = require_topic_alias_send();
    var mqttPacket = require_mqtt();
    var DefaultMessageIdProvider = require_default_message_id_provider();
    var Writable = require_readable_browser().Writable;
    var inherits = require_inherits_browser();
    var reInterval = require_reinterval();
    var clone = require_default();
    var validations = require_validations();
    var xtend = require_immutable();
    var debug = require_browser3()("mqttjs:client");
    var nextTick = process ? process.nextTick : function(callback) {
      setTimeout(callback, 0);
    };
    var setImmediate2 = global.setImmediate || function(callback) {
      nextTick(callback);
    };
    var defaultConnectOptions = {
      keepalive: 60,
      reschedulePings: true,
      protocolId: "MQTT",
      protocolVersion: 4,
      reconnectPeriod: 1e3,
      connectTimeout: 30 * 1e3,
      clean: true,
      resubscribe: true
    };
    var errors = {
      0: "",
      1: "Unacceptable protocol version",
      2: "Identifier rejected",
      3: "Server unavailable",
      4: "Bad username or password",
      5: "Not authorized",
      16: "No matching subscribers",
      17: "No subscription existed",
      128: "Unspecified error",
      129: "Malformed Packet",
      130: "Protocol Error",
      131: "Implementation specific error",
      132: "Unsupported Protocol Version",
      133: "Client Identifier not valid",
      134: "Bad User Name or Password",
      135: "Not authorized",
      136: "Server unavailable",
      137: "Server busy",
      138: "Banned",
      139: "Server shutting down",
      140: "Bad authentication method",
      141: "Keep Alive timeout",
      142: "Session taken over",
      143: "Topic Filter invalid",
      144: "Topic Name invalid",
      145: "Packet identifier in use",
      146: "Packet Identifier not found",
      147: "Receive Maximum exceeded",
      148: "Topic Alias invalid",
      149: "Packet too large",
      150: "Message rate too high",
      151: "Quota exceeded",
      152: "Administrative action",
      153: "Payload format invalid",
      154: "Retain not supported",
      155: "QoS not supported",
      156: "Use another server",
      157: "Server moved",
      158: "Shared Subscriptions not supported",
      159: "Connection rate exceeded",
      160: "Maximum connect time",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    function defaultId() {
      return "mqttjs_" + Math.random().toString(16).substr(2, 8);
    }
    function applyTopicAlias(client, packet) {
      if (client.options.protocolVersion === 5) {
        if (packet.cmd === "publish") {
          let alias;
          if (packet.properties) {
            alias = packet.properties.topicAlias;
          }
          const topic = packet.topic.toString();
          if (client.topicAliasSend) {
            if (alias) {
              if (topic.length !== 0) {
                debug("applyTopicAlias :: register topic: %s - alias: %d", topic, alias);
                if (!client.topicAliasSend.put(topic, alias)) {
                  debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                  return new Error("Sending Topic Alias out of range");
                }
              }
            } else {
              if (topic.length !== 0) {
                if (client.options.autoAssignTopicAlias) {
                  alias = client.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", topic, alias);
                  } else {
                    alias = client.topicAliasSend.getLruAlias();
                    client.topicAliasSend.put(topic, alias);
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto assign topic: %s - alias: %d", topic, alias);
                  }
                } else if (client.options.autoUseTopicAlias) {
                  alias = client.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto use topic: %s - alias: %d", topic, alias);
                  }
                }
              }
            }
          } else if (alias) {
            debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
            return new Error("Sending Topic Alias out of range");
          }
        }
      }
    }
    function removeTopicAliasAndRecoverTopicName(client, packet) {
      let alias;
      if (packet.properties) {
        alias = packet.properties.topicAlias;
      }
      let topic = packet.topic.toString();
      if (topic.length === 0) {
        if (typeof alias === "undefined") {
          return new Error("Unregistered Topic Alias");
        } else {
          topic = client.topicAliasSend.getTopicByAlias(alias);
          if (typeof topic === "undefined") {
            return new Error("Unregistered Topic Alias");
          } else {
            packet.topic = topic;
          }
        }
      }
      if (alias) {
        delete packet.properties.topicAlias;
      }
    }
    function sendPacket(client, packet, cb) {
      debug("sendPacket :: packet: %O", packet);
      debug("sendPacket :: emitting `packetsend`");
      client.emit("packetsend", packet);
      debug("sendPacket :: writing to stream");
      const result = mqttPacket.writeToStream(packet, client.stream, client.options);
      debug("sendPacket :: writeToStream result %s", result);
      if (!result && cb && cb !== nop) {
        debug("sendPacket :: handle events on `drain` once through callback.");
        client.stream.once("drain", cb);
      } else if (cb) {
        debug("sendPacket :: invoking cb");
        cb();
      }
    }
    function flush(queue) {
      if (queue) {
        debug("flush: queue exists? %b", !!queue);
        Object.keys(queue).forEach(function(messageId) {
          if (typeof queue[messageId].cb === "function") {
            queue[messageId].cb(new Error("Connection closed"));
            delete queue[messageId];
          }
        });
      }
    }
    function flushVolatile(queue) {
      if (queue) {
        debug("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function");
        Object.keys(queue).forEach(function(messageId) {
          if (queue[messageId].volatile && typeof queue[messageId].cb === "function") {
            queue[messageId].cb(new Error("Connection closed"));
            delete queue[messageId];
          }
        });
      }
    }
    function storeAndSend(client, packet, cb, cbStorePut) {
      debug("storeAndSend :: store packet with cmd %s to outgoingStore", packet.cmd);
      let storePacket = packet;
      let err;
      if (storePacket.cmd === "publish") {
        storePacket = clone(packet);
        err = removeTopicAliasAndRecoverTopicName(client, storePacket);
        if (err) {
          return cb && cb(err);
        }
      }
      client.outgoingStore.put(storePacket, function storedPacket(err2) {
        if (err2) {
          return cb && cb(err2);
        }
        cbStorePut();
        sendPacket(client, packet, cb);
      });
    }
    function nop(error) {
      debug("nop ::", error);
    }
    function MqttClient(streamBuilder, options) {
      let k2;
      const that = this;
      if (!(this instanceof MqttClient)) {
        return new MqttClient(streamBuilder, options);
      }
      this.options = options || {};
      for (k2 in defaultConnectOptions) {
        if (typeof this.options[k2] === "undefined") {
          this.options[k2] = defaultConnectOptions[k2];
        } else {
          this.options[k2] = options[k2];
        }
      }
      debug("MqttClient :: options.protocol", options.protocol);
      debug("MqttClient :: options.protocolVersion", options.protocolVersion);
      debug("MqttClient :: options.username", options.username);
      debug("MqttClient :: options.keepalive", options.keepalive);
      debug("MqttClient :: options.reconnectPeriod", options.reconnectPeriod);
      debug("MqttClient :: options.rejectUnauthorized", options.rejectUnauthorized);
      debug("MqttClient :: options.topicAliasMaximum", options.topicAliasMaximum);
      this.options.clientId = typeof options.clientId === "string" ? options.clientId : defaultId();
      debug("MqttClient :: clientId", this.options.clientId);
      this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function() {
        arguments[3](0);
      };
      this.streamBuilder = streamBuilder;
      this.messageIdProvider = typeof this.options.messageIdProvider === "undefined" ? new DefaultMessageIdProvider() : this.options.messageIdProvider;
      this.outgoingStore = options.outgoingStore || new Store();
      this.incomingStore = options.incomingStore || new Store();
      this.queueQoSZero = options.queueQoSZero === void 0 ? true : options.queueQoSZero;
      this._resubscribeTopics = {};
      this.messageIdToTopic = {};
      this.pingTimer = null;
      this.connected = false;
      this.disconnecting = false;
      this.queue = [];
      this.connackTimer = null;
      this.reconnectTimer = null;
      this._storeProcessing = false;
      this._packetIdsDuringStoreProcessing = {};
      this._storeProcessingQueue = [];
      this.outgoing = {};
      this._firstConnection = true;
      if (options.topicAliasMaximum > 0) {
        if (options.topicAliasMaximum > 65535) {
          debug("MqttClient :: options.topicAliasMaximum is out of range");
        } else {
          this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);
        }
      }
      this.on("connect", function() {
        const queue = this.queue;
        function deliver() {
          const entry = queue.shift();
          debug("deliver :: entry %o", entry);
          let packet = null;
          if (!entry) {
            that._resubscribe();
            return;
          }
          packet = entry.packet;
          debug("deliver :: call _sendPacket for %o", packet);
          let send = true;
          if (packet.messageId && packet.messageId !== 0) {
            if (!that.messageIdProvider.register(packet.messageId)) {
              send = false;
            }
          }
          if (send) {
            that._sendPacket(
              packet,
              function(err) {
                if (entry.cb) {
                  entry.cb(err);
                }
                deliver();
              }
            );
          } else {
            debug("messageId: %d has already used. The message is skipped and removed.", packet.messageId);
            deliver();
          }
        }
        debug("connect :: sending queued packets");
        deliver();
      });
      this.on("close", function() {
        debug("close :: connected set to `false`");
        this.connected = false;
        debug("close :: clearing connackTimer");
        clearTimeout(this.connackTimer);
        debug("close :: clearing ping timer");
        if (that.pingTimer !== null) {
          that.pingTimer.clear();
          that.pingTimer = null;
        }
        if (this.topicAliasRecv) {
          this.topicAliasRecv.clear();
        }
        debug("close :: calling _setupReconnect");
        this._setupReconnect();
      });
      EventEmitter.call(this);
      debug("MqttClient :: setting up stream");
      this._setupStream();
    }
    inherits(MqttClient, EventEmitter);
    MqttClient.prototype._setupStream = function() {
      const that = this;
      const writable = new Writable();
      const parser = mqttPacket.parser(this.options);
      let completeParse = null;
      const packets = [];
      debug("_setupStream :: calling method to clear reconnect");
      this._clearReconnect();
      debug("_setupStream :: using streamBuilder provided to client to create stream");
      this.stream = this.streamBuilder(this);
      parser.on("packet", function(packet) {
        debug("parser :: on packet push to packets array.");
        packets.push(packet);
      });
      function nextTickWork() {
        if (packets.length) {
          nextTick(work);
        } else {
          const done = completeParse;
          completeParse = null;
          done();
        }
      }
      function work() {
        debug("work :: getting next packet in queue");
        const packet = packets.shift();
        if (packet) {
          debug("work :: packet pulled from queue");
          that._handlePacket(packet, nextTickWork);
        } else {
          debug("work :: no packets in queue");
          const done = completeParse;
          completeParse = null;
          debug("work :: done flag is %s", !!done);
          if (done)
            done();
        }
      }
      writable._write = function(buf, enc, done) {
        completeParse = done;
        debug("writable stream :: parsing buffer");
        parser.parse(buf);
        work();
      };
      function streamErrorHandler(error) {
        debug("streamErrorHandler :: error", error.message);
        if (error.code) {
          debug("streamErrorHandler :: emitting error");
          that.emit("error", error);
        } else {
          nop(error);
        }
      }
      debug("_setupStream :: pipe stream to writable stream");
      this.stream.pipe(writable);
      this.stream.on("error", streamErrorHandler);
      this.stream.on("close", function() {
        debug("(%s)stream :: on close", that.options.clientId);
        flushVolatile(that.outgoing);
        debug("stream: emit close to MqttClient");
        that.emit("close");
      });
      debug("_setupStream: sending packet `connect`");
      const connectPacket = Object.create(this.options);
      connectPacket.cmd = "connect";
      if (this.topicAliasRecv) {
        if (!connectPacket.properties) {
          connectPacket.properties = {};
        }
        if (this.topicAliasRecv) {
          connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;
        }
      }
      sendPacket(this, connectPacket);
      parser.on("error", this.emit.bind(this, "error"));
      if (this.options.properties) {
        if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
          that.end(() => this.emit(
            "error",
            new Error("Packet has no Authentication Method")
          ));
          return this;
        }
        if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === "object") {
          const authPacket = xtend({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
          sendPacket(this, authPacket);
        }
      }
      this.stream.setMaxListeners(1e3);
      clearTimeout(this.connackTimer);
      this.connackTimer = setTimeout(function() {
        debug("!!connectTimeout hit!! Calling _cleanUp with force `true`");
        that._cleanUp(true);
      }, this.options.connectTimeout);
    };
    MqttClient.prototype._handlePacket = function(packet, done) {
      const options = this.options;
      if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
        this.emit("error", new Error("exceeding packets size " + packet.cmd));
        this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } });
        return this;
      }
      debug("_handlePacket :: emitting packetreceive");
      this.emit("packetreceive", packet);
      switch (packet.cmd) {
        case "publish":
          this._handlePublish(packet, done);
          break;
        case "puback":
        case "pubrec":
        case "pubcomp":
        case "suback":
        case "unsuback":
          this._handleAck(packet);
          done();
          break;
        case "pubrel":
          this._handlePubrel(packet, done);
          break;
        case "connack":
          this._handleConnack(packet);
          done();
          break;
        case "auth":
          this._handleAuth(packet);
          done();
          break;
        case "pingresp":
          this._handlePingresp(packet);
          done();
          break;
        case "disconnect":
          this._handleDisconnect(packet);
          done();
          break;
        default:
          break;
      }
    };
    MqttClient.prototype._checkDisconnecting = function(callback) {
      if (this.disconnecting) {
        if (callback && callback !== nop) {
          callback(new Error("client disconnecting"));
        } else {
          this.emit("error", new Error("client disconnecting"));
        }
      }
      return this.disconnecting;
    };
    MqttClient.prototype.publish = function(topic, message, opts, callback) {
      debug("publish :: message `%s` to topic `%s`", message, topic);
      const options = this.options;
      if (typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      const defaultOpts = { qos: 0, retain: false, dup: false };
      opts = xtend(defaultOpts, opts);
      if (this._checkDisconnecting(callback)) {
        return this;
      }
      const that = this;
      const publishProc = function() {
        let messageId = 0;
        if (opts.qos === 1 || opts.qos === 2) {
          messageId = that._nextId();
          if (messageId === null) {
            debug("No messageId left");
            return false;
          }
        }
        const packet = {
          cmd: "publish",
          topic,
          payload: message,
          qos: opts.qos,
          retain: opts.retain,
          messageId,
          dup: opts.dup
        };
        if (options.protocolVersion === 5) {
          packet.properties = opts.properties;
        }
        debug("publish :: qos", opts.qos);
        switch (opts.qos) {
          case 1:
          case 2:
            that.outgoing[packet.messageId] = {
              volatile: false,
              cb: callback || nop
            };
            debug("MqttClient:publish: packet cmd: %s", packet.cmd);
            that._sendPacket(packet, void 0, opts.cbStorePut);
            break;
          default:
            debug("MqttClient:publish: packet cmd: %s", packet.cmd);
            that._sendPacket(packet, callback, opts.cbStorePut);
            break;
        }
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: publishProc,
            cbStorePut: opts.cbStorePut,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.subscribe = function() {
      const that = this;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      const subs = [];
      let obj = args.shift();
      const resubscribe = obj.resubscribe;
      let callback = args.pop() || nop;
      let opts = args.pop();
      const version = this.options.protocolVersion;
      delete obj.resubscribe;
      if (typeof obj === "string") {
        obj = [obj];
      }
      if (typeof callback !== "function") {
        opts = callback;
        callback = nop;
      }
      const invalidTopic = validations.validateTopics(obj);
      if (invalidTopic !== null) {
        setImmediate2(callback, new Error("Invalid topic " + invalidTopic));
        return this;
      }
      if (this._checkDisconnecting(callback)) {
        debug("subscribe: discconecting true");
        return this;
      }
      const defaultOpts = {
        qos: 0
      };
      if (version === 5) {
        defaultOpts.nl = false;
        defaultOpts.rap = false;
        defaultOpts.rh = 0;
      }
      opts = xtend(defaultOpts, opts);
      if (Array.isArray(obj)) {
        obj.forEach(function(topic) {
          debug("subscribe: array topic %s", topic);
          if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {
            const currentOpts = {
              topic,
              qos: opts.qos
            };
            if (version === 5) {
              currentOpts.nl = opts.nl;
              currentOpts.rap = opts.rap;
              currentOpts.rh = opts.rh;
              currentOpts.properties = opts.properties;
            }
            debug("subscribe: pushing topic `%s` and qos `%s` to subs list", currentOpts.topic, currentOpts.qos);
            subs.push(currentOpts);
          }
        });
      } else {
        Object.keys(obj).forEach(function(k2) {
          debug("subscribe: object topic %s", k2);
          if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k2) || that._resubscribeTopics[k2].qos < obj[k2].qos || resubscribe) {
            const currentOpts = {
              topic: k2,
              qos: obj[k2].qos
            };
            if (version === 5) {
              currentOpts.nl = obj[k2].nl;
              currentOpts.rap = obj[k2].rap;
              currentOpts.rh = obj[k2].rh;
              currentOpts.properties = opts.properties;
            }
            debug("subscribe: pushing `%s` to subs list", currentOpts);
            subs.push(currentOpts);
          }
        });
      }
      if (!subs.length) {
        callback(null, []);
        return this;
      }
      const subscribeProc = function() {
        const messageId = that._nextId();
        if (messageId === null) {
          debug("No messageId left");
          return false;
        }
        const packet = {
          cmd: "subscribe",
          subscriptions: subs,
          qos: 1,
          retain: false,
          dup: false,
          messageId
        };
        if (opts.properties) {
          packet.properties = opts.properties;
        }
        if (that.options.resubscribe) {
          debug("subscribe :: resubscribe true");
          const topics = [];
          subs.forEach(function(sub) {
            if (that.options.reconnectPeriod > 0) {
              const topic = { qos: sub.qos };
              if (version === 5) {
                topic.nl = sub.nl || false;
                topic.rap = sub.rap || false;
                topic.rh = sub.rh || 0;
                topic.properties = sub.properties;
              }
              that._resubscribeTopics[sub.topic] = topic;
              topics.push(sub.topic);
            }
          });
          that.messageIdToTopic[packet.messageId] = topics;
        }
        that.outgoing[packet.messageId] = {
          volatile: true,
          cb: function(err, packet2) {
            if (!err) {
              const granted = packet2.granted;
              for (let i = 0; i < granted.length; i += 1) {
                subs[i].qos = granted[i];
              }
            }
            callback(err, subs);
          }
        };
        debug("subscribe :: call _sendPacket");
        that._sendPacket(packet);
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: subscribeProc,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.unsubscribe = function() {
      const that = this;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      let topic = args.shift();
      let callback = args.pop() || nop;
      let opts = args.pop();
      if (typeof topic === "string") {
        topic = [topic];
      }
      if (typeof callback !== "function") {
        opts = callback;
        callback = nop;
      }
      const invalidTopic = validations.validateTopics(topic);
      if (invalidTopic !== null) {
        setImmediate2(callback, new Error("Invalid topic " + invalidTopic));
        return this;
      }
      if (that._checkDisconnecting(callback)) {
        return this;
      }
      const unsubscribeProc = function() {
        const messageId = that._nextId();
        if (messageId === null) {
          debug("No messageId left");
          return false;
        }
        const packet = {
          cmd: "unsubscribe",
          qos: 1,
          messageId
        };
        if (typeof topic === "string") {
          packet.unsubscriptions = [topic];
        } else if (Array.isArray(topic)) {
          packet.unsubscriptions = topic;
        }
        if (that.options.resubscribe) {
          packet.unsubscriptions.forEach(function(topic2) {
            delete that._resubscribeTopics[topic2];
          });
        }
        if (typeof opts === "object" && opts.properties) {
          packet.properties = opts.properties;
        }
        that.outgoing[packet.messageId] = {
          volatile: true,
          cb: callback
        };
        debug("unsubscribe: call _sendPacket");
        that._sendPacket(packet);
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: unsubscribeProc,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.end = function(force, opts, cb) {
      const that = this;
      debug("end :: (%s)", this.options.clientId);
      if (force == null || typeof force !== "boolean") {
        cb = opts || nop;
        opts = force;
        force = false;
        if (typeof opts !== "object") {
          cb = opts;
          opts = null;
          if (typeof cb !== "function") {
            cb = nop;
          }
        }
      }
      if (typeof opts !== "object") {
        cb = opts;
        opts = null;
      }
      debug("end :: cb? %s", !!cb);
      cb = cb || nop;
      function closeStores() {
        debug("end :: closeStores: closing incoming and outgoing stores");
        that.disconnected = true;
        that.incomingStore.close(function(e1) {
          that.outgoingStore.close(function(e2) {
            debug("end :: closeStores: emitting end");
            that.emit("end");
            if (cb) {
              const err = e1 || e2;
              debug("end :: closeStores: invoking callback with args");
              cb(err);
            }
          });
        });
        if (that._deferredReconnect) {
          that._deferredReconnect();
        }
      }
      function finish() {
        debug("end :: (%s) :: finish :: calling _cleanUp with force %s", that.options.clientId, force);
        that._cleanUp(force, () => {
          debug("end :: finish :: calling process.nextTick on closeStores");
          nextTick(closeStores.bind(that));
        }, opts);
      }
      if (this.disconnecting) {
        cb();
        return this;
      }
      this._clearReconnect();
      this.disconnecting = true;
      if (!force && Object.keys(this.outgoing).length > 0) {
        debug("end :: (%s) :: calling finish in 10ms once outgoing is empty", that.options.clientId);
        this.once("outgoingEmpty", setTimeout.bind(null, finish, 10));
      } else {
        debug("end :: (%s) :: immediately calling finish", that.options.clientId);
        finish();
      }
      return this;
    };
    MqttClient.prototype.removeOutgoingMessage = function(messageId) {
      const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
      delete this.outgoing[messageId];
      this.outgoingStore.del({ messageId }, function() {
        cb(new Error("Message removed"));
      });
      return this;
    };
    MqttClient.prototype.reconnect = function(opts) {
      debug("client reconnect");
      const that = this;
      const f2 = function() {
        if (opts) {
          that.options.incomingStore = opts.incomingStore;
          that.options.outgoingStore = opts.outgoingStore;
        } else {
          that.options.incomingStore = null;
          that.options.outgoingStore = null;
        }
        that.incomingStore = that.options.incomingStore || new Store();
        that.outgoingStore = that.options.outgoingStore || new Store();
        that.disconnecting = false;
        that.disconnected = false;
        that._deferredReconnect = null;
        that._reconnect();
      };
      if (this.disconnecting && !this.disconnected) {
        this._deferredReconnect = f2;
      } else {
        f2();
      }
      return this;
    };
    MqttClient.prototype._reconnect = function() {
      debug("_reconnect: emitting reconnect to client");
      this.emit("reconnect");
      if (this.connected) {
        this.end(() => {
          this._setupStream();
        });
        debug("client already connected. disconnecting first.");
      } else {
        debug("_reconnect: calling _setupStream");
        this._setupStream();
      }
    };
    MqttClient.prototype._setupReconnect = function() {
      const that = this;
      if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {
        if (!this.reconnecting) {
          debug("_setupReconnect :: emit `offline` state");
          this.emit("offline");
          debug("_setupReconnect :: set `reconnecting` to `true`");
          this.reconnecting = true;
        }
        debug("_setupReconnect :: setting reconnectTimer for %d ms", that.options.reconnectPeriod);
        that.reconnectTimer = setInterval(function() {
          debug("reconnectTimer :: reconnect triggered!");
          that._reconnect();
        }, that.options.reconnectPeriod);
      } else {
        debug("_setupReconnect :: doing nothing...");
      }
    };
    MqttClient.prototype._clearReconnect = function() {
      debug("_clearReconnect : clearing reconnect timer");
      if (this.reconnectTimer) {
        clearInterval(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    };
    MqttClient.prototype._cleanUp = function(forced, done) {
      const opts = arguments[2];
      if (done) {
        debug("_cleanUp :: done callback provided for on stream close");
        this.stream.on("close", done);
      }
      debug("_cleanUp :: forced? %s", forced);
      if (forced) {
        if (this.options.reconnectPeriod === 0 && this.options.clean) {
          flush(this.outgoing);
        }
        debug("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
        this.stream.destroy();
      } else {
        const packet = xtend({ cmd: "disconnect" }, opts);
        debug("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId);
        this._sendPacket(
          packet,
          setImmediate2.bind(
            null,
            this.stream.end.bind(this.stream)
          )
        );
      }
      if (!this.disconnecting) {
        debug("_cleanUp :: client not disconnecting. Clearing and resetting reconnect.");
        this._clearReconnect();
        this._setupReconnect();
      }
      if (this.pingTimer !== null) {
        debug("_cleanUp :: clearing pingTimer");
        this.pingTimer.clear();
        this.pingTimer = null;
      }
      if (done && !this.connected) {
        debug("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId);
        this.stream.removeListener("close", done);
        done();
      }
    };
    MqttClient.prototype._sendPacket = function(packet, cb, cbStorePut) {
      debug("_sendPacket :: (%s) ::  start", this.options.clientId);
      cbStorePut = cbStorePut || nop;
      cb = cb || nop;
      const err = applyTopicAlias(this, packet);
      if (err) {
        cb(err);
        return;
      }
      if (!this.connected) {
        if (packet.cmd === "auth") {
          this._shiftPingInterval();
          sendPacket(this, packet, cb);
          return;
        }
        debug("_sendPacket :: client not connected. Storing packet offline.");
        this._storePacket(packet, cb, cbStorePut);
        return;
      }
      this._shiftPingInterval();
      switch (packet.cmd) {
        case "publish":
          break;
        case "pubrel":
          storeAndSend(this, packet, cb, cbStorePut);
          return;
        default:
          sendPacket(this, packet, cb);
          return;
      }
      switch (packet.qos) {
        case 2:
        case 1:
          storeAndSend(this, packet, cb, cbStorePut);
          break;
        case 0:
        default:
          sendPacket(this, packet, cb);
          break;
      }
      debug("_sendPacket :: (%s) ::  end", this.options.clientId);
    };
    MqttClient.prototype._storePacket = function(packet, cb, cbStorePut) {
      debug("_storePacket :: packet: %o", packet);
      debug("_storePacket :: cb? %s", !!cb);
      cbStorePut = cbStorePut || nop;
      let storePacket = packet;
      if (storePacket.cmd === "publish") {
        storePacket = clone(packet);
        const err = removeTopicAliasAndRecoverTopicName(this, storePacket);
        if (err) {
          return cb && cb(err);
        }
      }
      if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== "publish") {
        this.queue.push({ packet: storePacket, cb });
      } else if (storePacket.qos > 0) {
        cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;
        this.outgoingStore.put(storePacket, function(err) {
          if (err) {
            return cb && cb(err);
          }
          cbStorePut();
        });
      } else if (cb) {
        cb(new Error("No connection to broker"));
      }
    };
    MqttClient.prototype._setupPingTimer = function() {
      debug("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
      const that = this;
      if (!this.pingTimer && this.options.keepalive) {
        this.pingResp = true;
        this.pingTimer = reInterval(function() {
          that._checkPing();
        }, this.options.keepalive * 1e3);
      }
    };
    MqttClient.prototype._shiftPingInterval = function() {
      if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
        this.pingTimer.reschedule(this.options.keepalive * 1e3);
      }
    };
    MqttClient.prototype._checkPing = function() {
      debug("_checkPing :: checking ping...");
      if (this.pingResp) {
        debug("_checkPing :: ping response received. Clearing flag and sending `pingreq`");
        this.pingResp = false;
        this._sendPacket({ cmd: "pingreq" });
      } else {
        debug("_checkPing :: calling _cleanUp with force true");
        this._cleanUp(true);
      }
    };
    MqttClient.prototype._handlePingresp = function() {
      this.pingResp = true;
    };
    MqttClient.prototype._handleConnack = function(packet) {
      debug("_handleConnack");
      const options = this.options;
      const version = options.protocolVersion;
      const rc2 = version === 5 ? packet.reasonCode : packet.returnCode;
      clearTimeout(this.connackTimer);
      delete this.topicAliasSend;
      if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
          if (packet.properties.topicAliasMaximum > 65535) {
            this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
            return;
          }
          if (packet.properties.topicAliasMaximum > 0) {
            this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);
          }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
          options.keepalive = packet.properties.serverKeepAlive;
          this._shiftPingInterval();
        }
        if (packet.properties.maximumPacketSize) {
          if (!options.properties) {
            options.properties = {};
          }
          options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
        }
      }
      if (rc2 === 0) {
        this.reconnecting = false;
        this._onConnect(packet);
      } else if (rc2 > 0) {
        const err = new Error("Connection refused: " + errors[rc2]);
        err.code = rc2;
        this.emit("error", err);
      }
    };
    MqttClient.prototype._handleAuth = function(packet) {
      const options = this.options;
      const version = options.protocolVersion;
      const rc2 = version === 5 ? packet.reasonCode : packet.returnCode;
      if (version !== 5) {
        const err = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + version);
        err.code = rc2;
        this.emit("error", err);
        return;
      }
      const that = this;
      this.handleAuth(packet, function(err, packet2) {
        if (err) {
          that.emit("error", err);
          return;
        }
        if (rc2 === 24) {
          that.reconnecting = false;
          that._sendPacket(packet2);
        } else {
          const error = new Error("Connection refused: " + errors[rc2]);
          err.code = rc2;
          that.emit("error", error);
        }
      });
    };
    MqttClient.prototype.handleAuth = function(packet, callback) {
      callback();
    };
    MqttClient.prototype._handlePublish = function(packet, done) {
      debug("_handlePublish: packet %o", packet);
      done = typeof done !== "undefined" ? done : nop;
      let topic = packet.topic.toString();
      const message = packet.payload;
      const qos = packet.qos;
      const messageId = packet.messageId;
      const that = this;
      const options = this.options;
      const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
      if (this.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
          alias = packet.properties.topicAlias;
        }
        if (typeof alias !== "undefined") {
          if (topic.length === 0) {
            if (alias > 0 && alias <= 65535) {
              const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);
              if (gotTopic) {
                topic = gotTopic;
                debug("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
              } else {
                debug("_handlePublish :: unregistered topic alias. alias: %d", alias);
                this.emit("error", new Error("Received unregistered Topic Alias"));
                return;
              }
            } else {
              debug("_handlePublish :: topic alias out of range. alias: %d", alias);
              this.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          } else {
            if (this.topicAliasRecv.put(topic, alias)) {
              debug("_handlePublish :: registered topic: %s - alias: %d", topic, alias);
            } else {
              debug("_handlePublish :: topic alias out of range. alias: %d", alias);
              this.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          }
        }
      }
      debug("_handlePublish: qos %d", qos);
      switch (qos) {
        case 2: {
          options.customHandleAcks(topic, message, packet, function(error, code) {
            if (!(error instanceof Error)) {
              code = error;
              error = null;
            }
            if (error) {
              return that.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return that.emit("error", new Error("Wrong reason code for pubrec"));
            }
            if (code) {
              that._sendPacket({ cmd: "pubrec", messageId, reasonCode: code }, done);
            } else {
              that.incomingStore.put(packet, function() {
                that._sendPacket({ cmd: "pubrec", messageId }, done);
              });
            }
          });
          break;
        }
        case 1: {
          options.customHandleAcks(topic, message, packet, function(error, code) {
            if (!(error instanceof Error)) {
              code = error;
              error = null;
            }
            if (error) {
              return that.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return that.emit("error", new Error("Wrong reason code for puback"));
            }
            if (!code) {
              that.emit("message", topic, message, packet);
            }
            that.handleMessage(packet, function(err) {
              if (err) {
                return done && done(err);
              }
              that._sendPacket({ cmd: "puback", messageId, reasonCode: code }, done);
            });
          });
          break;
        }
        case 0:
          this.emit("message", topic, message, packet);
          this.handleMessage(packet, done);
          break;
        default:
          debug("_handlePublish: unknown QoS. Doing nothing.");
          break;
      }
    };
    MqttClient.prototype.handleMessage = function(packet, callback) {
      callback();
    };
    MqttClient.prototype._handleAck = function(packet) {
      const messageId = packet.messageId;
      const type = packet.cmd;
      let response = null;
      const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
      const that = this;
      let err;
      if (!cb) {
        debug("_handleAck :: Server sent an ack in error. Ignoring.");
        return;
      }
      debug("_handleAck :: packet type", type);
      switch (type) {
        case "pubcomp":
        case "puback": {
          const pubackRC = packet.reasonCode;
          if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
            err = new Error("Publish error: " + errors[pubackRC]);
            err.code = pubackRC;
            cb(err, packet);
          }
          delete this.outgoing[messageId];
          this.outgoingStore.del(packet, cb);
          this.messageIdProvider.deallocate(messageId);
          this._invokeStoreProcessingQueue();
          break;
        }
        case "pubrec": {
          response = {
            cmd: "pubrel",
            qos: 2,
            messageId
          };
          const pubrecRC = packet.reasonCode;
          if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
            err = new Error("Publish error: " + errors[pubrecRC]);
            err.code = pubrecRC;
            cb(err, packet);
          } else {
            this._sendPacket(response);
          }
          break;
        }
        case "suback": {
          delete this.outgoing[messageId];
          this.messageIdProvider.deallocate(messageId);
          for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {
            if ((packet.granted[grantedI] & 128) !== 0) {
              const topics = this.messageIdToTopic[messageId];
              if (topics) {
                topics.forEach(function(topic) {
                  delete that._resubscribeTopics[topic];
                });
              }
            }
          }
          this._invokeStoreProcessingQueue();
          cb(null, packet);
          break;
        }
        case "unsuback": {
          delete this.outgoing[messageId];
          this.messageIdProvider.deallocate(messageId);
          this._invokeStoreProcessingQueue();
          cb(null);
          break;
        }
        default:
          that.emit("error", new Error("unrecognized packet type"));
      }
      if (this.disconnecting && Object.keys(this.outgoing).length === 0) {
        this.emit("outgoingEmpty");
      }
    };
    MqttClient.prototype._handlePubrel = function(packet, callback) {
      debug("handling pubrel packet");
      callback = typeof callback !== "undefined" ? callback : nop;
      const messageId = packet.messageId;
      const that = this;
      const comp = { cmd: "pubcomp", messageId };
      that.incomingStore.get(packet, function(err, pub) {
        if (!err) {
          that.emit("message", pub.topic, pub.payload, pub);
          that.handleMessage(pub, function(err2) {
            if (err2) {
              return callback(err2);
            }
            that.incomingStore.del(pub, nop);
            that._sendPacket(comp, callback);
          });
        } else {
          that._sendPacket(comp, callback);
        }
      });
    };
    MqttClient.prototype._handleDisconnect = function(packet) {
      this.emit("disconnect", packet);
    };
    MqttClient.prototype._nextId = function() {
      return this.messageIdProvider.allocate();
    };
    MqttClient.prototype.getLastMessageId = function() {
      return this.messageIdProvider.getLastAllocated();
    };
    MqttClient.prototype._resubscribe = function() {
      debug("_resubscribe");
      const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
      if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {
        if (this.options.resubscribe) {
          if (this.options.protocolVersion === 5) {
            debug("_resubscribe: protocolVersion 5");
            for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
              const resubscribeTopic = {};
              resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
              resubscribeTopic.resubscribe = true;
              this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties });
            }
          } else {
            this._resubscribeTopics.resubscribe = true;
            this.subscribe(this._resubscribeTopics);
          }
        } else {
          this._resubscribeTopics = {};
        }
      }
      this._firstConnection = false;
    };
    MqttClient.prototype._onConnect = function(packet) {
      if (this.disconnected) {
        this.emit("connect", packet);
        return;
      }
      const that = this;
      this.connackPacket = packet;
      this.messageIdProvider.clear();
      this._setupPingTimer();
      this.connected = true;
      function startStreamProcess() {
        let outStore = that.outgoingStore.createStream();
        function clearStoreProcessing() {
          that._storeProcessing = false;
          that._packetIdsDuringStoreProcessing = {};
        }
        that.once("close", remove);
        outStore.on("error", function(err) {
          clearStoreProcessing();
          that._flushStoreProcessingQueue();
          that.removeListener("close", remove);
          that.emit("error", err);
        });
        function remove() {
          outStore.destroy();
          outStore = null;
          that._flushStoreProcessingQueue();
          clearStoreProcessing();
        }
        function storeDeliver() {
          if (!outStore) {
            return;
          }
          that._storeProcessing = true;
          const packet2 = outStore.read(1);
          let cb;
          if (!packet2) {
            outStore.once("readable", storeDeliver);
            return;
          }
          if (that._packetIdsDuringStoreProcessing[packet2.messageId]) {
            storeDeliver();
            return;
          }
          if (!that.disconnecting && !that.reconnectTimer) {
            cb = that.outgoing[packet2.messageId] ? that.outgoing[packet2.messageId].cb : null;
            that.outgoing[packet2.messageId] = {
              volatile: false,
              cb: function(err, status) {
                if (cb) {
                  cb(err, status);
                }
                storeDeliver();
              }
            };
            that._packetIdsDuringStoreProcessing[packet2.messageId] = true;
            if (that.messageIdProvider.register(packet2.messageId)) {
              that._sendPacket(packet2);
            } else {
              debug("messageId: %d has already used.", packet2.messageId);
            }
          } else if (outStore.destroy) {
            outStore.destroy();
          }
        }
        outStore.on("end", function() {
          let allProcessed = true;
          for (const id2 in that._packetIdsDuringStoreProcessing) {
            if (!that._packetIdsDuringStoreProcessing[id2]) {
              allProcessed = false;
              break;
            }
          }
          if (allProcessed) {
            clearStoreProcessing();
            that.removeListener("close", remove);
            that._invokeAllStoreProcessingQueue();
            that.emit("connect", packet);
          } else {
            startStreamProcess();
          }
        });
        storeDeliver();
      }
      startStreamProcess();
    };
    MqttClient.prototype._invokeStoreProcessingQueue = function() {
      if (this._storeProcessingQueue.length > 0) {
        const f2 = this._storeProcessingQueue[0];
        if (f2 && f2.invoke()) {
          this._storeProcessingQueue.shift();
          return true;
        }
      }
      return false;
    };
    MqttClient.prototype._invokeAllStoreProcessingQueue = function() {
      while (this._invokeStoreProcessingQueue()) {
      }
    };
    MqttClient.prototype._flushStoreProcessingQueue = function() {
      for (const f2 of this._storeProcessingQueue) {
        if (f2.cbStorePut)
          f2.cbStorePut(new Error("Connection closed"));
        if (f2.callback)
          f2.callback(new Error("Connection closed"));
      }
      this._storeProcessingQueue.splice(0);
    };
    module.exports = MqttClient;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mqtt/lib/connect/tcp.js
var require_tcp = __commonJS({
  "node_modules/mqtt/lib/connect/tcp.js"(exports, module) {
    "use strict";
    var net = require_net();
    var debug = require_browser3()("mqttjs:tcp");
    function streamBuilder(client, opts) {
      opts.port = opts.port || 1883;
      opts.hostname = opts.hostname || opts.host || "localhost";
      const port = opts.port;
      const host = opts.hostname;
      debug("port %d and host %s", port, host);
      return net.createConnection(port, host);
    }
    module.exports = streamBuilder;
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mqtt/lib/connect/tls.js
var require_tls2 = __commonJS({
  "node_modules/mqtt/lib/connect/tls.js"(exports, module) {
    "use strict";
    var tls = require_tls();
    var net = require_net();
    var debug = require_browser3()("mqttjs:tls");
    function buildBuilder(mqttClient, opts) {
      opts.port = opts.port || 8883;
      opts.host = opts.hostname || opts.host || "localhost";
      if (net.isIP(opts.host) === 0) {
        opts.servername = opts.host;
      }
      opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
      delete opts.path;
      debug("port %d host %s rejectUnauthorized %b", opts.port, opts.host, opts.rejectUnauthorized);
      const connection = tls.connect(opts);
      connection.on("secureConnect", function() {
        if (opts.rejectUnauthorized && !connection.authorized) {
          connection.emit("error", new Error("TLS not authorized"));
        } else {
          connection.removeListener("error", handleTLSerrors);
        }
      });
      function handleTLSerrors(err) {
        if (opts.rejectUnauthorized) {
          mqttClient.emit("error", err);
        }
        connection.end();
      }
      connection.on("error", handleTLSerrors);
      return connection;
    }
    module.exports = buildBuilder;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn2, cb) {
      if (fn2 && cb)
        return wrappy(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k2) {
        wrapper[k2] = fn2[k2];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn2.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k2) {
            ret[k2] = cb2[k2];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn2) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn2) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream3 = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws2 = stream._writableState;
      var rs2 = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs2 && (rs2.ended && !rs2.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws2 && (ws2.ended && !ws2.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws2) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/stream-shift/index.js
var require_stream_shift = __commonJS({
  "node_modules/stream-shift/index.js"(exports, module) {
    module.exports = shift;
    function shift(stream) {
      var rs2 = stream._readableState;
      if (!rs2)
        return null;
      return rs2.objectMode || typeof stream._duplexState === "number" ? stream.read() : stream.read(getStateLength(rs2));
    }
    function getStateLength(state) {
      if (state.buffer.length) {
        if (state.buffer.head) {
          return state.buffer.head.data.length;
        } else if (state.buffer.length > 0 && state.buffer[0]) {
          return state.buffer[0].length;
        }
      }
      return state.length;
    }
  }
});

// node_modules/mqtt/node_modules/duplexify/index.js
var require_duplexify = __commonJS({
  "node_modules/mqtt/node_modules/duplexify/index.js"(exports, module) {
    var stream = require_readable_browser();
    var eos = require_end_of_stream3();
    var inherits = require_inherits_browser();
    var shift = require_stream_shift();
    var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);
    var onuncork = function(self2, fn2) {
      if (self2._corked)
        self2.once("uncork", fn2);
      else
        fn2();
    };
    var autoDestroy = function(self2, err) {
      if (self2._autoDestroy)
        self2.destroy(err);
    };
    var destroyer = function(self2, end2) {
      return function(err) {
        if (err)
          autoDestroy(self2, err.message === "premature close" ? null : err);
        else if (end2 && !self2._ended)
          self2.end();
      };
    };
    var end = function(ws2, fn2) {
      if (!ws2)
        return fn2();
      if (ws2._writableState && ws2._writableState.finished)
        return fn2();
      if (ws2._writableState)
        return ws2.end(fn2);
      ws2.end();
      fn2();
    };
    var noop = function() {
    };
    var toStreams2 = function(rs2) {
      return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs2);
    };
    var Duplexify = function(writable, readable, opts) {
      if (!(this instanceof Duplexify))
        return new Duplexify(writable, readable, opts);
      stream.Duplex.call(this, opts);
      this._writable = null;
      this._readable = null;
      this._readable2 = null;
      this._autoDestroy = !opts || opts.autoDestroy !== false;
      this._forwardDestroy = !opts || opts.destroy !== false;
      this._forwardEnd = !opts || opts.end !== false;
      this._corked = 1;
      this._ondrain = null;
      this._drained = false;
      this._forwarding = false;
      this._unwrite = null;
      this._unread = null;
      this._ended = false;
      this.destroyed = false;
      if (writable)
        this.setWritable(writable);
      if (readable)
        this.setReadable(readable);
    };
    inherits(Duplexify, stream.Duplex);
    Duplexify.obj = function(writable, readable, opts) {
      if (!opts)
        opts = {};
      opts.objectMode = true;
      opts.highWaterMark = 16;
      return new Duplexify(writable, readable, opts);
    };
    Duplexify.prototype.cork = function() {
      if (++this._corked === 1)
        this.emit("cork");
    };
    Duplexify.prototype.uncork = function() {
      if (this._corked && --this._corked === 0)
        this.emit("uncork");
    };
    Duplexify.prototype.setWritable = function(writable) {
      if (this._unwrite)
        this._unwrite();
      if (this.destroyed) {
        if (writable && writable.destroy)
          writable.destroy();
        return;
      }
      if (writable === null || writable === false) {
        this.end();
        return;
      }
      var self2 = this;
      var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));
      var ondrain = function() {
        var ondrain2 = self2._ondrain;
        self2._ondrain = null;
        if (ondrain2)
          ondrain2();
      };
      var clear = function() {
        self2._writable.removeListener("drain", ondrain);
        unend();
      };
      if (this._unwrite)
        process.nextTick(ondrain);
      this._writable = writable;
      this._writable.on("drain", ondrain);
      this._unwrite = clear;
      this.uncork();
    };
    Duplexify.prototype.setReadable = function(readable) {
      if (this._unread)
        this._unread();
      if (this.destroyed) {
        if (readable && readable.destroy)
          readable.destroy();
        return;
      }
      if (readable === null || readable === false) {
        this.push(null);
        this.resume();
        return;
      }
      var self2 = this;
      var unend = eos(readable, { writable: false, readable: true }, destroyer(this));
      var onreadable = function() {
        self2._forward();
      };
      var onend = function() {
        self2.push(null);
      };
      var clear = function() {
        self2._readable2.removeListener("readable", onreadable);
        self2._readable2.removeListener("end", onend);
        unend();
      };
      this._drained = true;
      this._readable = readable;
      this._readable2 = readable._readableState ? readable : toStreams2(readable);
      this._readable2.on("readable", onreadable);
      this._readable2.on("end", onend);
      this._unread = clear;
      this._forward();
    };
    Duplexify.prototype._read = function() {
      this._drained = true;
      this._forward();
    };
    Duplexify.prototype._forward = function() {
      if (this._forwarding || !this._readable2 || !this._drained)
        return;
      this._forwarding = true;
      var data;
      while (this._drained && (data = shift(this._readable2)) !== null) {
        if (this.destroyed)
          continue;
        this._drained = this.push(data);
      }
      this._forwarding = false;
    };
    Duplexify.prototype.destroy = function(err, cb) {
      if (!cb)
        cb = noop;
      if (this.destroyed)
        return cb(null);
      this.destroyed = true;
      var self2 = this;
      process.nextTick(function() {
        self2._destroy(err);
        cb(null);
      });
    };
    Duplexify.prototype._destroy = function(err) {
      if (err) {
        var ondrain = this._ondrain;
        this._ondrain = null;
        if (ondrain)
          ondrain(err);
        else
          this.emit("error", err);
      }
      if (this._forwardDestroy) {
        if (this._readable && this._readable.destroy)
          this._readable.destroy();
        if (this._writable && this._writable.destroy)
          this._writable.destroy();
      }
      this.emit("close");
    };
    Duplexify.prototype._write = function(data, enc, cb) {
      if (this.destroyed)
        return;
      if (this._corked)
        return onuncork(this, this._write.bind(this, data, enc, cb));
      if (data === SIGNAL_FLUSH)
        return this._finish(cb);
      if (!this._writable)
        return cb();
      if (this._writable.write(data) === false)
        this._ondrain = cb;
      else if (!this.destroyed)
        cb();
    };
    Duplexify.prototype._finish = function(cb) {
      var self2 = this;
      this.emit("preend");
      onuncork(this, function() {
        end(self2._forwardEnd && self2._writable, function() {
          if (self2._writableState.prefinished === false)
            self2._writableState.prefinished = true;
          self2.emit("prefinish");
          onuncork(self2, cb);
        });
      });
    };
    Duplexify.prototype.end = function(data, enc, cb) {
      if (typeof data === "function")
        return this.end(null, null, data);
      if (typeof enc === "function")
        return this.end(data, null, enc);
      this._ended = true;
      if (data)
        this.write(data);
      if (!this._writableState.ending && !this._writableState.destroyed)
        this.write(SIGNAL_FLUSH);
      return stream.Writable.prototype.end.call(this, cb);
    };
    module.exports = Duplexify;
  }
});

// node_modules/mqtt/lib/connect/wx.js
var require_wx = __commonJS({
  "node_modules/mqtt/lib/connect/wx.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var Transform = require_readable_browser().Transform;
    var duplexify = require_duplexify();
    var socketTask;
    var proxy;
    var stream;
    function buildProxy() {
      const proxy2 = new Transform();
      proxy2._write = function(chunk, encoding, next) {
        socketTask.send({
          data: chunk.buffer,
          success: function() {
            next();
          },
          fail: function(errMsg) {
            next(new Error(errMsg));
          }
        });
      };
      proxy2._flush = function socketEnd(done) {
        socketTask.close({
          success: function() {
            done();
          }
        });
      };
      return proxy2;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "wxs" ? "wss" : "ws";
      let url = protocol + "://" + opts.hostname + opts.path;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      socketTask.onOpen(function() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      });
      socketTask.onMessage(function(res) {
        let data = res.data;
        if (data instanceof ArrayBuffer)
          data = Buffer2.from(data);
        else
          data = Buffer2.from(data, "utf8");
        proxy.push(data);
      });
      socketTask.onClose(function() {
        stream.end();
        stream.destroy();
      });
      socketTask.onError(function(res) {
        stream.destroy(new Error(res.errMsg));
      });
    }
    function buildStream(client, opts) {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      socketTask = wx.connectSocket({
        url,
        protocols: [websocketSubProtocol]
      });
      proxy = buildProxy();
      stream = duplexify.obj();
      stream._destroy = function(err, cb) {
        socketTask.close({
          success: function() {
            cb && cb(err);
          }
        });
      };
      const destroyRef = stream.destroy;
      stream.destroy = (function() {
        stream.destroy = destroyRef;
        const self2 = this;
        setTimeout(function() {
          socketTask.close({
            fail: function() {
              self2._destroy(new Error());
            }
          });
        }, 0);
      }).bind(stream);
      bindEventHandler();
      return stream;
    }
    module.exports = buildStream;
  }
});

// node_modules/mqtt/lib/connect/ali.js
var require_ali = __commonJS({
  "node_modules/mqtt/lib/connect/ali.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var Transform = require_readable_browser().Transform;
    var duplexify = require_duplexify();
    var my;
    var proxy;
    var stream;
    var isInitialized = false;
    function buildProxy() {
      const proxy2 = new Transform();
      proxy2._write = function(chunk, encoding, next) {
        my.sendSocketMessage({
          data: chunk.buffer,
          success: function() {
            next();
          },
          fail: function() {
            next(new Error());
          }
        });
      };
      proxy2._flush = function socketEnd(done) {
        my.closeSocket({
          success: function() {
            done();
          }
        });
      };
      return proxy2;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "alis" ? "wss" : "ws";
      let url = protocol + "://" + opts.hostname + opts.path;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      if (isInitialized)
        return;
      isInitialized = true;
      my.onSocketOpen(function() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      });
      my.onSocketMessage(function(res) {
        if (typeof res.data === "string") {
          const buffer = Buffer2.from(res.data, "base64");
          proxy.push(buffer);
        } else {
          const reader = new FileReader();
          reader.addEventListener("load", function() {
            let data = reader.result;
            if (data instanceof ArrayBuffer)
              data = Buffer2.from(data);
            else
              data = Buffer2.from(data, "utf8");
            proxy.push(data);
          });
          reader.readAsArrayBuffer(res.data);
        }
      });
      my.onSocketClose(function() {
        stream.end();
        stream.destroy();
      });
      my.onSocketError(function(res) {
        stream.destroy(res);
      });
    }
    function buildStream(client, opts) {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      my = opts.my;
      my.connectSocket({
        url,
        protocols: websocketSubProtocol
      });
      proxy = buildProxy();
      stream = duplexify.obj();
      bindEventHandler();
      return stream;
    }
    module.exports = buildStream;
  }
});

// node_modules/mqtt/node_modules/ws/browser.js
var require_browser4 = __commonJS({
  "node_modules/mqtt/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/mqtt/lib/connect/ws.js
var require_ws = __commonJS({
  "node_modules/mqtt/lib/connect/ws.js"(exports, module) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var WS = require_browser4();
    var debug = require_browser3()("mqttjs:ws");
    var duplexify = require_duplexify();
    var Transform = require_readable_browser().Transform;
    var WSS_OPTIONS = [
      "rejectUnauthorized",
      "ca",
      "cert",
      "key",
      "pfx",
      "passphrase"
    ];
    var IS_BROWSER = typeof process !== "undefined" && process.title === "browser" || typeof __webpack_require__ === "function";
    function buildUrl(opts, client) {
      let url = opts.protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function setDefaultOpts(opts) {
      const options = opts;
      if (!opts.hostname) {
        options.hostname = "localhost";
      }
      if (!opts.port) {
        if (opts.protocol === "wss") {
          options.port = 443;
        } else {
          options.port = 80;
        }
      }
      if (!opts.path) {
        options.path = "/";
      }
      if (!opts.wsOptions) {
        options.wsOptions = {};
      }
      if (!IS_BROWSER && opts.protocol === "wss") {
        WSS_OPTIONS.forEach(function(prop) {
          if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
            options.wsOptions[prop] = opts[prop];
          }
        });
      }
      return options;
    }
    function setDefaultBrowserOpts(opts) {
      const options = setDefaultOpts(opts);
      if (!options.hostname) {
        options.hostname = options.host;
      }
      if (!options.hostname) {
        if (typeof document === "undefined") {
          throw new Error("Could not determine host. Specify host manually.");
        }
        const parsed = new URL(document.URL);
        options.hostname = parsed.hostname;
        if (!options.port) {
          options.port = parsed.port;
        }
      }
      if (options.objectMode === void 0) {
        options.objectMode = !(options.binary === true || options.binary === void 0);
      }
      return options;
    }
    function createWebSocket(client, url, opts) {
      debug("createWebSocket");
      debug("protocol: " + opts.protocolId + " " + opts.protocolVersion);
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      debug("creating new Websocket for url: " + url + " and protocol: " + websocketSubProtocol);
      const socket = new WS(url, [websocketSubProtocol], opts.wsOptions);
      return socket;
    }
    function createBrowserWebSocket(client, opts) {
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      const url = buildUrl(opts, client);
      const socket = new WebSocket(url, [websocketSubProtocol]);
      socket.binaryType = "arraybuffer";
      return socket;
    }
    function streamBuilder(client, opts) {
      debug("streamBuilder");
      const options = setDefaultOpts(opts);
      const url = buildUrl(options, client);
      const socket = createWebSocket(client, url, options);
      const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);
      webSocketStream.url = url;
      socket.on("close", () => {
        webSocketStream.destroy();
      });
      return webSocketStream;
    }
    function browserStreamBuilder(client, opts) {
      debug("browserStreamBuilder");
      let stream;
      const options = setDefaultBrowserOpts(opts);
      const bufferSize = options.browserBufferSize || 1024 * 512;
      const bufferTimeout = opts.browserBufferTimeout || 1e3;
      const coerceToBuffer = !opts.objectMode;
      const socket = createBrowserWebSocket(client, opts);
      const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
      if (!opts.objectMode) {
        proxy._writev = writev;
      }
      proxy.on("close", () => {
        socket.close();
      });
      const eventListenerSupport = typeof socket.addEventListener !== "undefined";
      if (socket.readyState === socket.OPEN) {
        stream = proxy;
      } else {
        stream = stream = duplexify(void 0, void 0, opts);
        if (!opts.objectMode) {
          stream._writev = writev;
        }
        if (eventListenerSupport) {
          socket.addEventListener("open", onopen);
        } else {
          socket.onopen = onopen;
        }
      }
      stream.socket = socket;
      if (eventListenerSupport) {
        socket.addEventListener("close", onclose);
        socket.addEventListener("error", onerror);
        socket.addEventListener("message", onmessage);
      } else {
        socket.onclose = onclose;
        socket.onerror = onerror;
        socket.onmessage = onmessage;
      }
      function buildProxy(options2, socketWrite, socketEnd) {
        const proxy2 = new Transform({
          objectModeMode: options2.objectMode
        });
        proxy2._write = socketWrite;
        proxy2._flush = socketEnd;
        return proxy2;
      }
      function onopen() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      }
      function onclose() {
        stream.end();
        stream.destroy();
      }
      function onerror(err) {
        stream.destroy(err);
      }
      function onmessage(event) {
        let data = event.data;
        if (data instanceof ArrayBuffer)
          data = Buffer2.from(data);
        else
          data = Buffer2.from(data, "utf8");
        proxy.push(data);
      }
      function writev(chunks, cb) {
        const buffers = new Array(chunks.length);
        for (let i = 0; i < chunks.length; i++) {
          if (typeof chunks[i].chunk === "string") {
            buffers[i] = Buffer2.from(chunks[i], "utf8");
          } else {
            buffers[i] = chunks[i].chunk;
          }
        }
        this._write(Buffer2.concat(buffers), "binary", cb);
      }
      function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
          setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
        }
        if (coerceToBuffer && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, "utf8");
        }
        try {
          socket.send(chunk);
        } catch (err) {
          return next(err);
        }
        next();
      }
      function socketEndBrowser(done) {
        socket.close();
        done();
      }
      return stream;
    }
    if (IS_BROWSER) {
      module.exports = browserStreamBuilder;
    } else {
      module.exports = streamBuilder;
    }
  }
});

// node_modules/mqtt/lib/connect/index.js
var require_connect = __commonJS({
  "node_modules/mqtt/lib/connect/index.js"(exports, module) {
    "use strict";
    var MqttClient = require_client();
    var Store = require_store();
    var url = require_url();
    var xtend = require_immutable();
    var debug = require_browser3()("mqttjs");
    var protocols = {};
    if (typeof process !== "undefined" && process.title !== "browser" || typeof __webpack_require__ !== "function") {
      protocols.mqtt = require_tcp();
      protocols.tcp = require_tcp();
      protocols.ssl = require_tls2();
      protocols.tls = require_tls2();
      protocols.mqtts = require_tls2();
    } else {
      protocols.wx = require_wx();
      protocols.wxs = require_wx();
      protocols.ali = require_ali();
      protocols.alis = require_ali();
    }
    protocols.ws = require_ws();
    protocols.wss = require_ws();
    function parseAuthOptions(opts) {
      let matches;
      if (opts.auth) {
        matches = opts.auth.match(/^(.+):(.+)$/);
        if (matches) {
          opts.username = matches[1];
          opts.password = matches[2];
        } else {
          opts.username = opts.auth;
        }
      }
    }
    function connect(brokerUrl, opts) {
      debug("connecting to an MQTT broker...");
      if (typeof brokerUrl === "object" && !opts) {
        opts = brokerUrl;
        brokerUrl = null;
      }
      opts = opts || {};
      if (brokerUrl) {
        const parsed = url.parse(brokerUrl, true);
        if (parsed.port != null) {
          parsed.port = Number(parsed.port);
        }
        opts = xtend(parsed, opts);
        if (opts.protocol === null) {
          throw new Error("Missing protocol");
        }
        opts.protocol = opts.protocol.replace(/:$/, "");
      }
      parseAuthOptions(opts);
      if (opts.query && typeof opts.query.clientId === "string") {
        opts.clientId = opts.query.clientId;
      }
      if (opts.cert && opts.key) {
        if (opts.protocol) {
          if (["mqtts", "wss", "wxs", "alis"].indexOf(opts.protocol) === -1) {
            switch (opts.protocol) {
              case "mqtt":
                opts.protocol = "mqtts";
                break;
              case "ws":
                opts.protocol = "wss";
                break;
              case "wx":
                opts.protocol = "wxs";
                break;
              case "ali":
                opts.protocol = "alis";
                break;
              default:
                throw new Error('Unknown protocol for secure connection: "' + opts.protocol + '"!');
            }
          }
        } else {
          throw new Error("Missing secure protocol key");
        }
      }
      if (!protocols[opts.protocol]) {
        const isSecure = ["mqtts", "wss"].indexOf(opts.protocol) !== -1;
        opts.protocol = [
          "mqtt",
          "mqtts",
          "ws",
          "wss",
          "wx",
          "wxs",
          "ali",
          "alis"
        ].filter(function(key, index) {
          if (isSecure && index % 2 === 0) {
            return false;
          }
          return typeof protocols[key] === "function";
        })[0];
      }
      if (opts.clean === false && !opts.clientId) {
        throw new Error("Missing clientId for unclean clients");
      }
      if (opts.protocol) {
        opts.defaultProtocol = opts.protocol;
      }
      function wrapper(client2) {
        if (opts.servers) {
          if (!client2._reconnectCount || client2._reconnectCount === opts.servers.length) {
            client2._reconnectCount = 0;
          }
          opts.host = opts.servers[client2._reconnectCount].host;
          opts.port = opts.servers[client2._reconnectCount].port;
          opts.protocol = !opts.servers[client2._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client2._reconnectCount].protocol;
          opts.hostname = opts.host;
          client2._reconnectCount++;
        }
        debug("calling streambuilder for", opts.protocol);
        return protocols[opts.protocol](client2, opts);
      }
      const client = new MqttClient(wrapper, opts);
      client.on("error", function() {
      });
      return client;
    }
    module.exports = connect;
    module.exports.connect = connect;
    module.exports.MqttClient = MqttClient;
    module.exports.Store = Store;
  }
});

// node_modules/aws-crt/dist.browser/common/event.js
var require_event = __commonJS({
  "node_modules/aws-crt/dist.browser/common/event.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __read6 = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar2.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar2;
    };
    var __spreadArray4 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
          if (ar2 || !(i in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i);
            ar2[i] = from[i];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedEventEmitter = void 0;
    var events_1 = require_events();
    var BufferedEvent = (
      /** @class */
      function() {
        function BufferedEvent2(event, args) {
          this.event = event;
          this.args = args;
        }
        return BufferedEvent2;
      }()
    );
    var BufferedEventEmitter = (
      /** @class */
      function(_super) {
        __extends19(BufferedEventEmitter2, _super);
        function BufferedEventEmitter2() {
          var _this = _super.call(this) || this;
          _this.corked = false;
          return _this;
        }
        BufferedEventEmitter2.prototype.cork = function() {
          this.corked = true;
        };
        BufferedEventEmitter2.prototype.uncork = function() {
          this.corked = false;
          while (this.eventQueue) {
            var event_1 = this.eventQueue;
            _super.prototype.emit.apply(this, __spreadArray4([event_1.event], __read6(event_1.args), false));
            this.eventQueue = this.eventQueue.next;
          }
        };
        BufferedEventEmitter2.prototype.emit = function(event) {
          var args = [];
          for (var _i2 = 1; _i2 < arguments.length; _i2++) {
            args[_i2 - 1] = arguments[_i2];
          }
          if (this.corked) {
            var last = this.lastQueuedEvent;
            this.lastQueuedEvent = new BufferedEvent(event, args);
            if (last) {
              last.next = this.lastQueuedEvent;
            } else {
              this.eventQueue = this.lastQueuedEvent;
            }
            return this.listeners(event).length > 0;
          }
          return _super.prototype.emit.apply(this, __spreadArray4([event], __read6(args), false));
        };
        return BufferedEventEmitter2;
      }(events_1.EventEmitter)
    );
    exports.BufferedEventEmitter = BufferedEventEmitter;
  }
});

// node_modules/aws-crt/dist.browser/common/mqtt5.js
var require_mqtt5 = __commonJS({
  "node_modules/aws-crt/dist.browser/common/mqtt5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InboundTopicAliasBehaviorType = exports.OutboundTopicAliasBehaviorType = exports.RetryJitterType = exports.ClientSessionBehavior = void 0;
    var ClientSessionBehavior;
    (function(ClientSessionBehavior2) {
      ClientSessionBehavior2[ClientSessionBehavior2["Default"] = 0] = "Default";
      ClientSessionBehavior2[ClientSessionBehavior2["Clean"] = 1] = "Clean";
      ClientSessionBehavior2[ClientSessionBehavior2["RejoinPostSuccess"] = 2] = "RejoinPostSuccess";
      ClientSessionBehavior2[ClientSessionBehavior2["RejoinAlways"] = 3] = "RejoinAlways";
    })(ClientSessionBehavior = exports.ClientSessionBehavior || (exports.ClientSessionBehavior = {}));
    var RetryJitterType;
    (function(RetryJitterType2) {
      RetryJitterType2[RetryJitterType2["Default"] = 0] = "Default";
      RetryJitterType2[RetryJitterType2["None"] = 1] = "None";
      RetryJitterType2[RetryJitterType2["Full"] = 2] = "Full";
      RetryJitterType2[RetryJitterType2["Decorrelated"] = 3] = "Decorrelated";
    })(RetryJitterType = exports.RetryJitterType || (exports.RetryJitterType = {}));
    var OutboundTopicAliasBehaviorType;
    (function(OutboundTopicAliasBehaviorType2) {
      OutboundTopicAliasBehaviorType2[OutboundTopicAliasBehaviorType2["Default"] = 0] = "Default";
      OutboundTopicAliasBehaviorType2[OutboundTopicAliasBehaviorType2["Manual"] = 1] = "Manual";
      OutboundTopicAliasBehaviorType2[OutboundTopicAliasBehaviorType2["LRU"] = 2] = "LRU";
      OutboundTopicAliasBehaviorType2[OutboundTopicAliasBehaviorType2["Disabled"] = 3] = "Disabled";
    })(OutboundTopicAliasBehaviorType = exports.OutboundTopicAliasBehaviorType || (exports.OutboundTopicAliasBehaviorType = {}));
    var InboundTopicAliasBehaviorType;
    (function(InboundTopicAliasBehaviorType2) {
      InboundTopicAliasBehaviorType2[InboundTopicAliasBehaviorType2["Default"] = 0] = "Default";
      InboundTopicAliasBehaviorType2[InboundTopicAliasBehaviorType2["Enabled"] = 1] = "Enabled";
      InboundTopicAliasBehaviorType2[InboundTopicAliasBehaviorType2["Disabled"] = 2] = "Disabled";
    })(InboundTopicAliasBehaviorType = exports.InboundTopicAliasBehaviorType || (exports.InboundTopicAliasBehaviorType = {}));
  }
});

// node_modules/aws-crt/dist.browser/common/mqtt5_packet.js
var require_mqtt5_packet = __commonJS({
  "node_modules/aws-crt/dist.browser/common/mqtt5_packet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PacketType = exports.RetainHandlingType = exports.QoS = exports.PayloadFormatIndicator = exports.isSuccessfulPubackReasonCode = exports.PubackReasonCode = exports.isSuccessfulUnsubackReasonCode = exports.UnsubackReasonCode = exports.isSuccessfulSubackReasonCode = exports.SubackReasonCode = exports.isSuccessfulDisconnectReasonCode = exports.DisconnectReasonCode = exports.isSuccessfulConnectReasonCode = exports.ConnectReasonCode = void 0;
    var ConnectReasonCode;
    (function(ConnectReasonCode2) {
      ConnectReasonCode2[ConnectReasonCode2["Success"] = 0] = "Success";
      ConnectReasonCode2[ConnectReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      ConnectReasonCode2[ConnectReasonCode2["MalformedPacket"] = 129] = "MalformedPacket";
      ConnectReasonCode2[ConnectReasonCode2["ProtocolError"] = 130] = "ProtocolError";
      ConnectReasonCode2[ConnectReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      ConnectReasonCode2[ConnectReasonCode2["UnsupportedProtocolVersion"] = 132] = "UnsupportedProtocolVersion";
      ConnectReasonCode2[ConnectReasonCode2["ClientIdentifierNotValid"] = 133] = "ClientIdentifierNotValid";
      ConnectReasonCode2[ConnectReasonCode2["BadUsernameOrPassword"] = 134] = "BadUsernameOrPassword";
      ConnectReasonCode2[ConnectReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      ConnectReasonCode2[ConnectReasonCode2["ServerUnavailable"] = 136] = "ServerUnavailable";
      ConnectReasonCode2[ConnectReasonCode2["ServerBusy"] = 137] = "ServerBusy";
      ConnectReasonCode2[ConnectReasonCode2["Banned"] = 138] = "Banned";
      ConnectReasonCode2[ConnectReasonCode2["BadAuthenticationMethod"] = 140] = "BadAuthenticationMethod";
      ConnectReasonCode2[ConnectReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      ConnectReasonCode2[ConnectReasonCode2["PacketTooLarge"] = 149] = "PacketTooLarge";
      ConnectReasonCode2[ConnectReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      ConnectReasonCode2[ConnectReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
      ConnectReasonCode2[ConnectReasonCode2["RetainNotSupported"] = 154] = "RetainNotSupported";
      ConnectReasonCode2[ConnectReasonCode2["QosNotSupported"] = 155] = "QosNotSupported";
      ConnectReasonCode2[ConnectReasonCode2["UseAnotherServer"] = 156] = "UseAnotherServer";
      ConnectReasonCode2[ConnectReasonCode2["ServerMoved"] = 157] = "ServerMoved";
      ConnectReasonCode2[ConnectReasonCode2["ConnectionRateExceeded"] = 159] = "ConnectionRateExceeded";
    })(ConnectReasonCode = exports.ConnectReasonCode || (exports.ConnectReasonCode = {}));
    function isSuccessfulConnectReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    exports.isSuccessfulConnectReasonCode = isSuccessfulConnectReasonCode;
    var DisconnectReasonCode;
    (function(DisconnectReasonCode2) {
      DisconnectReasonCode2[DisconnectReasonCode2["NormalDisconnection"] = 0] = "NormalDisconnection";
      DisconnectReasonCode2[DisconnectReasonCode2["DisconnectWithWillMessage"] = 4] = "DisconnectWithWillMessage";
      DisconnectReasonCode2[DisconnectReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      DisconnectReasonCode2[DisconnectReasonCode2["MalformedPacket"] = 129] = "MalformedPacket";
      DisconnectReasonCode2[DisconnectReasonCode2["ProtocolError"] = 130] = "ProtocolError";
      DisconnectReasonCode2[DisconnectReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      DisconnectReasonCode2[DisconnectReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerBusy"] = 137] = "ServerBusy";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerShuttingDown"] = 139] = "ServerShuttingDown";
      DisconnectReasonCode2[DisconnectReasonCode2["KeepAliveTimeout"] = 141] = "KeepAliveTimeout";
      DisconnectReasonCode2[DisconnectReasonCode2["SessionTakenOver"] = 142] = "SessionTakenOver";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["ReceiveMaximumExceeded"] = 147] = "ReceiveMaximumExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicAliasInvalid"] = 148] = "TopicAliasInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["PacketTooLarge"] = 149] = "PacketTooLarge";
      DisconnectReasonCode2[DisconnectReasonCode2["MessageRateTooHigh"] = 150] = "MessageRateTooHigh";
      DisconnectReasonCode2[DisconnectReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["AdministrativeAction"] = 152] = "AdministrativeAction";
      DisconnectReasonCode2[DisconnectReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["RetainNotSupported"] = 154] = "RetainNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["QosNotSupported"] = 155] = "QosNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["UseAnotherServer"] = 156] = "UseAnotherServer";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerMoved"] = 157] = "ServerMoved";
      DisconnectReasonCode2[DisconnectReasonCode2["SharedSubscriptionsNotSupported"] = 158] = "SharedSubscriptionsNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["ConnectionRateExceeded"] = 159] = "ConnectionRateExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["MaximumConnectTime"] = 160] = "MaximumConnectTime";
      DisconnectReasonCode2[DisconnectReasonCode2["SubscriptionIdentifiersNotSupported"] = 161] = "SubscriptionIdentifiersNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["WildcardSubscriptionsNotSupported"] = 162] = "WildcardSubscriptionsNotSupported";
    })(DisconnectReasonCode = exports.DisconnectReasonCode || (exports.DisconnectReasonCode = {}));
    function isSuccessfulDisconnectReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    exports.isSuccessfulDisconnectReasonCode = isSuccessfulDisconnectReasonCode;
    var SubackReasonCode;
    (function(SubackReasonCode2) {
      SubackReasonCode2[SubackReasonCode2["GrantedQoS0"] = 0] = "GrantedQoS0";
      SubackReasonCode2[SubackReasonCode2["GrantedQoS1"] = 1] = "GrantedQoS1";
      SubackReasonCode2[SubackReasonCode2["GrantedQoS2"] = 2] = "GrantedQoS2";
      SubackReasonCode2[SubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      SubackReasonCode2[SubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      SubackReasonCode2[SubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      SubackReasonCode2[SubackReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      SubackReasonCode2[SubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
      SubackReasonCode2[SubackReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      SubackReasonCode2[SubackReasonCode2["SharedSubscriptionsNotSupported"] = 158] = "SharedSubscriptionsNotSupported";
      SubackReasonCode2[SubackReasonCode2["SubscriptionIdentifiersNotSupported"] = 161] = "SubscriptionIdentifiersNotSupported";
      SubackReasonCode2[SubackReasonCode2["WildcardSubscriptionsNotSupported"] = 162] = "WildcardSubscriptionsNotSupported";
    })(SubackReasonCode = exports.SubackReasonCode || (exports.SubackReasonCode = {}));
    function isSuccessfulSubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    exports.isSuccessfulSubackReasonCode = isSuccessfulSubackReasonCode;
    var UnsubackReasonCode;
    (function(UnsubackReasonCode2) {
      UnsubackReasonCode2[UnsubackReasonCode2["Success"] = 0] = "Success";
      UnsubackReasonCode2[UnsubackReasonCode2["NoSubscriptionExisted"] = 17] = "NoSubscriptionExisted";
      UnsubackReasonCode2[UnsubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      UnsubackReasonCode2[UnsubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      UnsubackReasonCode2[UnsubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      UnsubackReasonCode2[UnsubackReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      UnsubackReasonCode2[UnsubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
    })(UnsubackReasonCode = exports.UnsubackReasonCode || (exports.UnsubackReasonCode = {}));
    function isSuccessfulUnsubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    exports.isSuccessfulUnsubackReasonCode = isSuccessfulUnsubackReasonCode;
    var PubackReasonCode;
    (function(PubackReasonCode2) {
      PubackReasonCode2[PubackReasonCode2["Success"] = 0] = "Success";
      PubackReasonCode2[PubackReasonCode2["NoMatchingSubscribers"] = 16] = "NoMatchingSubscribers";
      PubackReasonCode2[PubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      PubackReasonCode2[PubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      PubackReasonCode2[PubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      PubackReasonCode2[PubackReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      PubackReasonCode2[PubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
      PubackReasonCode2[PubackReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      PubackReasonCode2[PubackReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
    })(PubackReasonCode = exports.PubackReasonCode || (exports.PubackReasonCode = {}));
    function isSuccessfulPubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    exports.isSuccessfulPubackReasonCode = isSuccessfulPubackReasonCode;
    var PayloadFormatIndicator;
    (function(PayloadFormatIndicator2) {
      PayloadFormatIndicator2[PayloadFormatIndicator2["Bytes"] = 0] = "Bytes";
      PayloadFormatIndicator2[PayloadFormatIndicator2["Utf8"] = 1] = "Utf8";
    })(PayloadFormatIndicator = exports.PayloadFormatIndicator || (exports.PayloadFormatIndicator = {}));
    var QoS;
    (function(QoS2) {
      QoS2[QoS2["AtMostOnce"] = 0] = "AtMostOnce";
      QoS2[QoS2["AtLeastOnce"] = 1] = "AtLeastOnce";
      QoS2[QoS2["ExactlyOnce"] = 2] = "ExactlyOnce";
    })(QoS = exports.QoS || (exports.QoS = {}));
    var RetainHandlingType;
    (function(RetainHandlingType2) {
      RetainHandlingType2[RetainHandlingType2["SendOnSubscribe"] = 0] = "SendOnSubscribe";
      RetainHandlingType2[RetainHandlingType2["SendOnSubscribeIfNew"] = 1] = "SendOnSubscribeIfNew";
      RetainHandlingType2[RetainHandlingType2["DontSend"] = 2] = "DontSend";
    })(RetainHandlingType = exports.RetainHandlingType || (exports.RetainHandlingType = {}));
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["Connect"] = 1] = "Connect";
      PacketType2[PacketType2["Connack"] = 2] = "Connack";
      PacketType2[PacketType2["Publish"] = 3] = "Publish";
      PacketType2[PacketType2["Puback"] = 4] = "Puback";
      PacketType2[PacketType2["Pubrec"] = 5] = "Pubrec";
      PacketType2[PacketType2["Pubrel"] = 6] = "Pubrel";
      PacketType2[PacketType2["Pubcomp"] = 7] = "Pubcomp";
      PacketType2[PacketType2["Subscribe"] = 8] = "Subscribe";
      PacketType2[PacketType2["Suback"] = 9] = "Suback";
      PacketType2[PacketType2["Unsubscribe"] = 10] = "Unsubscribe";
      PacketType2[PacketType2["Unsuback"] = 11] = "Unsuback";
      PacketType2[PacketType2["Pingreq"] = 12] = "Pingreq";
      PacketType2[PacketType2["Pingresp"] = 13] = "Pingresp";
      PacketType2[PacketType2["Disconnect"] = 14] = "Disconnect";
      PacketType2[PacketType2["Auth"] = 15] = "Auth";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
  }
});

// node_modules/aws-crt/dist.browser/browser/error.js
var require_error = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/error.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrtError = void 0;
    var CrtError = (
      /** @class */
      function(_super) {
        __extends19(CrtError2, _super);
        function CrtError2(error) {
          var _this = _super.call(this, error.toString()) || this;
          _this.error = error;
          _this.error_name = error.toString();
          return _this;
        }
        return CrtError2;
      }(Error)
    );
    exports.CrtError = CrtError;
  }
});

// node_modules/aws-crt/dist.browser/common/mqtt_shared.js
var require_mqtt_shared = __commonJS({
  "node_modules/aws-crt/dist.browser/common/mqtt_shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_KEEP_ALIVE = exports.normalize_payload = void 0;
    function normalize_payload(payload) {
      if (payload instanceof Buffer) {
        return payload;
      }
      if (typeof payload === "string") {
        return payload;
      }
      if (ArrayBuffer.isView(payload)) {
        var view = payload;
        return Buffer.from(view.buffer, view.byteOffset, view.byteLength);
      }
      if (payload instanceof ArrayBuffer) {
        return Buffer.from(payload);
      }
      if (typeof payload === "object") {
        return JSON.stringify(payload);
      }
      if (!payload) {
        return "";
      }
      throw new TypeError("payload parameter must be a string, object, or DataView.");
    }
    exports.normalize_payload = normalize_payload;
    exports.DEFAULT_KEEP_ALIVE = 1200;
  }
});

// node_modules/aws-crt/dist.browser/common/utils.js
var require_utils = __commonJS({
  "node_modules/aws-crt/dist.browser/common/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.set_defined_property = void 0;
    function set_defined_property(object, propertyName, value) {
      if (value === void 0 || value == null) {
        return false;
      }
      object[propertyName] = value;
      return true;
    }
    exports.set_defined_property = set_defined_property;
  }
});

// node_modules/aws-crt/dist.browser/browser/mqtt5_utils.js
var require_mqtt5_utils = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/mqtt5_utils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read6 = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar2.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar2;
    };
    var __values6 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transform_mqtt_js_unsuback_to_crt_unsuback = exports.transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options = exports.transform_mqtt_js_puback_to_crt_puback = exports.transform_mqtt_js_publish_to_crt_publish = exports.transform_crt_publish_to_mqtt_js_publish_options = exports.transform_mqtt_js_subscription_grants_to_crt_suback = exports.transform_crt_subscribe_to_mqtt_js_subscribe_options = exports.transform_crt_subscribe_to_mqtt_js_subscription_map = exports.transform_mqtt_js_disconnect_to_crt_disconnect = exports.transform_crt_disconnect_to_mqtt_js_disconnect = exports.transform_mqtt_js_user_properties_to_crt_user_properties = exports.transform_crt_user_properties_to_mqtt_js_user_properties = exports.create_mqtt_js_client_config_from_crt_client_config = exports.compute_mqtt_js_reconnect_delay_from_crt_max_delay = exports.getOrderedReconnectDelayBounds = exports.create_negotiated_settings = exports.transform_mqtt_js_connack_to_crt_connack = exports.DEFAULT_MIN_CONNECTED_TIME_TO_RESET_RECONNECT_DELAY_MS = exports.DEFAULT_MAX_RECONNECT_DELAY_MS = exports.DEFAULT_MIN_RECONNECT_DELAY_MS = exports.DEFAULT_CONNECT_TIMEOUT_MS = exports.DEFAULT_RECEIVE_MAXIMUM = exports.MAXIMUM_PACKET_SIZE = exports.MAXIMUM_VARIABLE_LENGTH_INTEGER = void 0;
    var mqtt_shared = __importStar2(require_mqtt_shared());
    var mqtt5 = __importStar2(require_mqtt52());
    var utils = __importStar2(require_utils());
    var error_1 = require_error();
    exports.MAXIMUM_VARIABLE_LENGTH_INTEGER = 268435455;
    exports.MAXIMUM_PACKET_SIZE = 5 + exports.MAXIMUM_VARIABLE_LENGTH_INTEGER;
    exports.DEFAULT_RECEIVE_MAXIMUM = 65535;
    exports.DEFAULT_CONNECT_TIMEOUT_MS = 3e4;
    exports.DEFAULT_MIN_RECONNECT_DELAY_MS = 1e3;
    exports.DEFAULT_MAX_RECONNECT_DELAY_MS = 12e4;
    exports.DEFAULT_MIN_CONNECTED_TIME_TO_RESET_RECONNECT_DELAY_MS = 3e4;
    function transform_mqtt_js_connack_to_crt_connack(mqtt_js_connack) {
      var _a2, _b, _c2, _d2, _e2, _f2, _g, _h2, _j, _k, _l2, _m, _o2, _p, _q, _r2;
      if (mqtt_js_connack == null || mqtt_js_connack == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_connack_to_crt_connack: mqtt_js_connack not defined");
      }
      var connack = {
        type: mqtt5.PacketType.Connack,
        sessionPresent: mqtt_js_connack.sessionPresent,
        reasonCode: (_a2 = mqtt_js_connack.reasonCode) !== null && _a2 !== void 0 ? _a2 : mqtt5.ConnectReasonCode.Success
      };
      utils.set_defined_property(connack, "sessionExpiryInterval", (_b = mqtt_js_connack.properties) === null || _b === void 0 ? void 0 : _b.sessionExpiryInterval);
      utils.set_defined_property(connack, "receiveMaximum", (_c2 = mqtt_js_connack.properties) === null || _c2 === void 0 ? void 0 : _c2.receiveMaximum);
      utils.set_defined_property(connack, "maximumQos", (_d2 = mqtt_js_connack.properties) === null || _d2 === void 0 ? void 0 : _d2.maximumQoS);
      utils.set_defined_property(connack, "retainAvailable", (_e2 = mqtt_js_connack.properties) === null || _e2 === void 0 ? void 0 : _e2.retainAvailable);
      utils.set_defined_property(connack, "maximumPacketSize", (_f2 = mqtt_js_connack.properties) === null || _f2 === void 0 ? void 0 : _f2.maximumPacketSize);
      utils.set_defined_property(connack, "assignedClientIdentifier", (_g = mqtt_js_connack.properties) === null || _g === void 0 ? void 0 : _g.assignedClientIdentifier);
      utils.set_defined_property(connack, "topicAliasMaximum", (_h2 = mqtt_js_connack.properties) === null || _h2 === void 0 ? void 0 : _h2.topicAliasMaximum);
      utils.set_defined_property(connack, "reasonString", (_j = mqtt_js_connack.properties) === null || _j === void 0 ? void 0 : _j.reasonString);
      utils.set_defined_property(connack, "userProperties", transform_mqtt_js_user_properties_to_crt_user_properties((_k = mqtt_js_connack.properties) === null || _k === void 0 ? void 0 : _k.userProperties));
      utils.set_defined_property(connack, "wildcardSubscriptionsAvailable", (_l2 = mqtt_js_connack.properties) === null || _l2 === void 0 ? void 0 : _l2.wildcardSubscriptionAvailable);
      utils.set_defined_property(connack, "subscriptionIdentifiersAvailable", (_m = mqtt_js_connack.properties) === null || _m === void 0 ? void 0 : _m.subscriptionIdentifiersAvailable);
      utils.set_defined_property(connack, "sharedSubscriptionsAvailable", (_o2 = mqtt_js_connack.properties) === null || _o2 === void 0 ? void 0 : _o2.sharedSubscriptionAvailable);
      utils.set_defined_property(connack, "serverKeepAlive", (_p = mqtt_js_connack.properties) === null || _p === void 0 ? void 0 : _p.serverKeepAlive);
      utils.set_defined_property(connack, "responseInformation", (_q = mqtt_js_connack.properties) === null || _q === void 0 ? void 0 : _q.responseInformation);
      utils.set_defined_property(connack, "serverReference", (_r2 = mqtt_js_connack.properties) === null || _r2 === void 0 ? void 0 : _r2.serverReference);
      return connack;
    }
    exports.transform_mqtt_js_connack_to_crt_connack = transform_mqtt_js_connack_to_crt_connack;
    function create_negotiated_settings(config, connack) {
      var _a2, _b, _c2, _d2, _e2, _f2, _g, _h2, _j, _k, _l2, _m, _o2, _p, _q, _r2, _s2, _t2, _u2, _v, _w;
      if (config == null || config == void 0) {
        throw new error_1.CrtError("create_negotiated_settings: config not defined");
      }
      if (connack == null || connack == void 0) {
        throw new error_1.CrtError("create_negotiated_settings: connack not defined");
      }
      return {
        maximumQos: Math.min((_a2 = connack.maximumQos) !== null && _a2 !== void 0 ? _a2 : mqtt5.QoS.ExactlyOnce, mqtt5.QoS.AtLeastOnce),
        sessionExpiryInterval: (_d2 = (_b = connack.sessionExpiryInterval) !== null && _b !== void 0 ? _b : (_c2 = config.connectProperties) === null || _c2 === void 0 ? void 0 : _c2.sessionExpiryIntervalSeconds) !== null && _d2 !== void 0 ? _d2 : 0,
        receiveMaximumFromServer: (_e2 = connack.receiveMaximum) !== null && _e2 !== void 0 ? _e2 : exports.DEFAULT_RECEIVE_MAXIMUM,
        maximumPacketSizeToServer: (_f2 = connack.maximumPacketSize) !== null && _f2 !== void 0 ? _f2 : exports.MAXIMUM_PACKET_SIZE,
        topicAliasMaximumToServer: Math.min((_h2 = (_g = config.topicAliasingOptions) === null || _g === void 0 ? void 0 : _g.outboundCacheMaxSize) !== null && _h2 !== void 0 ? _h2 : 0, (_j = connack.topicAliasMaximum) !== null && _j !== void 0 ? _j : 0),
        topicAliasMaximumToClient: (_l2 = (_k = config.topicAliasingOptions) === null || _k === void 0 ? void 0 : _k.inboundCacheMaxSize) !== null && _l2 !== void 0 ? _l2 : 0,
        serverKeepAlive: (_p = (_m = connack.serverKeepAlive) !== null && _m !== void 0 ? _m : (_o2 = config.connectProperties) === null || _o2 === void 0 ? void 0 : _o2.keepAliveIntervalSeconds) !== null && _p !== void 0 ? _p : mqtt_shared.DEFAULT_KEEP_ALIVE,
        retainAvailable: (_q = connack.retainAvailable) !== null && _q !== void 0 ? _q : true,
        wildcardSubscriptionsAvailable: (_r2 = connack.wildcardSubscriptionsAvailable) !== null && _r2 !== void 0 ? _r2 : true,
        subscriptionIdentifiersAvailable: (_s2 = connack.subscriptionIdentifiersAvailable) !== null && _s2 !== void 0 ? _s2 : true,
        sharedSubscriptionsAvailable: (_t2 = connack.sharedSubscriptionsAvailable) !== null && _t2 !== void 0 ? _t2 : true,
        rejoinedSession: connack.sessionPresent,
        clientId: (_w = (_u2 = connack.assignedClientIdentifier) !== null && _u2 !== void 0 ? _u2 : (_v = config.connectProperties) === null || _v === void 0 ? void 0 : _v.clientId) !== null && _w !== void 0 ? _w : ""
      };
    }
    exports.create_negotiated_settings = create_negotiated_settings;
    function create_mqtt_js_will_from_crt_config(connectProperties) {
      var _a2, _b;
      if (!connectProperties || !connectProperties.will) {
        return void 0;
      }
      var crtWill = connectProperties.will;
      var hasWillProperties = false;
      var willProperties = {};
      hasWillProperties = utils.set_defined_property(willProperties, "willDelayInterval", connectProperties.willDelayIntervalSeconds) || hasWillProperties;
      if (crtWill.payloadFormat !== void 0) {
        hasWillProperties = utils.set_defined_property(willProperties, "payloadFormatIndicator", crtWill.payloadFormat == mqtt5.PayloadFormatIndicator.Utf8) || hasWillProperties;
      }
      hasWillProperties = utils.set_defined_property(willProperties, "messageExpiryInterval", crtWill.messageExpiryIntervalSeconds) || hasWillProperties;
      hasWillProperties = utils.set_defined_property(willProperties, "contentType", crtWill.contentType) || hasWillProperties;
      hasWillProperties = utils.set_defined_property(willProperties, "responseTopic", crtWill.responseTopic) || hasWillProperties;
      hasWillProperties = utils.set_defined_property(willProperties, "correlationData", crtWill.correlationData) || hasWillProperties;
      hasWillProperties = utils.set_defined_property(willProperties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties(crtWill.userProperties)) || hasWillProperties;
      var will = {
        topic: crtWill.topicName,
        payload: (_a2 = crtWill.payload) !== null && _a2 !== void 0 ? _a2 : "",
        qos: crtWill.qos,
        retain: (_b = crtWill.retain) !== null && _b !== void 0 ? _b : false
      };
      if (hasWillProperties) {
        will["properties"] = willProperties;
      }
      return will;
    }
    function getOrderedReconnectDelayBounds(configMin, configMax) {
      var minDelay = Math.max(1, configMin !== null && configMin !== void 0 ? configMin : exports.DEFAULT_MIN_RECONNECT_DELAY_MS);
      var maxDelay = Math.max(1, configMax !== null && configMax !== void 0 ? configMax : exports.DEFAULT_MAX_RECONNECT_DELAY_MS);
      if (minDelay > maxDelay) {
        return [maxDelay, minDelay];
      } else {
        return [minDelay, maxDelay];
      }
    }
    exports.getOrderedReconnectDelayBounds = getOrderedReconnectDelayBounds;
    function should_mqtt_js_use_clean_start(session_behavior) {
      return session_behavior !== mqtt5.ClientSessionBehavior.RejoinPostSuccess && session_behavior !== mqtt5.ClientSessionBehavior.RejoinAlways;
    }
    function compute_mqtt_js_reconnect_delay_from_crt_max_delay(maxReconnectDelayMs) {
      return maxReconnectDelayMs * 2 + 6e4;
    }
    exports.compute_mqtt_js_reconnect_delay_from_crt_max_delay = compute_mqtt_js_reconnect_delay_from_crt_max_delay;
    function validate_required_uint16(propertyName, value) {
      if (value < 0 || value > 65535) {
        throw new error_1.CrtError("Invalid value for property ".concat(propertyName, ": ") + value);
      }
    }
    function validate_optional_uint16(propertyName, value) {
      if (value !== void 0) {
        validate_required_uint16(propertyName, value);
      }
    }
    function validate_required_uint32(propertyName, value) {
      if (value < 0 || value >= 4294967296) {
        throw new error_1.CrtError("Invalid value for property ".concat(propertyName, ": ") + value);
      }
    }
    function validate_optional_uint32(propertyName, value) {
      if (value !== void 0) {
        validate_required_uint32(propertyName, value);
      }
    }
    function validate_required_nonnegative_uint32(propertyName, value) {
      if (value <= 0 || value >= 4294967296) {
        throw new error_1.CrtError("Invalid value for property ".concat(propertyName, ": ") + value);
      }
    }
    function validate_optional_nonnegative_uint32(propertyName, value) {
      if (value !== void 0) {
        validate_required_nonnegative_uint32(propertyName, value);
      }
    }
    function validate_mqtt5_client_config(crtConfig) {
      var _a2, _b, _c2, _d2, _e2, _f2;
      if (crtConfig == null || crtConfig == void 0) {
        throw new error_1.CrtError("validate_mqtt5_client_config: crtConfig not defined");
      }
      validate_required_uint16("keepAliveIntervalSeconds", (_b = (_a2 = crtConfig.connectProperties) === null || _a2 === void 0 ? void 0 : _a2.keepAliveIntervalSeconds) !== null && _b !== void 0 ? _b : 0);
      validate_optional_uint32("sessionExpiryIntervalSeconds", (_c2 = crtConfig.connectProperties) === null || _c2 === void 0 ? void 0 : _c2.sessionExpiryIntervalSeconds);
      validate_optional_uint16("receiveMaximum", (_d2 = crtConfig.connectProperties) === null || _d2 === void 0 ? void 0 : _d2.receiveMaximum);
      validate_optional_nonnegative_uint32("maximumPacketSizeBytes", (_e2 = crtConfig.connectProperties) === null || _e2 === void 0 ? void 0 : _e2.maximumPacketSizeBytes);
      validate_optional_uint32("willDelayIntervalSeconds", (_f2 = crtConfig.connectProperties) === null || _f2 === void 0 ? void 0 : _f2.willDelayIntervalSeconds);
    }
    function create_mqtt_js_client_config_from_crt_client_config(crtConfig) {
      var _a2, _b, _c2, _d2, _e2, _f2, _g, _h2, _j, _k, _l2, _m, _o2, _p;
      validate_mqtt5_client_config(crtConfig);
      var _q = __read6(getOrderedReconnectDelayBounds(crtConfig.minReconnectDelayMs, crtConfig.maxReconnectDelayMs), 2), _2 = _q[0], maxDelay = _q[1];
      maxDelay = compute_mqtt_js_reconnect_delay_from_crt_max_delay(maxDelay);
      var mqttJsClientConfig = {
        protocolVersion: 5,
        keepalive: (_b = (_a2 = crtConfig.connectProperties) === null || _a2 === void 0 ? void 0 : _a2.keepAliveIntervalSeconds) !== null && _b !== void 0 ? _b : mqtt_shared.DEFAULT_KEEP_ALIVE,
        connectTimeout: (_c2 = crtConfig.connectTimeoutMs) !== null && _c2 !== void 0 ? _c2 : exports.DEFAULT_CONNECT_TIMEOUT_MS,
        clean: should_mqtt_js_use_clean_start(crtConfig.sessionBehavior),
        reconnectPeriod: maxDelay,
        // @ts-ignore
        autoUseTopicAlias: false,
        // @ts-ignore
        autoAssignTopicAlias: false,
        queueQoSZero: false,
        transformWsUrl: void 0,
        resubscribe: false
      };
      var topic_aliasing_options = crtConfig.topicAliasingOptions;
      if (topic_aliasing_options) {
        switch ((_d2 = topic_aliasing_options.outboundBehavior) !== null && _d2 !== void 0 ? _d2 : mqtt5.OutboundTopicAliasBehaviorType.Default) {
          case mqtt5.OutboundTopicAliasBehaviorType.LRU:
            mqttJsClientConfig.autoUseTopicAlias = true;
            mqttJsClientConfig.autoAssignTopicAlias = true;
            break;
          case mqtt5.OutboundTopicAliasBehaviorType.Manual:
            mqttJsClientConfig.autoUseTopicAlias = true;
            break;
          default:
            break;
        }
      }
      utils.set_defined_property(mqttJsClientConfig, "clientId", (_f2 = (_e2 = crtConfig.connectProperties) === null || _e2 === void 0 ? void 0 : _e2.clientId) !== null && _f2 !== void 0 ? _f2 : "");
      utils.set_defined_property(mqttJsClientConfig, "username", (_g = crtConfig.connectProperties) === null || _g === void 0 ? void 0 : _g.username);
      utils.set_defined_property(mqttJsClientConfig, "password", (_h2 = crtConfig.connectProperties) === null || _h2 === void 0 ? void 0 : _h2.password);
      utils.set_defined_property(mqttJsClientConfig, "will", create_mqtt_js_will_from_crt_config(crtConfig.connectProperties));
      var hasProperties = false;
      var properties = {};
      hasProperties = utils.set_defined_property(properties, "sessionExpiryInterval", (_j = crtConfig.connectProperties) === null || _j === void 0 ? void 0 : _j.sessionExpiryIntervalSeconds) || hasProperties;
      hasProperties = utils.set_defined_property(properties, "receiveMaximum", (_k = crtConfig.connectProperties) === null || _k === void 0 ? void 0 : _k.receiveMaximum) || hasProperties;
      hasProperties = utils.set_defined_property(properties, "maximumPacketSize", (_l2 = crtConfig.connectProperties) === null || _l2 === void 0 ? void 0 : _l2.maximumPacketSizeBytes) || hasProperties;
      hasProperties = utils.set_defined_property(properties, "requestResponseInformation", (_m = crtConfig.connectProperties) === null || _m === void 0 ? void 0 : _m.requestResponseInformation) || hasProperties;
      hasProperties = utils.set_defined_property(properties, "requestProblemInformation", (_o2 = crtConfig.connectProperties) === null || _o2 === void 0 ? void 0 : _o2.requestProblemInformation) || hasProperties;
      hasProperties = utils.set_defined_property(properties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties((_p = crtConfig.connectProperties) === null || _p === void 0 ? void 0 : _p.userProperties)) || hasProperties;
      if (hasProperties) {
        mqttJsClientConfig["properties"] = properties;
      }
      return mqttJsClientConfig;
    }
    exports.create_mqtt_js_client_config_from_crt_client_config = create_mqtt_js_client_config_from_crt_client_config;
    function transform_crt_user_properties_to_mqtt_js_user_properties(userProperties) {
      var e_1, _a2;
      if (!userProperties) {
        return void 0;
      }
      var mqttJsProperties = {};
      try {
        for (var userProperties_1 = __values6(userProperties), userProperties_1_1 = userProperties_1.next(); !userProperties_1_1.done; userProperties_1_1 = userProperties_1.next()) {
          var property = userProperties_1_1.value;
          var key = property.name;
          if (!(key in mqttJsProperties)) {
            mqttJsProperties[key] = [];
          }
          mqttJsProperties[key].push(property.value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (userProperties_1_1 && !userProperties_1_1.done && (_a2 = userProperties_1.return))
            _a2.call(userProperties_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return mqttJsProperties;
    }
    exports.transform_crt_user_properties_to_mqtt_js_user_properties = transform_crt_user_properties_to_mqtt_js_user_properties;
    function transform_mqtt_js_user_properties_to_crt_user_properties(userProperties) {
      var e_2, _a2, e_3, _b;
      if (!userProperties) {
        return void 0;
      }
      var crtProperties = void 0;
      try {
        for (var _c2 = __values6(Object.entries(userProperties)), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
          var _e2 = __read6(_d2.value, 2), propName = _e2[0], propValue = _e2[1];
          var values = typeof propValue === "string" ? [propValue] : propValue;
          try {
            for (var values_1 = (e_3 = void 0, __values6(values)), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
              var valueIter = values_1_1.value;
              var propertyEntry = { name: propName, value: valueIter };
              if (!crtProperties) {
                crtProperties = [propertyEntry];
              } else {
                crtProperties.push(propertyEntry);
              }
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (values_1_1 && !values_1_1.done && (_b = values_1.return))
                _b.call(values_1);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_d2 && !_d2.done && (_a2 = _c2.return))
            _a2.call(_c2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return crtProperties;
    }
    exports.transform_mqtt_js_user_properties_to_crt_user_properties = transform_mqtt_js_user_properties_to_crt_user_properties;
    function validate_crt_disconnect(disconnect) {
      if (disconnect == null || disconnect == void 0) {
        throw new error_1.CrtError("validate_crt_disconnect: disconnect not defined");
      }
      validate_optional_uint32("sessionExpiryIntervalSeconds", disconnect.sessionExpiryIntervalSeconds);
    }
    function transform_crt_disconnect_to_mqtt_js_disconnect(disconnect) {
      validate_crt_disconnect(disconnect);
      var properties = {};
      var propertiesValid = false;
      propertiesValid = utils.set_defined_property(properties, "sessionExpiryInterval", disconnect.sessionExpiryIntervalSeconds) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "reasonString", disconnect.reasonString) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties(disconnect.userProperties)) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "serverReference", disconnect.serverReference) || propertiesValid;
      var mqttJsDisconnect = {
        cmd: "disconnect",
        reasonCode: disconnect.reasonCode
      };
      if (propertiesValid) {
        mqttJsDisconnect["properties"] = properties;
      }
      return mqttJsDisconnect;
    }
    exports.transform_crt_disconnect_to_mqtt_js_disconnect = transform_crt_disconnect_to_mqtt_js_disconnect;
    function transform_mqtt_js_disconnect_to_crt_disconnect(disconnect) {
      var _a2, _b, _c2, _d2, _e2;
      if (disconnect == null || disconnect == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_disconnect_to_crt_disconnect: disconnect not defined");
      }
      var crtDisconnect = {
        type: mqtt5.PacketType.Disconnect,
        reasonCode: (_a2 = disconnect.reasonCode) !== null && _a2 !== void 0 ? _a2 : mqtt5.DisconnectReasonCode.NormalDisconnection
      };
      utils.set_defined_property(crtDisconnect, "sessionExpiryIntervalSeconds", (_b = disconnect.properties) === null || _b === void 0 ? void 0 : _b.sessionExpiryInterval);
      utils.set_defined_property(crtDisconnect, "reasonString", (_c2 = disconnect.properties) === null || _c2 === void 0 ? void 0 : _c2.reasonString);
      utils.set_defined_property(crtDisconnect, "userProperties", transform_mqtt_js_user_properties_to_crt_user_properties((_d2 = disconnect.properties) === null || _d2 === void 0 ? void 0 : _d2.userProperties));
      utils.set_defined_property(crtDisconnect, "serverReference", (_e2 = disconnect.properties) === null || _e2 === void 0 ? void 0 : _e2.serverReference);
      return crtDisconnect;
    }
    exports.transform_mqtt_js_disconnect_to_crt_disconnect = transform_mqtt_js_disconnect_to_crt_disconnect;
    function validate_crt_subscribe(subscribe) {
      if (subscribe == null || subscribe == void 0) {
        throw new error_1.CrtError("validate_crt_subscribe: subscribe not defined");
      }
      validate_optional_uint32("subscriptionIdentifier", subscribe.subscriptionIdentifier);
    }
    function transform_crt_subscribe_to_mqtt_js_subscription_map(subscribe) {
      var e_4, _a2;
      var _b, _c2, _d2;
      validate_crt_subscribe(subscribe);
      var subscriptionMap = {};
      try {
        for (var _e2 = __values6(subscribe.subscriptions), _f2 = _e2.next(); !_f2.done; _f2 = _e2.next()) {
          var subscription = _f2.value;
          var mqttJsSub = {
            qos: subscription.qos,
            nl: (_b = subscription.noLocal) !== null && _b !== void 0 ? _b : false,
            rap: (_c2 = subscription.retainAsPublished) !== null && _c2 !== void 0 ? _c2 : false,
            rh: (_d2 = subscription.retainHandlingType) !== null && _d2 !== void 0 ? _d2 : mqtt5.RetainHandlingType.SendOnSubscribe
          };
          subscriptionMap[subscription.topicFilter] = mqttJsSub;
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_f2 && !_f2.done && (_a2 = _e2.return))
            _a2.call(_e2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return subscriptionMap;
    }
    exports.transform_crt_subscribe_to_mqtt_js_subscription_map = transform_crt_subscribe_to_mqtt_js_subscription_map;
    function transform_crt_subscribe_to_mqtt_js_subscribe_options(subscribe) {
      var properties = {};
      var propertiesValid = false;
      if (subscribe == null || subscribe == void 0) {
        throw new error_1.CrtError("transform_crt_subscribe_to_mqtt_js_subscribe_options: subscribe not defined");
      }
      propertiesValid = utils.set_defined_property(properties, "subscriptionIdentifier", subscribe.subscriptionIdentifier) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties(subscribe.userProperties)) || propertiesValid;
      var options = {
        qos: 0
      };
      if (propertiesValid) {
        options["properties"] = properties;
      }
      return options;
    }
    exports.transform_crt_subscribe_to_mqtt_js_subscribe_options = transform_crt_subscribe_to_mqtt_js_subscribe_options;
    function transform_mqtt_js_subscription_grants_to_crt_suback(subscriptionsGranted) {
      if (subscriptionsGranted == null || subscriptionsGranted == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_subscription_grants_to_crt_suback: subscriptionsGranted not defined");
      }
      var crtSuback = {
        type: mqtt5.PacketType.Suback,
        reasonCodes: subscriptionsGranted.map(function(subscription, index, array) {
          return subscription.qos;
        })
      };
      return crtSuback;
    }
    exports.transform_mqtt_js_subscription_grants_to_crt_suback = transform_mqtt_js_subscription_grants_to_crt_suback;
    function validate_crt_publish(publish) {
      if (publish == null || publish == void 0) {
        throw new error_1.CrtError("validate_crt_publish: publish not defined");
      }
      validate_optional_uint32("messageExpiryIntervalSeconds", publish.messageExpiryIntervalSeconds);
    }
    function transform_crt_publish_to_mqtt_js_publish_options(publish) {
      var _a2;
      validate_crt_publish(publish);
      var properties = {};
      var propertiesValid = false;
      if (publish.payloadFormat !== void 0) {
        propertiesValid = utils.set_defined_property(properties, "payloadFormatIndicator", publish.payloadFormat == mqtt5.PayloadFormatIndicator.Utf8) || propertiesValid;
      }
      propertiesValid = utils.set_defined_property(properties, "messageExpiryInterval", publish.messageExpiryIntervalSeconds) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "responseTopic", publish.responseTopic) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "correlationData", publish.correlationData) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties(publish.userProperties)) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "contentType", publish.contentType) || propertiesValid;
      propertiesValid = utils.set_defined_property(properties, "topicAlias", publish.topicAlias) || propertiesValid;
      var mqttJsPublish = {
        qos: publish.qos,
        retain: (_a2 = publish.retain) !== null && _a2 !== void 0 ? _a2 : false
      };
      if (propertiesValid) {
        mqttJsPublish["properties"] = properties;
      }
      return mqttJsPublish;
    }
    exports.transform_crt_publish_to_mqtt_js_publish_options = transform_crt_publish_to_mqtt_js_publish_options;
    function transform_mqtt_js_publish_to_crt_publish(publish) {
      var _a2, _b, _c2, _d2, _e2, _f2;
      if (publish == null || publish == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_publish_to_crt_publish: publish not defined");
      }
      var crtPublish = {
        type: mqtt5.PacketType.Publish,
        qos: publish.qos,
        retain: publish.retain,
        topicName: publish.topic,
        payload: publish.payload
      };
      if (publish.properties) {
        if (publish.properties.payloadFormatIndicator !== void 0) {
          utils.set_defined_property(crtPublish, "payloadFormat", publish.properties.payloadFormatIndicator ? mqtt5.PayloadFormatIndicator.Utf8 : mqtt5.PayloadFormatIndicator.Bytes);
        }
        utils.set_defined_property(crtPublish, "messageExpiryIntervalSeconds", (_a2 = publish.properties) === null || _a2 === void 0 ? void 0 : _a2.messageExpiryInterval);
        utils.set_defined_property(crtPublish, "responseTopic", (_b = publish.properties) === null || _b === void 0 ? void 0 : _b.responseTopic);
        utils.set_defined_property(crtPublish, "correlationData", (_c2 = publish.properties) === null || _c2 === void 0 ? void 0 : _c2.correlationData);
        utils.set_defined_property(crtPublish, "userProperties", transform_mqtt_js_user_properties_to_crt_user_properties((_d2 = publish.properties) === null || _d2 === void 0 ? void 0 : _d2.userProperties));
        utils.set_defined_property(crtPublish, "contentType", (_e2 = publish.properties) === null || _e2 === void 0 ? void 0 : _e2.contentType);
        var subIds = (_f2 = publish.properties) === null || _f2 === void 0 ? void 0 : _f2.subscriptionIdentifier;
        var subIdsType = typeof subIds;
        if (subIds) {
          if (subIdsType == "number") {
            crtPublish["subscriptionIdentifiers"] = [subIds];
          } else if (Array.isArray(subIds)) {
            crtPublish["subscriptionIdentifiers"] = subIds;
          }
        }
      }
      return crtPublish;
    }
    exports.transform_mqtt_js_publish_to_crt_publish = transform_mqtt_js_publish_to_crt_publish;
    function transform_mqtt_js_puback_to_crt_puback(puback) {
      var _a2, _b, _c2;
      if (puback == null || puback == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_puback_to_crt_puback: puback not defined");
      }
      var crtPuback = {
        type: mqtt5.PacketType.Puback,
        reasonCode: (_a2 = puback.reasonCode) !== null && _a2 !== void 0 ? _a2 : mqtt5.PubackReasonCode.Success
      };
      if (puback.properties) {
        utils.set_defined_property(crtPuback, "reasonString", (_b = puback.properties) === null || _b === void 0 ? void 0 : _b.reasonString);
        utils.set_defined_property(crtPuback, "userProperties", transform_mqtt_js_user_properties_to_crt_user_properties((_c2 = puback.properties) === null || _c2 === void 0 ? void 0 : _c2.userProperties));
      }
      return crtPuback;
    }
    exports.transform_mqtt_js_puback_to_crt_puback = transform_mqtt_js_puback_to_crt_puback;
    function transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options(unsubscribe) {
      if (unsubscribe == null || unsubscribe == void 0) {
        throw new error_1.CrtError("transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options: unsubscribe not defined");
      }
      var properties = {};
      var propertiesValid = false;
      propertiesValid = utils.set_defined_property(properties, "userProperties", transform_crt_user_properties_to_mqtt_js_user_properties(unsubscribe.userProperties));
      var options = {};
      if (propertiesValid) {
        options["properties"] = properties;
      }
      return options;
    }
    exports.transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options = transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options;
    function transform_mqtt_js_unsuback_to_crt_unsuback(packet) {
      var _a2, _b;
      if (packet == null || packet == void 0) {
        throw new error_1.CrtError("transform_mqtt_js_unsuback_to_crt_unsuback: packet not defined");
      }
      var reasonCodes = packet.reasonCode;
      var codes;
      if (Array.isArray(reasonCodes)) {
        codes = reasonCodes;
      } else if (typeof reasonCodes == "number") {
        codes = [reasonCodes];
      } else {
        codes = [];
      }
      var crtUnsuback = {
        type: mqtt5.PacketType.Unsuback,
        reasonCodes: codes
      };
      if (packet.properties) {
        utils.set_defined_property(crtUnsuback, "reasonString", (_a2 = packet.properties) === null || _a2 === void 0 ? void 0 : _a2.reasonString);
        utils.set_defined_property(crtUnsuback, "userProperties", transform_mqtt_js_user_properties_to_crt_user_properties((_b = packet.properties) === null || _b === void 0 ? void 0 : _b.userProperties));
      }
      return crtUnsuback;
    }
    exports.transform_mqtt_js_unsuback_to_crt_unsuback = transform_mqtt_js_unsuback_to_crt_unsuback;
  }
});

// node_modules/aws-crt/dist.browser/browser/mqtt5.js
var require_mqtt52 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/mqtt5.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar2 = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m2, p);
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator9 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op2) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
              return t;
            if (y = 0, t)
              op2 = [op2[0] & 2, t.value];
            switch (op2[0]) {
              case 0:
              case 1:
                t = op2;
                break;
              case 4:
                _2.label++;
                return { value: op2[1], done: false };
              case 5:
                _2.label++;
                y = op2[1];
                op2 = [0];
                continue;
              case 7:
                op2 = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                  _2.label = op2[1];
                  break;
                }
                if (op2[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op2;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op2);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op2 = body.call(thisArg, _2);
          } catch (e) {
            op2 = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op2[0] & 5)
          throw op2[1];
        return { value: op2[0] ? op2[1] : void 0, done: true };
      }
    };
    var __read6 = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar2.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mqtt5Client = exports.Mqtt5WebsocketUrlFactoryType = void 0;
    var event_1 = require_event();
    var mqtt = __importStar2(require_connect());
    var mqtt5 = __importStar2(require_mqtt5());
    var mqtt5_1 = require_mqtt5();
    var mqtt5_packet = __importStar2(require_mqtt5_packet());
    var error_1 = require_error();
    var WebsocketUtils = __importStar2(require_ws2());
    var mqtt_utils = __importStar2(require_mqtt5_utils());
    var mqtt_shared = __importStar2(require_mqtt_shared());
    __exportStar2(require_mqtt5(), exports);
    __exportStar2(require_mqtt5_packet(), exports);
    var Mqtt5WebsocketUrlFactoryType;
    (function(Mqtt5WebsocketUrlFactoryType2) {
      Mqtt5WebsocketUrlFactoryType2[Mqtt5WebsocketUrlFactoryType2["Ws"] = 1] = "Ws";
      Mqtt5WebsocketUrlFactoryType2[Mqtt5WebsocketUrlFactoryType2["Wss"] = 2] = "Wss";
      Mqtt5WebsocketUrlFactoryType2[Mqtt5WebsocketUrlFactoryType2["Sigv4"] = 3] = "Sigv4";
      Mqtt5WebsocketUrlFactoryType2[Mqtt5WebsocketUrlFactoryType2["Custom"] = 4] = "Custom";
    })(Mqtt5WebsocketUrlFactoryType = exports.Mqtt5WebsocketUrlFactoryType || (exports.Mqtt5WebsocketUrlFactoryType = {}));
    var ReconnectionScheduler = (
      /** @class */
      function() {
        function ReconnectionScheduler2(browserClient, clientConfig) {
          this.browserClient = browserClient;
          this.clientConfig = clientConfig;
          this.connectionFailureCount = 0;
          this.lastReconnectDelay = 0;
          this.resetConnectionFailureCountTask = void 0;
          this.reconnectionTask = void 0;
          this.lastReconnectDelay = void 0;
        }
        ReconnectionScheduler2.prototype.onSuccessfulConnection = function() {
          var _this = this;
          var _a2;
          this.clearTasks();
          this.resetConnectionFailureCountTask = setTimeout(function() {
            _this.connectionFailureCount = 0;
            _this.lastReconnectDelay = void 0;
          }, (_a2 = this.clientConfig.minConnectedTimeToResetReconnectDelayMs) !== null && _a2 !== void 0 ? _a2 : mqtt_utils.DEFAULT_MIN_CONNECTED_TIME_TO_RESET_RECONNECT_DELAY_MS);
        };
        ReconnectionScheduler2.prototype.onConnectionFailureOrDisconnection = function() {
          var _this = this;
          this.clearTasks();
          var nextDelay = this.calculateNextReconnectDelay();
          this.lastReconnectDelay = nextDelay;
          this.connectionFailureCount += 1;
          this.reconnectionTask = setTimeout(function() {
            return __awaiter2(_this, void 0, void 0, function() {
              var wsOptions, sigv4Options;
              return __generator9(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    wsOptions = this.clientConfig.websocketOptions;
                    if (!(wsOptions && wsOptions.urlFactoryOptions.urlFactory == Mqtt5WebsocketUrlFactoryType.Sigv4))
                      return [3, 2];
                    sigv4Options = wsOptions.urlFactoryOptions;
                    if (!sigv4Options.credentialsProvider)
                      return [3, 2];
                    return [4, sigv4Options.credentialsProvider.refreshCredentials()];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.browserClient.reconnect();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }, nextDelay);
        };
        ReconnectionScheduler2.prototype.clearTasks = function() {
          if (this.reconnectionTask) {
            clearTimeout(this.reconnectionTask);
          }
          if (this.resetConnectionFailureCountTask) {
            clearTimeout(this.resetConnectionFailureCountTask);
          }
        };
        ReconnectionScheduler2.prototype.randomInRange = function(min, max) {
          return min + (max - min) * Math.random();
        };
        ReconnectionScheduler2.prototype.calculateNextReconnectDelay = function() {
          var _a2;
          var jitterType = (_a2 = this.clientConfig.retryJitterMode) !== null && _a2 !== void 0 ? _a2 : mqtt5.RetryJitterType.Default;
          var _b = __read6(mqtt_utils.getOrderedReconnectDelayBounds(this.clientConfig.minReconnectDelayMs, this.clientConfig.maxReconnectDelayMs), 2), minDelay = _b[0], maxDelay = _b[1];
          var clampedFailureCount = Math.min(52, this.connectionFailureCount);
          var delay = 0;
          if (jitterType == mqtt5.RetryJitterType.None) {
            delay = minDelay * Math.pow(2, clampedFailureCount);
          } else if (jitterType == mqtt5.RetryJitterType.Decorrelated && this.lastReconnectDelay) {
            delay = this.randomInRange(minDelay, 3 * this.lastReconnectDelay);
          } else {
            delay = this.randomInRange(minDelay, Math.min(maxDelay, minDelay * Math.pow(2, clampedFailureCount)));
          }
          delay = Math.min(maxDelay, delay);
          this.lastReconnectDelay = delay;
          return delay;
        };
        return ReconnectionScheduler2;
      }()
    );
    var Mqtt5ClientState;
    (function(Mqtt5ClientState2) {
      Mqtt5ClientState2[Mqtt5ClientState2["Stopped"] = 0] = "Stopped";
      Mqtt5ClientState2[Mqtt5ClientState2["Running"] = 1] = "Running";
      Mqtt5ClientState2[Mqtt5ClientState2["Stopping"] = 2] = "Stopping";
      Mqtt5ClientState2[Mqtt5ClientState2["Restarting"] = 3] = "Restarting";
    })(Mqtt5ClientState || (Mqtt5ClientState = {}));
    var Mqtt5ClientLifecycleEventState;
    (function(Mqtt5ClientLifecycleEventState2) {
      Mqtt5ClientLifecycleEventState2[Mqtt5ClientLifecycleEventState2["None"] = 0] = "None";
      Mqtt5ClientLifecycleEventState2[Mqtt5ClientLifecycleEventState2["Connecting"] = 1] = "Connecting";
      Mqtt5ClientLifecycleEventState2[Mqtt5ClientLifecycleEventState2["Connected"] = 2] = "Connected";
      Mqtt5ClientLifecycleEventState2[Mqtt5ClientLifecycleEventState2["Disconnected"] = 3] = "Disconnected";
    })(Mqtt5ClientLifecycleEventState || (Mqtt5ClientLifecycleEventState = {}));
    var Mqtt5Client = (
      /** @class */
      function(_super) {
        __extends19(Mqtt5Client2, _super);
        function Mqtt5Client2(config) {
          var _this = _super.call(this) || this;
          _this.config = config;
          _this.on_message = function(topic, payload, packet) {
            var crtPublish = mqtt_utils.transform_mqtt_js_publish_to_crt_publish(packet);
            var messageReceivedEvent = {
              message: crtPublish
            };
            setTimeout(function() {
              _this.emit(Mqtt5Client2.MESSAGE_RECEIVED, messageReceivedEvent);
            }, 0);
          };
          _this.mqttJsConfig = mqtt_utils.create_mqtt_js_client_config_from_crt_client_config(_this.config);
          _this.state = Mqtt5ClientState.Stopped;
          _this.lifecycleEventState = Mqtt5ClientLifecycleEventState.None;
          _this.topicAliasBindings = /* @__PURE__ */ new Map();
          return _this;
        }
        Mqtt5Client2.prototype.close = function() {
        };
        Mqtt5Client2.prototype.start = function() {
          var _this = this;
          if (this.state == Mqtt5ClientState.Stopped) {
            this.lifecycleEventState = Mqtt5ClientLifecycleEventState.Connecting;
            this.lastDisconnect = void 0;
            this.cork();
            this.emit("attemptingConnect");
            var create_websocket_stream = function(client) {
              return WebsocketUtils.create_mqtt5_websocket_stream(_this.config);
            };
            this.browserClient = new mqtt.MqttClient(create_websocket_stream, this.mqttJsConfig);
            this.browserClient.on("end", function() {
              _this._on_stopped_internal();
            });
            this.browserClient.on("reconnect", function() {
              _this.on_attempting_connect();
            });
            this.browserClient.on("connect", function(connack) {
              _this.on_connection_success(connack);
            });
            this.browserClient.on("message", function(topic, payload, packet) {
              _this.on_message(topic, payload, packet);
            });
            this.browserClient.on("error", function(error) {
              _this.on_browser_client_error(error);
            });
            this.browserClient.on("close", function() {
              _this.on_browser_close();
            });
            this.browserClient.on("disconnect", function(packet) {
              _this.on_browser_disconnect_packet(packet);
            });
            this.reconnectionScheduler = new ReconnectionScheduler(this.browserClient, this.config);
            this.state = Mqtt5ClientState.Running;
            this.uncork();
          } else if (this.state == Mqtt5ClientState.Stopping) {
            this.state = Mqtt5ClientState.Restarting;
          }
        };
        Mqtt5Client2.prototype.stop = function(disconnectPacket) {
          var _a2, _b;
          if (this.state == Mqtt5ClientState.Running) {
            if (disconnectPacket) {
              (_a2 = this.browserClient) === null || _a2 === void 0 ? void 0 : _a2.end(true, mqtt_utils.transform_crt_disconnect_to_mqtt_js_disconnect(disconnectPacket));
            } else {
              (_b = this.browserClient) === null || _b === void 0 ? void 0 : _b.end(true);
            }
            this.state = Mqtt5ClientState.Stopping;
          } else if (this.state == Mqtt5ClientState.Restarting) {
            this.state = Mqtt5ClientState.Stopping;
          }
        };
        Mqtt5Client2.prototype.subscribe = function(packet) {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              return [2, new Promise(function(resolve, reject) {
                try {
                  if (!_this.browserClient) {
                    reject(new Error("Client is stopped and cannot subscribe"));
                    return;
                  }
                  if (!packet) {
                    reject(new Error("Invalid subscribe packet"));
                    return;
                  }
                  var subMap = mqtt_utils.transform_crt_subscribe_to_mqtt_js_subscription_map(packet);
                  var subOptions = mqtt_utils.transform_crt_subscribe_to_mqtt_js_subscribe_options(packet);
                  _this.browserClient.subscribe(subMap, subOptions, function(error, grants) {
                    if (error) {
                      reject(error);
                      return;
                    }
                    var suback = mqtt_utils.transform_mqtt_js_subscription_grants_to_crt_suback(grants);
                    resolve(suback);
                  });
                } catch (err) {
                  reject(err);
                }
              })];
            });
          });
        };
        Mqtt5Client2.prototype.unsubscribe = function(packet) {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              return [2, new Promise(function(resolve, reject) {
                try {
                  if (!_this.browserClient) {
                    reject(new Error("Client is stopped and cannot unsubscribe"));
                    return;
                  }
                  if (!packet) {
                    reject(new Error("Invalid unsubscribe packet"));
                    return;
                  }
                  var topicFilters_1 = packet.topicFilters;
                  var unsubOptions = mqtt_utils.transform_crt_unsubscribe_to_mqtt_js_unsubscribe_options(packet);
                  _this.browserClient.unsubscribe(topicFilters_1, unsubOptions, function(error, packet2) {
                    if (error) {
                      reject(error);
                      return;
                    }
                    if (!packet2 || packet2.cmd !== "unsuback") {
                      var unsuback = {
                        type: mqtt5_packet.PacketType.Unsuback,
                        reasonCodes: topicFilters_1.map(function(filter, index, array) {
                          return mqtt5_packet.UnsubackReasonCode.Success;
                        })
                      };
                      resolve(unsuback);
                    } else {
                      var unsuback = mqtt_utils.transform_mqtt_js_unsuback_to_crt_unsuback(packet2);
                      resolve(unsuback);
                    }
                  });
                } catch (err) {
                  reject(err);
                }
              })];
            });
          });
        };
        Mqtt5Client2.prototype.reset_topic_aliases = function() {
          this.topicAliasBindings.clear();
        };
        Mqtt5Client2.prototype.bind_topic_alias = function(alias, topic) {
          this.topicAliasBindings.set(alias, topic);
        };
        Mqtt5Client2.prototype.is_topic_alias_bound = function(alias, topic) {
          if (!topic) {
            return false;
          }
          return this.topicAliasBindings.get(alias) === topic;
        };
        Mqtt5Client2.prototype.publish = function(packet) {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              return [2, new Promise(function(resolve, reject) {
                var _a3, _b;
                try {
                  if (!_this.browserClient) {
                    reject(new Error("Client is stopped and cannot publish"));
                    return;
                  }
                  if (!packet) {
                    reject(new Error("Invalid publish packet"));
                    return;
                  }
                  if (((_b = (_a3 = _this.config.topicAliasingOptions) === null || _a3 === void 0 ? void 0 : _a3.outboundBehavior) !== null && _b !== void 0 ? _b : mqtt5_1.OutboundTopicAliasBehaviorType.Default) == mqtt5_1.OutboundTopicAliasBehaviorType.Manual) {
                    if (packet.topicAlias && _this.lifecycleEventState == Mqtt5ClientLifecycleEventState.Connected) {
                      if (_this.is_topic_alias_bound(packet.topicAlias, packet.topicName)) {
                        delete packet.topicAlias;
                      }
                      _this.bind_topic_alias(packet.topicAlias, packet.topicName);
                    }
                  } else {
                    delete packet.topicAlias;
                  }
                  var publishOptions = mqtt_utils.transform_crt_publish_to_mqtt_js_publish_options(packet);
                  var qos_1 = packet.qos;
                  var payload = mqtt_shared.normalize_payload(packet.payload);
                  _this.browserClient.publish(packet.topicName, payload, publishOptions, function(error, completionPacket) {
                    if (error) {
                      reject(error);
                      return;
                    }
                    switch (qos_1) {
                      case mqtt5_packet.QoS.AtMostOnce:
                        resolve(void 0);
                        break;
                      case mqtt5_packet.QoS.AtLeastOnce:
                        if (!completionPacket) {
                          reject(new Error("Invalid puback packet from mqtt-js"));
                          return;
                        }
                        if (completionPacket.cmd !== "puback") {
                          resolve({
                            type: mqtt5_packet.PacketType.Puback,
                            reasonCode: mqtt5_packet.PubackReasonCode.Success
                          });
                        }
                        var puback = mqtt_utils.transform_mqtt_js_puback_to_crt_puback(completionPacket);
                        resolve(puback);
                        break;
                      default:
                        reject(new Error("Unsupported QoS value"));
                        break;
                    }
                  });
                } catch (err) {
                  reject(err);
                }
              })];
            });
          });
        };
        Mqtt5Client2.prototype.on = function(event, listener) {
          _super.prototype.on.call(this, event, listener);
          return this;
        };
        Mqtt5Client2.prototype.on_browser_disconnect_packet = function(packet) {
          this.lastDisconnect = mqtt_utils.transform_mqtt_js_disconnect_to_crt_disconnect(packet);
        };
        Mqtt5Client2.prototype.on_browser_close = function() {
          var _this = this;
          var _a2, _b, _c2, _d2;
          var lastDisconnect = this.lastDisconnect;
          var lastError = this.lastError;
          if (this.lifecycleEventState == Mqtt5ClientLifecycleEventState.Connected) {
            this.lifecycleEventState = Mqtt5ClientLifecycleEventState.Disconnected;
            (_a2 = this.reconnectionScheduler) === null || _a2 === void 0 ? void 0 : _a2.onConnectionFailureOrDisconnection();
            var disconnectionEvent_1 = {
              error: new error_1.CrtError((_b = lastError === null || lastError === void 0 ? void 0 : lastError.toString()) !== null && _b !== void 0 ? _b : "disconnected")
            };
            if (lastDisconnect !== void 0) {
              disconnectionEvent_1.disconnect = lastDisconnect;
            }
            setTimeout(function() {
              _this.emit(Mqtt5Client2.DISCONNECTION, disconnectionEvent_1);
            }, 0);
          } else if (this.lifecycleEventState == Mqtt5ClientLifecycleEventState.Connecting) {
            this.lifecycleEventState = Mqtt5ClientLifecycleEventState.Disconnected;
            (_c2 = this.reconnectionScheduler) === null || _c2 === void 0 ? void 0 : _c2.onConnectionFailureOrDisconnection();
            var connectionFailureEvent_1 = {
              error: new error_1.CrtError((_d2 = lastError === null || lastError === void 0 ? void 0 : lastError.toString()) !== null && _d2 !== void 0 ? _d2 : "connectionFailure")
            };
            setTimeout(function() {
              _this.emit(Mqtt5Client2.CONNECTION_FAILURE, connectionFailureEvent_1);
            }, 0);
          }
          this.lastDisconnect = void 0;
          this.lastError = void 0;
        };
        Mqtt5Client2.prototype.on_browser_client_error = function(error) {
          var _this = this;
          this.lastError = error;
          setTimeout(function() {
            _this.emit(Mqtt5Client2.INFO, new error_1.CrtError(error));
          }, 0);
        };
        Mqtt5Client2.prototype.on_attempting_connect = function() {
          var _this = this;
          this.lifecycleEventState = Mqtt5ClientLifecycleEventState.Connecting;
          var attemptingConnectEvent = {};
          setTimeout(function() {
            _this.emit(Mqtt5Client2.ATTEMPTING_CONNECT, attemptingConnectEvent);
          }, 0);
        };
        Mqtt5Client2.prototype.on_connection_success = function(connack) {
          var _this = this;
          var _a2;
          this.lifecycleEventState = Mqtt5ClientLifecycleEventState.Connected;
          this.reset_topic_aliases();
          (_a2 = this.reconnectionScheduler) === null || _a2 === void 0 ? void 0 : _a2.onSuccessfulConnection();
          var crt_connack = mqtt_utils.transform_mqtt_js_connack_to_crt_connack(connack);
          var settings = mqtt_utils.create_negotiated_settings(this.config, crt_connack);
          var connectionSuccessEvent = {
            connack: crt_connack,
            settings
          };
          setTimeout(function() {
            _this.emit(Mqtt5Client2.CONNECTION_SUCCESS, connectionSuccessEvent);
          }, 0);
        };
        Mqtt5Client2.prototype._on_stopped_internal = function() {
          var _a2;
          (_a2 = this.reconnectionScheduler) === null || _a2 === void 0 ? void 0 : _a2.clearTasks();
          this.reconnectionScheduler = void 0;
          this.browserClient = void 0;
          this.lifecycleEventState = Mqtt5ClientLifecycleEventState.None;
          this.lastDisconnect = void 0;
          this.lastError = void 0;
          if (this.state == Mqtt5ClientState.Restarting) {
            this.state = Mqtt5ClientState.Stopped;
            this.start();
          } else if (this.state != Mqtt5ClientState.Stopped) {
            this.state = Mqtt5ClientState.Stopped;
            this.emit(Mqtt5Client2.STOPPED);
          }
        };
        Mqtt5Client2.ERROR = "error";
        Mqtt5Client2.INFO = "info";
        Mqtt5Client2.MESSAGE_RECEIVED = "messageReceived";
        Mqtt5Client2.ATTEMPTING_CONNECT = "attemptingConnect";
        Mqtt5Client2.CONNECTION_SUCCESS = "connectionSuccess";
        Mqtt5Client2.CONNECTION_FAILURE = "connectionFailure";
        Mqtt5Client2.DISCONNECTION = "disconnection";
        Mqtt5Client2.STOPPED = "stopped";
        return Mqtt5Client2;
      }(event_1.BufferedEventEmitter)
    );
    exports.Mqtt5Client = Mqtt5Client;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser3 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re2) {
      return objectToString(re2) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require_util();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join4(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream = require_stream_browser3();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy3();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new Error("write after end");
      stream.emit("error", er2);
      pna.nextTick(cb, er2);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er2 = false;
      if (chunk === null) {
        er2 = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er2) {
        stream.emit("error", er2);
        pna.nextTick(cb, er2);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er2);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er2);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er2)
        onwriteError(stream, state, sync, er2, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable3();
    var Writable = require_stream_writable3();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v2 = 0; v2 < keys.length; v2++) {
        method = keys[v2];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v2;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser3();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList2();
    var destroyImpl = require_destroy3();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state, chunk);
        if (er2) {
          stream.emit("error", er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new TypeError("Invalid non-string/buffer chunk");
      }
      return er2;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er2);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = Stream.prototype.on.call(this, ev, fn2);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c2 = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c2;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c2;
      }
      list.length -= c2;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c2 = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c2;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c2;
      }
      list.length -= c2;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs2, x2) {
      for (var i = 0, l2 = xs2.length; i < l2; i++) {
        if (xs2[i] === x2)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform3 = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var Duplex = require_stream_duplex3();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er2, data) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && ts2.writecb && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough3 = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform3();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser3 = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable3();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable3();
    exports.Duplex = require_stream_duplex3();
    exports.Transform = require_stream_transform3();
    exports.PassThrough = require_stream_passthrough3();
  }
});

// node_modules/duplexify/index.js
var require_duplexify2 = __commonJS({
  "node_modules/duplexify/index.js"(exports, module) {
    var stream = require_readable_browser3();
    var eos = require_end_of_stream3();
    var inherits = require_inherits_browser();
    var shift = require_stream_shift();
    var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);
    var onuncork = function(self2, fn2) {
      if (self2._corked)
        self2.once("uncork", fn2);
      else
        fn2();
    };
    var autoDestroy = function(self2, err) {
      if (self2._autoDestroy)
        self2.destroy(err);
    };
    var destroyer = function(self2, end2) {
      return function(err) {
        if (err)
          autoDestroy(self2, err.message === "premature close" ? null : err);
        else if (end2 && !self2._ended)
          self2.end();
      };
    };
    var end = function(ws2, fn2) {
      if (!ws2)
        return fn2();
      if (ws2._writableState && ws2._writableState.finished)
        return fn2();
      if (ws2._writableState)
        return ws2.end(fn2);
      ws2.end();
      fn2();
    };
    var toStreams2 = function(rs2) {
      return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs2);
    };
    var Duplexify = function(writable, readable, opts) {
      if (!(this instanceof Duplexify))
        return new Duplexify(writable, readable, opts);
      stream.Duplex.call(this, opts);
      this._writable = null;
      this._readable = null;
      this._readable2 = null;
      this._autoDestroy = !opts || opts.autoDestroy !== false;
      this._forwardDestroy = !opts || opts.destroy !== false;
      this._forwardEnd = !opts || opts.end !== false;
      this._corked = 1;
      this._ondrain = null;
      this._drained = false;
      this._forwarding = false;
      this._unwrite = null;
      this._unread = null;
      this._ended = false;
      this.destroyed = false;
      if (writable)
        this.setWritable(writable);
      if (readable)
        this.setReadable(readable);
    };
    inherits(Duplexify, stream.Duplex);
    Duplexify.obj = function(writable, readable, opts) {
      if (!opts)
        opts = {};
      opts.objectMode = true;
      opts.highWaterMark = 16;
      return new Duplexify(writable, readable, opts);
    };
    Duplexify.prototype.cork = function() {
      if (++this._corked === 1)
        this.emit("cork");
    };
    Duplexify.prototype.uncork = function() {
      if (this._corked && --this._corked === 0)
        this.emit("uncork");
    };
    Duplexify.prototype.setWritable = function(writable) {
      if (this._unwrite)
        this._unwrite();
      if (this.destroyed) {
        if (writable && writable.destroy)
          writable.destroy();
        return;
      }
      if (writable === null || writable === false) {
        this.end();
        return;
      }
      var self2 = this;
      var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));
      var ondrain = function() {
        var ondrain2 = self2._ondrain;
        self2._ondrain = null;
        if (ondrain2)
          ondrain2();
      };
      var clear = function() {
        self2._writable.removeListener("drain", ondrain);
        unend();
      };
      if (this._unwrite)
        process.nextTick(ondrain);
      this._writable = writable;
      this._writable.on("drain", ondrain);
      this._unwrite = clear;
      this.uncork();
    };
    Duplexify.prototype.setReadable = function(readable) {
      if (this._unread)
        this._unread();
      if (this.destroyed) {
        if (readable && readable.destroy)
          readable.destroy();
        return;
      }
      if (readable === null || readable === false) {
        this.push(null);
        this.resume();
        return;
      }
      var self2 = this;
      var unend = eos(readable, { writable: false, readable: true }, destroyer(this));
      var onreadable = function() {
        self2._forward();
      };
      var onend = function() {
        self2.push(null);
      };
      var clear = function() {
        self2._readable2.removeListener("readable", onreadable);
        self2._readable2.removeListener("end", onend);
        unend();
      };
      this._drained = true;
      this._readable = readable;
      this._readable2 = readable._readableState ? readable : toStreams2(readable);
      this._readable2.on("readable", onreadable);
      this._readable2.on("end", onend);
      this._unread = clear;
      this._forward();
    };
    Duplexify.prototype._read = function() {
      this._drained = true;
      this._forward();
    };
    Duplexify.prototype._forward = function() {
      if (this._forwarding || !this._readable2 || !this._drained)
        return;
      this._forwarding = true;
      var data;
      while (this._drained && (data = shift(this._readable2)) !== null) {
        if (this.destroyed)
          continue;
        this._drained = this.push(data);
      }
      this._forwarding = false;
    };
    Duplexify.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      var self2 = this;
      process.nextTick(function() {
        self2._destroy(err);
      });
    };
    Duplexify.prototype._destroy = function(err) {
      if (err) {
        var ondrain = this._ondrain;
        this._ondrain = null;
        if (ondrain)
          ondrain(err);
        else
          this.emit("error", err);
      }
      if (this._forwardDestroy) {
        if (this._readable && this._readable.destroy)
          this._readable.destroy();
        if (this._writable && this._writable.destroy)
          this._writable.destroy();
      }
      this.emit("close");
    };
    Duplexify.prototype._write = function(data, enc, cb) {
      if (this.destroyed)
        return cb();
      if (this._corked)
        return onuncork(this, this._write.bind(this, data, enc, cb));
      if (data === SIGNAL_FLUSH)
        return this._finish(cb);
      if (!this._writable)
        return cb();
      if (this._writable.write(data) === false)
        this._ondrain = cb;
      else
        cb();
    };
    Duplexify.prototype._finish = function(cb) {
      var self2 = this;
      this.emit("preend");
      onuncork(this, function() {
        end(self2._forwardEnd && self2._writable, function() {
          if (self2._writableState.prefinished === false)
            self2._writableState.prefinished = true;
          self2.emit("prefinish");
          onuncork(self2, cb);
        });
      });
    };
    Duplexify.prototype.end = function(data, enc, cb) {
      if (typeof data === "function")
        return this.end(null, null, data);
      if (typeof enc === "function")
        return this.end(data, null, enc);
      this._ended = true;
      if (data)
        this.write(data);
      if (!this._writableState.ending)
        this.write(SIGNAL_FLUSH);
      return stream.Writable.prototype.end.call(this, cb);
    };
    module.exports = Duplexify;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser5 = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws2 = null;
    if (typeof WebSocket !== "undefined") {
      ws2 = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws2 = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws2 = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws2 = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws2 = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws2;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/@httptoolkit/websocket-stream/stream.js
var require_stream = __commonJS({
  "node_modules/@httptoolkit/websocket-stream/stream.js"(exports, module) {
    "use strict";
    var Transform = require_readable_browser3().Transform;
    var duplexify = require_duplexify2();
    var WS = require_browser5();
    var Buffer2 = require_safe_buffer3().Buffer;
    module.exports = WebSocketStream;
    function buildProxy(options, socketWrite, socketEnd) {
      var proxy = new Transform({
        objectMode: options.objectMode
      });
      proxy._write = socketWrite;
      proxy._flush = socketEnd;
      return proxy;
    }
    function WebSocketStream(target, protocols, options) {
      var stream, socket;
      var isBrowser = process.title === "browser";
      var isNative = !!global.WebSocket;
      var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;
      if (protocols && !Array.isArray(protocols) && "object" === typeof protocols) {
        options = protocols;
        protocols = void 0;
        if (typeof options.protocol === "string" || Array.isArray(options.protocol)) {
          protocols = options.protocol;
        }
      }
      if (!options)
        options = {};
      if (options.objectMode === void 0) {
        options.objectMode = !(options.binary === true || options.binary === void 0);
      }
      var proxy = buildProxy(options, socketWrite, socketEnd);
      if (!options.objectMode) {
        proxy._writev = writev;
      }
      var bufferSize = options.browserBufferSize || 1024 * 512;
      var bufferTimeout = options.browserBufferTimeout || 1e3;
      if (typeof target === "object") {
        socket = target;
      } else {
        if (isNative && isBrowser) {
          socket = new WS(target, protocols);
        } else {
          socket = new WS(target, protocols, options);
        }
        socket.binaryType = "arraybuffer";
      }
      var eventListenerSupport = "undefined" === typeof socket.addEventListener;
      if (socket.readyState === socket.OPEN) {
        stream = proxy;
      } else {
        stream = duplexify(void 0, void 0, options);
        if (!options.objectMode) {
          stream._writev = writev;
        }
        if (eventListenerSupport) {
          socket.addEventListener("open", onopen);
        } else {
          socket.onopen = onopen;
        }
      }
      stream.socket = socket;
      if (eventListenerSupport) {
        socket.addEventListener("close", onclose);
        socket.addEventListener("error", onerror);
        socket.addEventListener("message", onmessage);
      } else {
        socket.onclose = onclose;
        socket.onerror = onerror;
        socket.onmessage = onmessage;
      }
      proxy.on("close", destroy);
      var coerceToBuffer = !options.objectMode;
      function socketWriteNode(chunk, enc, next) {
        if (socket.readyState !== socket.OPEN) {
          next();
          return;
        }
        if (coerceToBuffer && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, "utf8");
        }
        socket.send(chunk, next);
      }
      function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
          setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
          return;
        }
        if (coerceToBuffer && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, "utf8");
        }
        try {
          socket.send(chunk);
        } catch (err) {
          return next(err);
        }
        next();
      }
      function socketEnd(done) {
        socket.close();
        done();
      }
      function onopen() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      }
      function onclose(closeDetails) {
        stream.emit("ws-close", closeDetails);
        stream.end();
        stream.destroy();
      }
      function onerror(err) {
        stream.destroy(err);
      }
      function onmessage(event) {
        var data = event.data;
        if (data instanceof ArrayBuffer)
          data = Buffer2.from(data);
        else
          data = Buffer2.from(data, "utf8");
        proxy.push(data);
      }
      function destroy() {
        socket.close();
      }
      function writev(chunks, cb) {
        var buffers = new Array(chunks.length);
        for (var i = 0; i < chunks.length; i++) {
          if (typeof chunks[i].chunk === "string") {
            buffers[i] = Buffer2.from(chunks[i], "utf8");
          } else {
            buffers[i] = chunks[i].chunk;
          }
        }
        this._write(Buffer2.concat(buffers), "binary", cb);
      }
      return stream;
    }
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base2 = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C2.x64 = {};
        var X64Word = C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T2[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d = H2[3];
            a = FF(a, b2, c2, d, M_offset_0, 7, T2[0]);
            d = FF(d, a, b2, c2, M_offset_1, 12, T2[1]);
            c2 = FF(c2, d, a, b2, M_offset_2, 17, T2[2]);
            b2 = FF(b2, c2, d, a, M_offset_3, 22, T2[3]);
            a = FF(a, b2, c2, d, M_offset_4, 7, T2[4]);
            d = FF(d, a, b2, c2, M_offset_5, 12, T2[5]);
            c2 = FF(c2, d, a, b2, M_offset_6, 17, T2[6]);
            b2 = FF(b2, c2, d, a, M_offset_7, 22, T2[7]);
            a = FF(a, b2, c2, d, M_offset_8, 7, T2[8]);
            d = FF(d, a, b2, c2, M_offset_9, 12, T2[9]);
            c2 = FF(c2, d, a, b2, M_offset_10, 17, T2[10]);
            b2 = FF(b2, c2, d, a, M_offset_11, 22, T2[11]);
            a = FF(a, b2, c2, d, M_offset_12, 7, T2[12]);
            d = FF(d, a, b2, c2, M_offset_13, 12, T2[13]);
            c2 = FF(c2, d, a, b2, M_offset_14, 17, T2[14]);
            b2 = FF(b2, c2, d, a, M_offset_15, 22, T2[15]);
            a = GG(a, b2, c2, d, M_offset_1, 5, T2[16]);
            d = GG(d, a, b2, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d, a, b2, M_offset_11, 14, T2[18]);
            b2 = GG(b2, c2, d, a, M_offset_0, 20, T2[19]);
            a = GG(a, b2, c2, d, M_offset_5, 5, T2[20]);
            d = GG(d, a, b2, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d, a, b2, M_offset_15, 14, T2[22]);
            b2 = GG(b2, c2, d, a, M_offset_4, 20, T2[23]);
            a = GG(a, b2, c2, d, M_offset_9, 5, T2[24]);
            d = GG(d, a, b2, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d, a, b2, M_offset_3, 14, T2[26]);
            b2 = GG(b2, c2, d, a, M_offset_8, 20, T2[27]);
            a = GG(a, b2, c2, d, M_offset_13, 5, T2[28]);
            d = GG(d, a, b2, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d, a, b2, M_offset_7, 14, T2[30]);
            b2 = GG(b2, c2, d, a, M_offset_12, 20, T2[31]);
            a = HH(a, b2, c2, d, M_offset_5, 4, T2[32]);
            d = HH(d, a, b2, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d, a, b2, M_offset_11, 16, T2[34]);
            b2 = HH(b2, c2, d, a, M_offset_14, 23, T2[35]);
            a = HH(a, b2, c2, d, M_offset_1, 4, T2[36]);
            d = HH(d, a, b2, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d, a, b2, M_offset_7, 16, T2[38]);
            b2 = HH(b2, c2, d, a, M_offset_10, 23, T2[39]);
            a = HH(a, b2, c2, d, M_offset_13, 4, T2[40]);
            d = HH(d, a, b2, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d, a, b2, M_offset_3, 16, T2[42]);
            b2 = HH(b2, c2, d, a, M_offset_6, 23, T2[43]);
            a = HH(a, b2, c2, d, M_offset_9, 4, T2[44]);
            d = HH(d, a, b2, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d, a, b2, M_offset_15, 16, T2[46]);
            b2 = HH(b2, c2, d, a, M_offset_2, 23, T2[47]);
            a = II(a, b2, c2, d, M_offset_0, 6, T2[48]);
            d = II(d, a, b2, c2, M_offset_7, 10, T2[49]);
            c2 = II(c2, d, a, b2, M_offset_14, 15, T2[50]);
            b2 = II(b2, c2, d, a, M_offset_5, 21, T2[51]);
            a = II(a, b2, c2, d, M_offset_12, 6, T2[52]);
            d = II(d, a, b2, c2, M_offset_3, 10, T2[53]);
            c2 = II(c2, d, a, b2, M_offset_10, 15, T2[54]);
            b2 = II(b2, c2, d, a, M_offset_1, 21, T2[55]);
            a = II(a, b2, c2, d, M_offset_8, 6, T2[56]);
            d = II(d, a, b2, c2, M_offset_15, 10, T2[57]);
            c2 = II(c2, d, a, b2, M_offset_6, 15, T2[58]);
            b2 = II(b2, c2, d, a, M_offset_13, 21, T2[59]);
            a = II(a, b2, c2, d, M_offset_4, 6, T2[60]);
            d = II(d, a, b2, c2, M_offset_11, 10, T2[61]);
            c2 = II(c2, d, a, b2, M_offset_2, 15, T2[62]);
            b2 = II(b2, c2, d, a, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H2 = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H2[i];
              H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b2, c2, d, x2, s, t) {
          var n = a + (b2 & c2 | ~b2 & d) + x2 + t;
          return (n << s | n >>> 32 - s) + b2;
        }
        function GG(a, b2, c2, d, x2, s, t) {
          var n = a + (b2 & d | c2 & ~d) + x2 + t;
          return (n << s | n >>> 32 - s) + b2;
        }
        function HH(a, b2, c2, d, x2, s, t) {
          var n = a + (b2 ^ c2 ^ d) + x2 + t;
          return (n << s | n >>> 32 - s) + b2;
        }
        function II(a, b2, c2, d, x2, s, t) {
          var n = a + (c2 ^ (b2 | ~d)) + x2 + t;
          return (n << s | n >>> 32 - s) + b2;
        }
        C2.MD5 = Hasher._createHelper(MD5);
        C2.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d = H2[3];
            var e = H2[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W2[i] = M2[offset + i] | 0;
              } else {
                var n = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
                W2[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W2[i];
              if (i < 20) {
                t += (b2 & c2 | ~b2 & d) + 1518500249;
              } else if (i < 40) {
                t += (b2 ^ c2 ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b2 & c2 | b2 & d | c2 & d) - 1894007588;
              } else {
                t += (b2 ^ c2 ^ d) - 899497514;
              }
              e = d;
              d = c2;
              c2 = b2 << 30 | b2 >>> 2;
              b2 = a;
              a = t;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C2.SHA1 = Hasher._createHelper(SHA1);
        C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var H2 = [];
        var K2 = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H2.slice(0));
          },
          _doProcessBlock: function(M2, offset) {
            var H3 = this._hash.words;
            var a = H3[0];
            var b2 = H3[1];
            var c2 = H3[2];
            var d = H3[3];
            var e = H3[4];
            var f2 = H3[5];
            var g = H3[6];
            var h = H3[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W2[i] = M2[offset + i] | 0;
              } else {
                var gamma0x = W2[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i] = gamma0 + W2[i - 7] + gamma1 + W2[i - 16];
              }
              var ch2 = e & f2 ^ ~e & g;
              var maj = a & b2 ^ a & c2 ^ b2 & c2;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch2 + K2[i] + W2[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c2;
              c2 = b2;
              b2 = a;
              a = t1 + t2 | 0;
            }
            H3[0] = H3[0] + a | 0;
            H3[1] = H3[1] + b2 | 0;
            H3[2] = H3[2] + c2 | 0;
            H3[3] = H3[3] + d | 0;
            H3[4] = H3[4] + e | 0;
            H3[5] = H3[5] + f2 | 0;
            H3[6] = H3[6] + g | 0;
            H3[7] = H3[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C2.SHA256 = Hasher._createHelper(SHA256);
        C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C2.SHA224 = SHA256._createHelper(SHA224);
        C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K2 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W2[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var H0 = H2[0];
            var H1 = H2[1];
            var H22 = H2[2];
            var H3 = H2[3];
            var H4 = H2[4];
            var H5 = H2[5];
            var H6 = H2[6];
            var H7 = H2[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah2 = H0h;
            var al2 = H0l;
            var bh2 = H1h;
            var bl2 = H1l;
            var ch2 = H2h;
            var cl2 = H2l;
            var dh2 = H3h;
            var dl2 = H3l;
            var eh2 = H4h;
            var el2 = H4l;
            var fh2 = H5h;
            var fl2 = H5l;
            var gh2 = H6h;
            var gl2 = H6l;
            var hh2 = H7h;
            var hl2 = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi2 = W2[i];
              if (i < 16) {
                Wih = Wi2.high = M2[offset + i * 2] | 0;
                Wil = Wi2.low = M2[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi2.high = Wih;
                Wi2.low = Wil;
              }
              var chh = eh2 & fh2 ^ ~eh2 & gh2;
              var chl = el2 & fl2 ^ ~el2 & gl2;
              var majh = ah2 & bh2 ^ ah2 & ch2 ^ bh2 & ch2;
              var majl = al2 & bl2 ^ al2 & cl2 ^ bl2 & cl2;
              var sigma0h = (ah2 >>> 28 | al2 << 4) ^ (ah2 << 30 | al2 >>> 2) ^ (ah2 << 25 | al2 >>> 7);
              var sigma0l = (al2 >>> 28 | ah2 << 4) ^ (al2 << 30 | ah2 >>> 2) ^ (al2 << 25 | ah2 >>> 7);
              var sigma1h = (eh2 >>> 14 | el2 << 18) ^ (eh2 >>> 18 | el2 << 14) ^ (eh2 << 23 | el2 >>> 9);
              var sigma1l = (el2 >>> 14 | eh2 << 18) ^ (el2 >>> 18 | eh2 << 14) ^ (el2 << 23 | eh2 >>> 9);
              var Ki2 = K2[i];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl2 + sigma1l;
              var t1h = hh2 + sigma1h + (t1l >>> 0 < hl2 >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh2 = gh2;
              hl2 = gl2;
              gh2 = fh2;
              gl2 = fl2;
              fh2 = eh2;
              fl2 = el2;
              el2 = dl2 + t1l | 0;
              eh2 = dh2 + t1h + (el2 >>> 0 < dl2 >>> 0 ? 1 : 0) | 0;
              dh2 = ch2;
              dl2 = cl2;
              ch2 = bh2;
              cl2 = bl2;
              bh2 = ah2;
              bl2 = al2;
              al2 = t1l + t2l | 0;
              ah2 = t1h + t2h + (al2 >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al2;
            H0.high = H0h + ah2 + (H0l >>> 0 < al2 >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl2;
            H1.high = H1h + bh2 + (H1l >>> 0 < bl2 >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl2;
            H22.high = H2h + ch2 + (H2l >>> 0 < cl2 >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl2;
            H3.high = H3h + dh2 + (H3l >>> 0 < dl2 >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el2;
            H4.high = H4h + eh2 + (H4l >>> 0 < el2 >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl2;
            H5.high = H5h + fh2 + (H5l >>> 0 < fl2 >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl2;
            H6.high = H6h + gh2 + (H6l >>> 0 < gl2 >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl2;
            H7.high = H7h + hh2 + (H7l >>> 0 < hl2 >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C2.SHA512 = Hasher._createHelper(SHA512);
        C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C2.SHA384 = SHA512._createHelper(SHA384);
        C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var C_algo = C2.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x2 = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x2 + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x2 + 3 * y) % 5;
            x2 = newX;
            y = newY;
          }
          for (var x2 = 0; x2 < 5; x2++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x2 + 5 * y] = y + (2 * x2 + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j2 = 0; j2 < 7; j2++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j2) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T2 = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T2[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M2, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M2[offset + 2 * i];
              var M2i1 = M2[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x2 = 0; x2 < 5; x2++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x2 + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T2[x2];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                var Tx4 = T2[(x2 + 4) % 5];
                var Tx1 = T2[(x2 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x2 + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T2[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T2[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x2 + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T2[laneIndex];
                  var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y];
                  var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C2.SHA3 = Hasher._createHelper(SHA3);
        C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var hl2 = _hl.words;
            var hr2 = _hr.words;
            var zl2 = _zl.words;
            var zr2 = _zr.words;
            var sl2 = _sl.words;
            var sr2 = _sr.words;
            var al2, bl2, cl2, dl2, el2;
            var ar2, br2, cr2, dr2, er2;
            ar2 = al2 = H2[0];
            br2 = bl2 = H2[1];
            cr2 = cl2 = H2[2];
            dr2 = dl2 = H2[3];
            er2 = el2 = H2[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al2 + M2[offset + zl2[i]] | 0;
              if (i < 16) {
                t += f1(bl2, cl2, dl2) + hl2[0];
              } else if (i < 32) {
                t += f2(bl2, cl2, dl2) + hl2[1];
              } else if (i < 48) {
                t += f3(bl2, cl2, dl2) + hl2[2];
              } else if (i < 64) {
                t += f4(bl2, cl2, dl2) + hl2[3];
              } else {
                t += f5(bl2, cl2, dl2) + hl2[4];
              }
              t = t | 0;
              t = rotl(t, sl2[i]);
              t = t + el2 | 0;
              al2 = el2;
              el2 = dl2;
              dl2 = rotl(cl2, 10);
              cl2 = bl2;
              bl2 = t;
              t = ar2 + M2[offset + zr2[i]] | 0;
              if (i < 16) {
                t += f5(br2, cr2, dr2) + hr2[0];
              } else if (i < 32) {
                t += f4(br2, cr2, dr2) + hr2[1];
              } else if (i < 48) {
                t += f3(br2, cr2, dr2) + hr2[2];
              } else if (i < 64) {
                t += f2(br2, cr2, dr2) + hr2[3];
              } else {
                t += f1(br2, cr2, dr2) + hr2[4];
              }
              t = t | 0;
              t = rotl(t, sr2[i]);
              t = t + er2 | 0;
              ar2 = er2;
              er2 = dr2;
              dr2 = rotl(cr2, 10);
              cr2 = br2;
              br2 = t;
            }
            t = H2[1] + cl2 + dr2 | 0;
            H2[1] = H2[2] + dl2 + er2 | 0;
            H2[2] = H2[3] + el2 + ar2 | 0;
            H2[3] = H2[4] + al2 + br2 | 0;
            H2[4] = H2[0] + bl2 + cr2 | 0;
            H2[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H2 = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H2[i];
              H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x2, y, z2) {
          return x2 ^ y ^ z2;
        }
        function f2(x2, y, z2) {
          return x2 & y | ~x2 & z2;
        }
        function f3(x2, y, z2) {
          return (x2 | ~y) ^ z2;
        }
        function f4(x2, y, z2) {
          return x2 & z2 | y & ~z2;
        }
        function f5(x2, y, z2) {
          return x2 ^ (y | ~z2);
        }
        function rotl(x2, n) {
          return x2 << n | x2 >>> 32 - n;
        }
        C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base2 = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        var HMAC = C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j2 = 0; j2 < blockWordsLength; j2++) {
                  blockWords[j2] ^= intermediateWords[j2];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C2.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C2.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C2.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C2.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C2.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C2.enc;
        var Hex = C_enc.Hex;
        var C_format = C2.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi2 = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d[x2];
            var x4 = d[x22];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t << 24 | t >>> 8;
            SUB_MIX_1[x2] = t << 16 | t >>> 16;
            SUB_MIX_2[x2] = t << 8 | t >>> 24;
            SUB_MIX_3[x2] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x2) {
              x2 = xi2 = 1;
            } else {
              x2 = x22 ^ d[d[d[x8 ^ x22]]];
              xi2 ^= d[d[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset) {
            var t = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t;
            this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t;
          },
          _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset] ^ keySchedule[0];
            var s1 = M2[offset + 1] ^ keySchedule[1];
            var s2 = M2[offset + 2] ^ keySchedule[2];
            var s3 = M2[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset] = t0;
            M2[offset + 1] = t1;
            M2[offset + 2] = t2;
            M2[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C2.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._subKeys);
          },
          decryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M2, offset, subKeys) {
            this._lBlock = M2[offset];
            this._rBlock = M2[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i = 0; i < 8; i++) {
                f2 |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M2[offset] = this._lBlock;
            M2[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C2.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M2, offset) {
            this._des1.encryptBlock(M2, offset);
            this._des2.decryptBlock(M2, offset);
            this._des3.encryptBlock(M2, offset);
          },
          decryptBlock: function(M2, offset) {
            this._des3.decryptBlock(M2, offset);
            this._des2.encryptBlock(M2, offset);
            this._des1.decryptBlock(M2, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C2.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i = 0; i < 256; i++) {
              S2[i] = i;
            }
            for (var i = 0, j2 = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j2 = (j2 + S2[i] + keyByte) % 256;
              var t = S2[i];
              S2[i] = S2[j2];
              S2[j2] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M2, offset) {
            M2[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i = this._i;
          var j2 = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j2 = (j2 + S2[i]) % 256;
            var t = S2[i];
            S2[i] = S2[j2];
            S2[j2] = t;
            keystreamWord |= S2[(S2[i] + S2[j2]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j2;
          return keystreamWord;
        }
        C2.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K2[i] = (K2[i] << 8 | K2[i] >>> 24) & 16711935 | (K2[i] << 24 | K2[i] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C3[i] ^= X2[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i2;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i2;
              C3[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i = 0; i < 4; i++) {
              S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
              M2[offset + i] ^= S2[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C3[i];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X2[i] + C3[i];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh2 = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C3[i] ^= X2[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i2;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i2;
              C3[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i = 0; i < 4; i++) {
              S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
              M2[offset + i] ^= S2[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C3[i];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X2[i] + C3[i];
            var ga2 = gx & 65535;
            var gb = gx >>> 16;
            var gh2 = ((ga2 * ga2 >>> 17) + ga2 * gb >>> 15) + gb * gb;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        const N2 = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F2(ctx, x2) {
          let a = x2 >> 24 & 255;
          let b2 = x2 >> 16 & 255;
          let c2 = x2 >> 8 & 255;
          let d = x2 & 255;
          let y = ctx.sbox[0][a] + ctx.sbox[1][b2];
          y = y ^ ctx.sbox[2][c2];
          y = y + ctx.sbox[3][d];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl2 = left;
          let Xr2 = right;
          let temp;
          for (let i = 0; i < N2; ++i) {
            Xl2 = Xl2 ^ ctx.pbox[i];
            Xr2 = F2(ctx, Xl2) ^ Xr2;
            temp = Xl2;
            Xl2 = Xr2;
            Xr2 = temp;
          }
          temp = Xl2;
          Xl2 = Xr2;
          Xr2 = temp;
          Xr2 = Xr2 ^ ctx.pbox[N2];
          Xl2 = Xl2 ^ ctx.pbox[N2 + 1];
          return { left: Xl2, right: Xr2 };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl2 = left;
          let Xr2 = right;
          let temp;
          for (let i = N2 + 1; i > 1; --i) {
            Xl2 = Xl2 ^ ctx.pbox[i];
            Xr2 = F2(ctx, Xl2) ^ Xr2;
            temp = Xl2;
            Xl2 = Xr2;
            Xr2 = temp;
          }
          temp = Xl2;
          Xl2 = Xr2;
          Xr2 = temp;
          Xr2 = Xr2 ^ ctx.pbox[1];
          Xl2 = Xl2 ^ ctx.pbox[0];
          return { left: Xl2, right: Xr2 };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N2 + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i = 0; i < N2 + 2; i += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i] = Data1;
            ctx.pbox[i + 1] = Data2;
          }
          for (let i = 0; i < 4; i++) {
            for (let j2 = 0; j2 < 256; j2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i][j2] = Data1;
              ctx.sbox[i][j2 + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M2, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res.left;
            M2[offset + 1] = res.right;
          },
          decryptBlock: function(M2, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res.left;
            M2[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C2.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS.Blowfish;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/aws-crt/dist.browser/common/aws_iot_shared.js
var require_aws_iot_shared = __commonJS({
  "node_modules/aws-crt/dist.browser/common/aws_iot_shared.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractRegionFromEndpoint = exports.buildMqtt5FinalUsername = exports.canonicalizeCustomAuthConfig = exports.canonicalizeCustomAuthTokenSignature = exports.populate_username_string_with_custom_authorizer = exports.is_string_and_not_empty = exports.add_to_username_parameter = void 0;
    var platform2 = __importStar2(require_platform());
    var utils = __importStar2(require_utils());
    function add_to_username_parameter(current_username, parameter_value, parameter_pre_text) {
      var return_string = current_username;
      if (return_string.indexOf("?") != -1) {
        return_string += "&";
      } else {
        return_string += "?";
      }
      if (parameter_value.indexOf(parameter_pre_text) != -1) {
        return return_string + parameter_value;
      } else {
        return return_string + parameter_pre_text + parameter_value;
      }
    }
    exports.add_to_username_parameter = add_to_username_parameter;
    function is_string_and_not_empty(item) {
      return item != void 0 && typeof item == "string" && item != "";
    }
    exports.is_string_and_not_empty = is_string_and_not_empty;
    function populate_username_string_with_custom_authorizer(current_username, input_username, input_authorizer, input_signature, input_builder_username, input_token_key_name, input_token_value) {
      var username_string = "";
      if (current_username) {
        username_string += current_username;
      }
      if (is_string_and_not_empty(input_username) == false) {
        if (is_string_and_not_empty(input_builder_username) && input_builder_username) {
          username_string += input_builder_username;
        }
      } else {
        username_string += input_username;
      }
      if (is_string_and_not_empty(input_authorizer) && input_authorizer) {
        username_string = add_to_username_parameter(username_string, input_authorizer, "x-amz-customauthorizer-name=");
      }
      if (is_string_and_not_empty(input_signature) || is_string_and_not_empty(input_token_value) || is_string_and_not_empty(input_token_key_name)) {
        if (!input_token_value || !input_token_key_name || !input_signature) {
          throw new Error("Signing-based custom authentication requires all token-related properties to be set");
        }
      }
      if (is_string_and_not_empty(input_signature) && input_signature) {
        username_string = add_to_username_parameter(username_string, input_signature, "x-amz-customauthorizer-signature=");
      }
      if (is_string_and_not_empty(input_token_value) && is_string_and_not_empty(input_token_key_name)) {
        username_string = add_to_username_parameter(username_string, input_token_value, input_token_key_name + "=");
      }
      return username_string;
    }
    exports.populate_username_string_with_custom_authorizer = populate_username_string_with_custom_authorizer;
    function canonicalizeCustomAuthTokenSignature(signature) {
      if (signature === void 0 || signature == null) {
        return void 0;
      }
      var hasPercent = signature.indexOf("%") != -1;
      if (hasPercent) {
        return signature;
      } else {
        return encodeURIComponent(signature);
      }
    }
    exports.canonicalizeCustomAuthTokenSignature = canonicalizeCustomAuthTokenSignature;
    function canonicalizeCustomAuthConfig(config) {
      var processedConfig = {};
      utils.set_defined_property(processedConfig, "authorizerName", config.authorizerName);
      utils.set_defined_property(processedConfig, "username", config.username);
      utils.set_defined_property(processedConfig, "password", config.password);
      utils.set_defined_property(processedConfig, "tokenKeyName", config.tokenKeyName);
      utils.set_defined_property(processedConfig, "tokenValue", config.tokenValue);
      utils.set_defined_property(processedConfig, "tokenSignature", canonicalizeCustomAuthTokenSignature(config.tokenSignature));
      return processedConfig;
    }
    exports.canonicalizeCustomAuthConfig = canonicalizeCustomAuthConfig;
    function addParam(paramName, paramValue, paramSet) {
      if (paramValue) {
        paramSet.push([paramName, paramValue]);
      }
    }
    function buildMqtt5FinalUsername(customAuthConfig) {
      var path = "";
      var paramList = [];
      if (customAuthConfig) {
        var usingSigning = false;
        if (customAuthConfig.tokenValue || customAuthConfig.tokenKeyName || customAuthConfig.tokenSignature) {
          usingSigning = true;
          if (!customAuthConfig.tokenValue || !customAuthConfig.tokenKeyName || !customAuthConfig.tokenSignature) {
            throw new Error("Token-based custom authentication requires all token-related properties to be set");
          }
        }
        var username = customAuthConfig.username;
        var pathSplit = (username !== null && username !== void 0 ? username : "").split("?");
        var params = pathSplit.slice(1);
        path = pathSplit[0];
        if (params.length > 1) {
          throw new Error("Custom auth username property value is invalid");
        } else if (params.length == 1) {
          params[0].split("&").forEach(function(keyValue, index, array) {
            var _a2;
            var kvPair = keyValue.split("=");
            paramList.push([kvPair[0], (_a2 = kvPair[1]) !== null && _a2 !== void 0 ? _a2 : ""]);
          });
        }
        addParam("x-amz-customauthorizer-name", customAuthConfig.authorizerName, paramList);
        if (usingSigning) {
          addParam(customAuthConfig.tokenKeyName, customAuthConfig.tokenValue, paramList);
          addParam("x-amz-customauthorizer-signature", customAuthConfig.tokenSignature, paramList);
        }
      }
      paramList.push(["SDK", "NodeJSv2"]);
      paramList.push(["Version", platform2.crt_version()]);
      return (path !== null && path !== void 0 ? path : "") + "?" + paramList.map(function(value) {
        return "".concat(value[0], "=").concat(value[1]);
      }).join("&");
    }
    exports.buildMqtt5FinalUsername = buildMqtt5FinalUsername;
    function extractRegionFromEndpoint(endpoint) {
      var regexpRegion = /^[\w\-]+\.[\w\-]+\.([\w+\-]+)\./;
      var match = endpoint.match(regexpRegion);
      if (match) {
        return match[1];
      }
      throw new Error("AWS region could not be extracted from endpoint.  Use 'region' property on WebsocketConfig to set manually.");
    }
    exports.extractRegionFromEndpoint = extractRegionFromEndpoint;
  }
});

// node_modules/aws-crt/dist.browser/browser/ws.js
var require_ws2 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/ws.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create_mqtt5_websocket_stream = exports.create_mqtt5_websocket_url = exports.create_websocket_stream = exports.create_websocket_url = void 0;
    var mqtt5 = __importStar2(require_mqtt52());
    var error_1 = require_error();
    var websocket = require_stream();
    var Crypto = __importStar2(require_crypto_js());
    var iot_shared = __importStar2(require_aws_iot_shared());
    function zero_pad(n) {
      return n > 9 ? n : "0" + n.toString();
    }
    function canonical_time(time) {
      var now = time !== null && time !== void 0 ? time : /* @__PURE__ */ new Date();
      return "".concat(now.getUTCFullYear()).concat(zero_pad(now.getUTCMonth() + 1)).concat(zero_pad(now.getUTCDate()), "T") + "".concat(zero_pad(now.getUTCHours())).concat(zero_pad(now.getUTCMinutes())).concat(zero_pad(now.getUTCSeconds()), "Z");
    }
    function canonical_day(time) {
      if (time === void 0) {
        time = canonical_time();
      }
      return time.substring(0, time.indexOf("T"));
    }
    function make_signing_key(credentials, day, service_name) {
      if (credentials == null || credentials == void 0) {
        throw new error_1.CrtError("make_signing_key: credentials not defined");
      }
      var hash_opts = { asBytes: true };
      var hash = Crypto.HmacSHA256(day, "AWS4" + credentials.aws_secret_key, hash_opts);
      hash = Crypto.HmacSHA256(credentials.aws_region || "", hash, hash_opts);
      hash = Crypto.HmacSHA256(service_name, hash, hash_opts);
      hash = Crypto.HmacSHA256("aws4_request", hash, hash_opts);
      return hash;
    }
    function sign_url(method, url, signing_config, time, day, payload) {
      var _a2;
      if (time === void 0) {
        time = canonical_time();
      }
      if (day === void 0) {
        day = canonical_day(time);
      }
      if (payload === void 0) {
        payload = "";
      }
      if (signing_config == null || signing_config == void 0) {
        throw new error_1.CrtError("sign_url: signing_config not defined");
      }
      var region = (_a2 = signing_config.credentials.aws_region) !== null && _a2 !== void 0 ? _a2 : signing_config.region;
      var signed_headers = "host";
      var service = signing_config.service;
      var canonical_headers = "host:".concat(url.hostname.toLowerCase(), "\n");
      var payload_hash = Crypto.SHA256(payload, { asBytes: true });
      var canonical_params = url.search.replace(new RegExp("^\\?"), "");
      var canonical_request = "".concat(method, "\n").concat(url.pathname, "\n").concat(canonical_params, "\n").concat(canonical_headers, "\n").concat(signed_headers, "\n").concat(payload_hash);
      var canonical_request_hash = Crypto.SHA256(canonical_request, { asBytes: true });
      var signature_raw = "AWS4-HMAC-SHA256\n".concat(time, "\n").concat(day, "/").concat(region, "/").concat(service, "/aws4_request\n").concat(canonical_request_hash);
      var signing_key = make_signing_key(signing_config.credentials, day, service);
      var signature = Crypto.HmacSHA256(signature_raw, signing_key, { asBytes: true });
      var query_params = "".concat(url.search, "&X-Amz-Signature=").concat(signature);
      if (signing_config.credentials.aws_sts_token) {
        query_params += "&X-Amz-Security-Token=".concat(encodeURIComponent(signing_config.credentials.aws_sts_token));
      }
      var signed_url = "".concat(url.protocol, "//").concat(url.hostname).concat(url.pathname).concat(query_params);
      return signed_url;
    }
    function create_websocket_url(config) {
      var _a2, _b, _c2, _d2;
      if (config == null || config == void 0) {
        throw new error_1.CrtError("create_websocket_url: config not defined");
      }
      var path = "/mqtt";
      var protocol = (config.websocket || {}).protocol || "wss";
      if (protocol === "wss") {
        var websocketoptions = config.websocket;
        var credentials = (_a2 = config.credentials_provider) === null || _a2 === void 0 ? void 0 : _a2.getCredentials();
        var signing_config_value = (_c2 = (_b = websocketoptions.create_signing_config) === null || _b === void 0 ? void 0 : _b.call(websocketoptions)) !== null && _c2 !== void 0 ? _c2 : {
          service: (_d2 = websocketoptions.service) !== null && _d2 !== void 0 ? _d2 : "iotdevicegateway",
          credentials,
          date: /* @__PURE__ */ new Date()
        };
        var signing_config = signing_config_value;
        var time = canonical_time(signing_config.date);
        var day = canonical_day(time);
        var query_params = "X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=".concat(signing_config.credentials.aws_access_id) + "%2F".concat(day, "%2F").concat(signing_config.credentials.aws_region, "%2F").concat(signing_config.service, "%2Faws4_request&X-Amz-Date=").concat(time, "&X-Amz-SignedHeaders=host");
        var url = new URL("wss://".concat(config.host_name, ":").concat(config.port).concat(path, "?").concat(query_params));
        return sign_url("GET", url, signing_config, time, day);
      } else if (protocol === "wss-custom-auth") {
        return "wss://".concat(config.host_name, ":").concat(config.port).concat(path);
      }
      throw new URIError("Invalid protocol requested: ".concat(protocol));
    }
    exports.create_websocket_url = create_websocket_url;
    function create_websocket_stream(config) {
      var url = create_websocket_url(config);
      return websocket(url, ["mqttv3.1"], config.websocket);
    }
    exports.create_websocket_stream = create_websocket_stream;
    function create_mqtt5_websocket_url(config) {
      var _a2, _b;
      if (config == null || config == void 0) {
        throw new error_1.CrtError("create_mqtt5_websocket_url: config not defined");
      }
      var path = "/mqtt";
      var websocketConfig = (_a2 = config.websocketOptions) !== null && _a2 !== void 0 ? _a2 : { urlFactoryOptions: { urlFactory: mqtt5.Mqtt5WebsocketUrlFactoryType.Ws } };
      var urlFactory = websocketConfig.urlFactoryOptions.urlFactory;
      switch (urlFactory) {
        case mqtt5.Mqtt5WebsocketUrlFactoryType.Ws:
          return "ws://".concat(config.hostName, ":").concat(config.port).concat(path);
          break;
        case mqtt5.Mqtt5WebsocketUrlFactoryType.Wss:
          return "wss://".concat(config.hostName, ":").concat(config.port).concat(path);
          break;
        case mqtt5.Mqtt5WebsocketUrlFactoryType.Sigv4:
          var sigv4Options = websocketConfig.urlFactoryOptions;
          var credentials = sigv4Options.credentialsProvider.getCredentials();
          if (credentials === void 0) {
            throw new error_1.CrtError("Websockets with sigv4 requires valid AWS credentials");
          }
          var region = (_b = sigv4Options.region) !== null && _b !== void 0 ? _b : iot_shared.extractRegionFromEndpoint(config.hostName);
          var signingConfig = {
            service: "iotdevicegateway",
            region,
            credentials,
            date: /* @__PURE__ */ new Date()
          };
          var time = canonical_time(signingConfig.date);
          var day = canonical_day(time);
          var query_params = "X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=".concat(signingConfig.credentials.aws_access_id) + "%2F".concat(day, "%2F").concat(region, "%2F").concat(signingConfig.service, "%2Faws4_request&X-Amz-Date=").concat(time, "&X-Amz-SignedHeaders=host");
          var url = new URL("wss://".concat(config.hostName, ":").concat(config.port).concat(path, "?").concat(query_params));
          return sign_url("GET", url, signingConfig, time, day);
        case mqtt5.Mqtt5WebsocketUrlFactoryType.Custom:
          var customOptions = websocketConfig.urlFactoryOptions;
          return customOptions.customUrlFactory();
      }
      throw new URIError("Invalid url factory requested: ".concat(urlFactory));
    }
    exports.create_mqtt5_websocket_url = create_mqtt5_websocket_url;
    function create_mqtt5_websocket_stream(config) {
      var _a2;
      var url = create_mqtt5_websocket_url(config);
      var ws2 = websocket(url, ["mqtt"], (_a2 = config.websocketOptions) === null || _a2 === void 0 ? void 0 : _a2.wsOptions);
      return ws2;
    }
    exports.create_mqtt5_websocket_stream = create_mqtt5_websocket_stream;
  }
});

// node_modules/aws-crt/dist.browser/browser/auth.js
var require_auth = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/auth.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator9 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op2) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
              return t;
            if (y = 0, t)
              op2 = [op2[0] & 2, t.value];
            switch (op2[0]) {
              case 0:
              case 1:
                t = op2;
                break;
              case 4:
                _2.label++;
                return { value: op2[1], done: false };
              case 5:
                _2.label++;
                y = op2[1];
                op2 = [0];
                continue;
              case 7:
                op2 = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                  _2.label = op2[1];
                  break;
                }
                if (op2[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op2;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op2);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op2 = body.call(thisArg, _2);
          } catch (e) {
            op2 = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op2[0] & 5)
          throw op2[1];
        return { value: op2[0] ? op2[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StaticCredentialProvider = exports.CredentialsProvider = void 0;
    var CredentialsProvider = (
      /** @class */
      function() {
        function CredentialsProvider2() {
        }
        CredentialsProvider2.prototype.getCredentials = function() {
          return void 0;
        };
        CredentialsProvider2.prototype.refreshCredentials = function() {
          return __awaiter2(this, void 0, void 0, function() {
            return __generator9(this, function(_a2) {
              return [2, new Promise(function(resolve, reject) {
                resolve();
              })];
            });
          });
        };
        return CredentialsProvider2;
      }()
    );
    exports.CredentialsProvider = CredentialsProvider;
    var StaticCredentialProvider = (
      /** @class */
      function(_super) {
        __extends19(StaticCredentialProvider2, _super);
        function StaticCredentialProvider2(credentials) {
          var _this = _super.call(this) || this;
          _this.getCredentials = function() {
            return _this.credentials;
          };
          _this.credentials = credentials;
          return _this;
        }
        return StaticCredentialProvider2;
      }(CredentialsProvider)
    );
    exports.StaticCredentialProvider = StaticCredentialProvider;
  }
});

// node_modules/aws-crt/dist.browser/browser/trie.js
var require_trie = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/trie.js"(exports) {
    "use strict";
    var __values6 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trie = exports.TrieOp = exports.Node = void 0;
    var Node = (
      /** @class */
      function() {
        function Node2(key, value, children) {
          if (children === void 0) {
            children = /* @__PURE__ */ new Map();
          }
          this.key = key;
          this.value = value;
          this.children = children;
        }
        return Node2;
      }()
    );
    exports.Node = Node;
    var TrieOp;
    (function(TrieOp2) {
      TrieOp2[TrieOp2["Insert"] = 0] = "Insert";
      TrieOp2[TrieOp2["Delete"] = 1] = "Delete";
      TrieOp2[TrieOp2["Find"] = 2] = "Find";
    })(TrieOp = exports.TrieOp || (exports.TrieOp = {}));
    var Trie = (
      /** @class */
      function() {
        function Trie2(split) {
          this.root = new Node();
          if (typeof split === "string") {
            var delimeter_1 = split;
            split = function(key) {
              return key.split(delimeter_1);
            };
          }
          this.split_key = split;
        }
        Trie2.prototype.find_node = function(key, op2) {
          var e_1, _a2;
          var parts = this.split_key(key);
          var current = this.root;
          var parent = void 0;
          try {
            for (var parts_1 = __values6(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
              var part = parts_1_1.value;
              var child = current.children.get(part);
              if (!child) {
                if (op2 == TrieOp.Insert) {
                  current.children.set(part, child = new Node(part));
                } else {
                  return void 0;
                }
              }
              parent = current;
              current = child;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (parts_1_1 && !parts_1_1.done && (_a2 = parts_1.return))
                _a2.call(parts_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (parent && op2 == TrieOp.Delete) {
            parent.children.delete(current.key);
          }
          return current;
        };
        Trie2.prototype.insert = function(key, value) {
          var node = this.find_node(key, TrieOp.Insert);
          node.value = value;
        };
        Trie2.prototype.remove = function(key) {
          this.find_node(key, TrieOp.Delete);
        };
        Trie2.prototype.find = function(key) {
          var node = this.find_node(key, TrieOp.Find);
          return node ? node.value : void 0;
        };
        return Trie2;
      }()
    );
    exports.Trie = Trie;
  }
});

// node_modules/aws-crt/dist.browser/common/mqtt.js
var require_mqtt2 = __commonJS({
  "node_modules/aws-crt/dist.browser/common/mqtt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_RECONNECT_MIN_SEC = exports.DEFAULT_RECONNECT_MAX_SEC = exports.MqttWill = exports.QoS = void 0;
    var QoS;
    (function(QoS2) {
      QoS2[QoS2["AtMostOnce"] = 0] = "AtMostOnce";
      QoS2[QoS2["AtLeastOnce"] = 1] = "AtLeastOnce";
      QoS2[QoS2["ExactlyOnce"] = 2] = "ExactlyOnce";
    })(QoS = exports.QoS || (exports.QoS = {}));
    var MqttWill = (
      /** @class */
      function() {
        function MqttWill2(topic, qos, payload, retain) {
          if (retain === void 0) {
            retain = false;
          }
          this.topic = topic;
          this.qos = qos;
          this.payload = payload;
          this.retain = retain;
        }
        return MqttWill2;
      }()
    );
    exports.MqttWill = MqttWill;
    exports.DEFAULT_RECONNECT_MAX_SEC = 128;
    exports.DEFAULT_RECONNECT_MIN_SEC = 1;
  }
});

// node_modules/aws-crt/dist.browser/browser/mqtt.js
var require_mqtt3 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/mqtt.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator9 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op2) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
              return t;
            if (y = 0, t)
              op2 = [op2[0] & 2, t.value];
            switch (op2[0]) {
              case 0:
              case 1:
                t = op2;
                break;
              case 4:
                _2.label++;
                return { value: op2[1], done: false };
              case 5:
                _2.label++;
                y = op2[1];
                op2 = [0];
                continue;
              case 7:
                op2 = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                  _2.label = op2[1];
                  break;
                }
                if (op2[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op2;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op2);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op2 = body.call(thisArg, _2);
          } catch (e) {
            op2 = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op2[0] & 5)
          throw op2[1];
        return { value: op2[0] ? op2[1] : void 0, done: true };
      }
    };
    var __values6 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MqttClientConnection = exports.MqttClient = exports.MqttWill = exports.QoS = void 0;
    var mqtt = __importStar2(require_connect());
    var WebsocketUtils = __importStar2(require_ws2());
    var auth = __importStar2(require_auth());
    var trie_1 = require_trie();
    var event_1 = require_event();
    var browser_1 = require_browser6();
    var mqtt_1 = require_mqtt2();
    var mqtt_shared_1 = require_mqtt_shared();
    var mqtt_2 = require_mqtt2();
    Object.defineProperty(exports, "QoS", { enumerable: true, get: function() {
      return mqtt_2.QoS;
    } });
    Object.defineProperty(exports, "MqttWill", { enumerable: true, get: function() {
      return mqtt_2.MqttWill;
    } });
    var MqttClient = (
      /** @class */
      function() {
        function MqttClient2(bootstrap) {
        }
        MqttClient2.prototype.new_connection = function(config) {
          return new MqttClientConnection(this, config);
        };
        return MqttClient2;
      }()
    );
    exports.MqttClient = MqttClient;
    var MqttBrowserClientState;
    (function(MqttBrowserClientState2) {
      MqttBrowserClientState2[MqttBrowserClientState2["Connected"] = 0] = "Connected";
      MqttBrowserClientState2[MqttBrowserClientState2["Stopped"] = 1] = "Stopped";
    })(MqttBrowserClientState || (MqttBrowserClientState = {}));
    var TopicTrie = (
      /** @class */
      function(_super) {
        __extends19(TopicTrie2, _super);
        function TopicTrie2() {
          return _super.call(this, "/") || this;
        }
        TopicTrie2.prototype.find_node = function(key, op2) {
          var e_1, _a2;
          var parts = this.split_key(key);
          var current = this.root;
          var parent = void 0;
          try {
            for (var parts_1 = __values6(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
              var part = parts_1_1.value;
              var child = current.children.get(part);
              if (!child) {
                child = current.children.get("#");
                if (child) {
                  return child;
                }
                child = current.children.get("+");
              }
              if (!child) {
                if (op2 == trie_1.TrieOp.Insert) {
                  current.children.set(part, child = new trie_1.Node(part));
                } else {
                  return void 0;
                }
              }
              parent = current;
              current = child;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (parts_1_1 && !parts_1_1.done && (_a2 = parts_1.return))
                _a2.call(parts_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (parent && op2 == trie_1.TrieOp.Delete) {
            parent.children.delete(current.key);
          }
          return current;
        };
        return TopicTrie2;
      }(trie_1.Trie)
    );
    var MqttClientConnection = (
      /** @class */
      function(_super) {
        __extends19(MqttClientConnection2, _super);
        function MqttClientConnection2(client, config) {
          var _this = _super.call(this) || this;
          _this.client = client;
          _this.config = config;
          _this.subscriptions = new TopicTrie();
          _this.connection_count = 0;
          _this.reconnect_count = 0;
          _this.reconnect_min_sec = mqtt_1.DEFAULT_RECONNECT_MIN_SEC;
          _this.reconnect_max_sec = mqtt_1.DEFAULT_RECONNECT_MAX_SEC;
          _this.currentState = MqttBrowserClientState.Stopped;
          _this.desiredState = MqttBrowserClientState.Stopped;
          _this.on_connect = function(connack) {
            _this.on_online(connack.sessionPresent);
          };
          _this.on_online = function(session_present) {
            _this.currentState = MqttBrowserClientState.Connected;
            if (++_this.connection_count == 1) {
              _this.emit("connect", session_present);
            } else {
              _this.reset_reconnect_times();
              _this.emit("resume", 0, session_present);
            }
            var successCallbackData = { session_present };
            _this.emit("connection_success", successCallbackData);
          };
          _this.on_close = function() {
            var _a2;
            var lastError = _this.lastError;
            if (_this.currentState == MqttBrowserClientState.Connected) {
              _this.currentState = MqttBrowserClientState.Stopped;
              _this.emit("interrupt", -1);
              if (_this.desiredState == MqttBrowserClientState.Stopped) {
                _this.emit("closed");
              }
            }
            if (_this.desiredState == MqttBrowserClientState.Connected) {
              var crtError = new browser_1.CrtError((_a2 = lastError === null || lastError === void 0 ? void 0 : lastError.toString()) !== null && _a2 !== void 0 ? _a2 : "connectionFailure");
              var failureCallbackData = { error: crtError };
              _this.emit("connection_failure", failureCallbackData);
              var waitTime = _this.get_reconnect_time_sec();
              _this.reconnectTask = setTimeout(function() {
                _this.reconnect_count++;
                _this.connection.reconnect();
              }, waitTime * 1e3);
            }
            _this.lastError = void 0;
          };
          _this.on_disconnected = function() {
            _this.emit("disconnect");
            if (_this.currentState == MqttBrowserClientState.Connected && _this.desiredState == MqttBrowserClientState.Stopped) {
              var closedCallbackData = {};
              _this.emit("closed", closedCallbackData);
            }
          };
          _this.on_error = function(error) {
            _this.lastError = error;
            _this.emit("error", new browser_1.CrtError(error));
          };
          _this.on_message = function(topic, payload, packet) {
            var array_buffer = payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.byteLength);
            var callback = _this.subscriptions.find(topic);
            if (callback) {
              callback(topic, array_buffer, packet.dup, packet.qos, packet.retain);
            }
            _this.emit("message", topic, array_buffer, packet.dup, packet.qos, packet.retain);
          };
          var create_websocket_stream = function(client2) {
            return WebsocketUtils.create_websocket_stream(_this.config);
          };
          var transform_websocket_url = function(url, options, client2) {
            return WebsocketUtils.create_websocket_url(_this.config);
          };
          if (config == null || config == void 0) {
            throw new browser_1.CrtError("MqttClientConnection constructor: config not defined");
          }
          var will = _this.config.will ? {
            topic: _this.config.will.topic,
            payload: (0, mqtt_shared_1.normalize_payload)(_this.config.will.payload),
            qos: _this.config.will.qos,
            retain: _this.config.will.retain
          } : void 0;
          if (config.reconnect_min_sec !== void 0) {
            _this.reconnect_min_sec = config.reconnect_min_sec;
            _this.reconnect_max_sec = Math.max(_this.reconnect_min_sec, _this.reconnect_max_sec);
          }
          if (config.reconnect_max_sec !== void 0) {
            _this.reconnect_max_sec = config.reconnect_max_sec;
            _this.reconnect_min_sec = Math.min(_this.reconnect_min_sec, _this.reconnect_max_sec);
          }
          _this.reset_reconnect_times();
          if (_this.config.credentials_provider == void 0 && _this.config.credentials != void 0) {
            var provider = new auth.StaticCredentialProvider({
              aws_region: _this.config.credentials.aws_region,
              aws_access_id: _this.config.credentials.aws_access_id,
              aws_secret_key: _this.config.credentials.aws_secret_key,
              aws_sts_token: _this.config.credentials.aws_sts_token
            });
            _this.config.credentials_provider = provider;
          }
          var websocketXform = (_this.config.websocket || {}).protocol != "wss-custom-auth" ? transform_websocket_url : void 0;
          _this.connection = new mqtt.MqttClient(create_websocket_stream, {
            // service default is 1200 seconds
            keepalive: _this.config.keep_alive ? _this.config.keep_alive : 1200,
            clientId: _this.config.client_id,
            connectTimeout: _this.config.ping_timeout ? _this.config.ping_timeout : 30 * 1e3,
            clean: _this.config.clean_session,
            username: _this.config.username,
            password: _this.config.password,
            reconnectPeriod: _this.reconnect_max_sec * 1e3,
            will,
            transformWsUrl: websocketXform
          });
          _this.connection.on("connect", _this.on_connect);
          _this.connection.on("error", _this.on_error);
          _this.connection.on("message", _this.on_message);
          _this.connection.on("close", _this.on_close);
          _this.connection.on("end", _this.on_disconnected);
          return _this;
        }
        MqttClientConnection2.prototype.on = function(event, listener) {
          return _super.prototype.on.call(this, event, listener);
        };
        MqttClientConnection2.prototype.connect = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              this.desiredState = MqttBrowserClientState.Connected;
              setTimeout(function() {
                _this.uncork();
              }, 0);
              return [2, new Promise(function(resolve, reject) {
                return __awaiter2(_this, void 0, void 0, function() {
                  var provider, on_connect_error;
                  var _this2 = this;
                  return __generator9(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        provider = this.config.credentials_provider;
                        if (!provider)
                          return [3, 2];
                        return [4, provider.refreshCredentials()];
                      case 1:
                        _a3.sent();
                        _a3.label = 2;
                      case 2:
                        on_connect_error = function(error) {
                          var crtError = new browser_1.CrtError(error);
                          var failureCallbackData = { error: crtError };
                          _this2.emit("connection_failure", failureCallbackData);
                          reject(crtError);
                        };
                        this.connection.once("error", on_connect_error);
                        this.connection.once("connect", function(connack) {
                          _this2.connection.removeListener("error", on_connect_error);
                          resolve(connack.sessionPresent);
                        });
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              })];
            });
          });
        };
        MqttClientConnection2.prototype.reconnect = function() {
          return __awaiter2(this, void 0, void 0, function() {
            return __generator9(this, function(_a2) {
              return [2, this.connect()];
            });
          });
        };
        MqttClientConnection2.prototype.publish = function(topic, payload, qos, retain) {
          if (retain === void 0) {
            retain = false;
          }
          return __awaiter2(this, void 0, void 0, function() {
            var payload_data;
            var _this = this;
            return __generator9(this, function(_a2) {
              if (typeof topic !== "string") {
                return [2, Promise.reject("topic is not a string")];
              }
              if (typeof qos !== "number") {
                return [2, Promise.reject("qos is not a number")];
              }
              if (typeof retain !== "boolean") {
                return [2, Promise.reject("retain is not a boolean")];
              }
              payload_data = (0, mqtt_shared_1.normalize_payload)(payload);
              return [2, new Promise(function(resolve, reject) {
                _this.connection.publish(topic, payload_data, { qos, retain }, function(error, packet) {
                  if (error) {
                    reject(new browser_1.CrtError(error));
                    return _this.on_error(error);
                  }
                  var id2 = void 0;
                  if (qos != mqtt_1.QoS.AtMostOnce) {
                    id2 = packet.messageId;
                  }
                  resolve({ packet_id: id2 });
                });
              })];
            });
          });
        };
        MqttClientConnection2.prototype.subscribe = function(topic, qos, on_message) {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              if (typeof topic !== "string") {
                return [2, Promise.reject("topic is not a string")];
              }
              if (typeof qos !== "number") {
                return [2, Promise.reject("qos is not a number")];
              }
              this.subscriptions.insert(topic, on_message);
              return [2, new Promise(function(resolve, reject) {
                _this.connection.subscribe(topic, { qos }, function(error, packet) {
                  if (error) {
                    reject(new browser_1.CrtError(error));
                    return _this.on_error(error);
                  }
                  var sub = packet[0];
                  resolve({ topic: sub.topic, qos: sub.qos });
                });
              })];
            });
          });
        };
        MqttClientConnection2.prototype.unsubscribe = function(topic) {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              if (typeof topic !== "string") {
                return [2, Promise.reject("topic is not a string")];
              }
              this.subscriptions.remove(topic);
              return [2, new Promise(function(resolve, reject) {
                _this.connection.unsubscribe(topic, void 0, function(error, packet) {
                  if (error) {
                    reject(new browser_1.CrtError(error));
                    return _this.on_error(error);
                  }
                  resolve({
                    packet_id: packet ? packet.messageId : void 0
                  });
                });
              })];
            });
          });
        };
        MqttClientConnection2.prototype.disconnect = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var _this = this;
            return __generator9(this, function(_a2) {
              this.desiredState = MqttBrowserClientState.Stopped;
              if (this.reconnectTask) {
                clearTimeout(this.reconnectTask);
                this.reconnectTask = void 0;
              }
              return [2, new Promise(function(resolve) {
                _this.connection.end(false, {}, resolve);
              })];
            });
          });
        };
        MqttClientConnection2.prototype.reset_reconnect_times = function() {
          this.reconnect_count = 0;
        };
        MqttClientConnection2.prototype.get_reconnect_time_sec = function() {
          if (this.reconnect_min_sec == 0 && this.reconnect_max_sec == 0) {
            return 0;
          }
          var cap = this.reconnect_max_sec - this.reconnect_min_sec;
          var base = Math.max(this.reconnect_min_sec, 1);
          var sleep = Math.random() * Math.min(cap, base * Math.pow(2, this.reconnect_count));
          return this.reconnect_min_sec + sleep;
        };
        MqttClientConnection2.CONNECT = "connect";
        MqttClientConnection2.DISCONNECT = "disconnect";
        MqttClientConnection2.ERROR = "error";
        MqttClientConnection2.INTERRUPT = "interrupt";
        MqttClientConnection2.RESUME = "resume";
        MqttClientConnection2.MESSAGE = "message";
        MqttClientConnection2.CONNECTION_SUCCESS = "connection_success";
        MqttClientConnection2.CONNECTION_FAILURE = "connection_failure";
        MqttClientConnection2.CLOSED = "closed";
        return MqttClientConnection2;
      }(event_1.BufferedEventEmitter)
    );
    exports.MqttClientConnection = MqttClientConnection;
  }
});

// node_modules/aws-crt/dist.browser/common/http.js
var require_http = __commonJS({
  "node_modules/aws-crt/dist.browser/common/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonHttpProxyOptions = exports.HttpProxyAuthenticationType = exports.HttpVersion = void 0;
    var HttpVersion;
    (function(HttpVersion2) {
      HttpVersion2[HttpVersion2["Unknown"] = 0] = "Unknown";
      HttpVersion2[HttpVersion2["Http1_0"] = 1] = "Http1_0";
      HttpVersion2[HttpVersion2["Http1_1"] = 2] = "Http1_1";
      HttpVersion2[HttpVersion2["Http2"] = 3] = "Http2";
    })(HttpVersion = exports.HttpVersion || (exports.HttpVersion = {}));
    var HttpProxyAuthenticationType;
    (function(HttpProxyAuthenticationType2) {
      HttpProxyAuthenticationType2[HttpProxyAuthenticationType2["None"] = 0] = "None";
      HttpProxyAuthenticationType2[HttpProxyAuthenticationType2["Basic"] = 1] = "Basic";
    })(HttpProxyAuthenticationType = exports.HttpProxyAuthenticationType || (exports.HttpProxyAuthenticationType = {}));
    var CommonHttpProxyOptions = (
      /** @class */
      function() {
        function CommonHttpProxyOptions2(host_name, port, auth_method, auth_username, auth_password) {
          if (auth_method === void 0) {
            auth_method = HttpProxyAuthenticationType.None;
          }
          this.host_name = host_name;
          this.port = port;
          this.auth_method = auth_method;
          this.auth_username = auth_username;
          this.auth_password = auth_password;
        }
        return CommonHttpProxyOptions2;
      }()
    );
    exports.CommonHttpProxyOptions = CommonHttpProxyOptions;
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn2, thisArg) {
      return function wrap() {
        return fn2.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val2) {
      return val2 !== null && !isUndefined(val2) && val2.constructor !== null && !isUndefined(val2.constructor) && isFunction(val2.constructor.isBuffer) && val2.constructor.isBuffer(val2);
    }
    var isArrayBuffer2 = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val2) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val2);
      } else {
        result = val2 && val2.buffer && isArrayBuffer2(val2.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val2) => {
      if (kindOf(val2) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val2);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val2) && !(Symbol.iterator in val2);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val2) => isObject(val2) && isFunction(val2.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn2, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l2 = obj.length; i < l2; i++) {
          fn2.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn2.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val2, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val2)) {
          result[targetKey] = merge(result[targetKey], val2);
        } else if (isPlainObject(val2)) {
          result[targetKey] = merge({}, val2);
        } else if (isArray(val2)) {
          result[targetKey] = val2.slice();
        } else {
          result[targetKey] = val2;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
      forEach(b2, (val2, key) => {
        if (thisArg && isFunction(val2)) {
          a[key] = bind(val2, thisArg);
        } else {
          a[key] = val2;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn2) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn2.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray,
      isArrayBuffer: isArrayBuffer2,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el2, index) {
              !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el2)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el2, key) {
          const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
            formData,
            el2,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el2, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val2) {
      return encodeURIComponent(val2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn2) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn2(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform2 = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform2.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform2.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform2.classes.FormData,
        Blob: platform2.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val2;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val2 = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val2);
          } else {
            parsed[key] = [val2];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val2 : val2;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader2(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader2);
        } else {
          deleteHeader2(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn2) {
        data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform2.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform2.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform2.hasStandardBrowserEnv || platform2.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform2.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val2, key) {
            request.setRequestHeader(key, val2);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform2.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn2, value) => {
      if (fn2) {
        try {
          Object.defineProperty(fn2, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn2, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id2;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id2}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id2 || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b2, caseless) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(a, b2, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.6.5";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain2 = [dispatchRequest.bind(this), void 0];
          chain2.unshift.apply(chain2, requestInterceptorChain);
          chain2.push.apply(chain2, responseInterceptorChain);
          len = chain2.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain2[i++], chain2[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/aws-crt/dist.browser/browser/http.js
var require_http2 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/http.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b2) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
          d2.__proto__ = b3;
        } || function(d2, b3) {
          for (var p in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p))
              d2[p] = b3[p];
        };
        return extendStatics2(d, b2);
      };
      return function(d, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics2(d, b2);
        function __() {
          this.constructor = d;
        }
        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __generator9 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v2) {
          return step([n, v2]);
        };
      }
      function step(op2) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
              return t;
            if (y = 0, t)
              op2 = [op2[0] & 2, t.value];
            switch (op2[0]) {
              case 0:
              case 1:
                t = op2;
                break;
              case 4:
                _2.label++;
                return { value: op2[1], done: false };
              case 5:
                _2.label++;
                y = op2[1];
                op2 = [0];
                continue;
              case 7:
                op2 = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                  _2.label = op2[1];
                  break;
                }
                if (op2[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1];
                  t = op2;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2];
                  _2.ops.push(op2);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op2 = body.call(thisArg, _2);
          } catch (e) {
            op2 = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op2[0] & 5)
          throw op2[1];
        return { value: op2[0] ? op2[1] : void 0, done: true };
      }
    };
    var __values6 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2)
        return m2.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClientConnectionManager = exports.HttpClientStream = exports.HttpClientConnection = exports.HttpRequest = exports.HttpProxyOptions = exports.HttpHeaders = exports.HttpProxyAuthenticationType = void 0;
    var http_1 = require_http();
    var http_2 = require_http();
    Object.defineProperty(exports, "HttpProxyAuthenticationType", { enumerable: true, get: function() {
      return http_2.HttpProxyAuthenticationType;
    } });
    var event_1 = require_event();
    var error_1 = require_error();
    var axios = __importStar2(require_axios());
    var io_1 = require_io2();
    var util_utf8_browser_1 = (init_dist_es12(), __toCommonJS(dist_es_exports));
    var HttpHeaders = (
      /** @class */
      function() {
        function HttpHeaders2(headers) {
          var e_1, _a2;
          if (headers === void 0) {
            headers = [];
          }
          this.headers = {};
          try {
            for (var headers_1 = __values6(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
              var header = headers_1_1.value;
              this.add(header[0], header[1]);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (headers_1_1 && !headers_1_1.done && (_a2 = headers_1.return))
                _a2.call(headers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        Object.defineProperty(HttpHeaders2.prototype, "length", {
          /**
           * Fetches the total length of all headers
           *
           * @returns the total length of all headers
           */
          get: function() {
            var length = 0;
            for (var key in this.headers) {
              length += this.headers[key].length;
            }
            return length;
          },
          enumerable: false,
          configurable: true
        });
        HttpHeaders2.prototype.add = function(name, value) {
          var values = this.headers[name.toLowerCase()];
          if (values) {
            values.push([name, value]);
          } else {
            this.headers[name.toLowerCase()] = [[name, value]];
          }
        };
        HttpHeaders2.prototype.set = function(name, value) {
          this.headers[name.toLowerCase()] = [[name, value]];
        };
        HttpHeaders2.prototype.get_values = function(name) {
          var e_2, _a2;
          var values = [];
          var values_list = this.headers[name.toLowerCase()] || [];
          try {
            for (var values_list_1 = __values6(values_list), values_list_1_1 = values_list_1.next(); !values_list_1_1.done; values_list_1_1 = values_list_1.next()) {
              var entry = values_list_1_1.value;
              values.push(entry[1]);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (values_list_1_1 && !values_list_1_1.done && (_a2 = values_list_1.return))
                _a2.call(values_list_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          return values;
        };
        HttpHeaders2.prototype.get = function(name, default_value) {
          if (default_value === void 0) {
            default_value = "";
          }
          var values = this.headers[name.toLowerCase()];
          if (!values) {
            return default_value;
          }
          return values[0][1] || default_value;
        };
        HttpHeaders2.prototype.remove = function(name) {
          delete this.headers[name.toLowerCase()];
        };
        HttpHeaders2.prototype.remove_value = function(name, value) {
          var key = name.toLowerCase();
          var values = this.headers[key];
          for (var idx = 0; idx < values.length; ++idx) {
            var entry = values[idx];
            if (entry[1] === value) {
              if (values.length === 1) {
                delete this.headers[key];
              } else {
                delete values[idx];
              }
              return;
            }
          }
        };
        HttpHeaders2.prototype.clear = function() {
          this.headers = {};
        };
        HttpHeaders2.prototype[Symbol.iterator] = function() {
          var _a2, _b, _i2, key, values, values_1, values_1_1, entry, e_3_1;
          var e_3, _c2;
          return __generator9(this, function(_d2) {
            switch (_d2.label) {
              case 0:
                _a2 = [];
                for (_b in this.headers)
                  _a2.push(_b);
                _i2 = 0;
                _d2.label = 1;
              case 1:
                if (!(_i2 < _a2.length))
                  return [3, 10];
                key = _a2[_i2];
                values = this.headers[key];
                _d2.label = 2;
              case 2:
                _d2.trys.push([2, 7, 8, 9]);
                values_1 = (e_3 = void 0, __values6(values)), values_1_1 = values_1.next();
                _d2.label = 3;
              case 3:
                if (!!values_1_1.done)
                  return [3, 6];
                entry = values_1_1.value;
                return [4, entry];
              case 4:
                _d2.sent();
                _d2.label = 5;
              case 5:
                values_1_1 = values_1.next();
                return [3, 3];
              case 6:
                return [3, 9];
              case 7:
                e_3_1 = _d2.sent();
                e_3 = { error: e_3_1 };
                return [3, 9];
              case 8:
                try {
                  if (values_1_1 && !values_1_1.done && (_c2 = values_1.return))
                    _c2.call(values_1);
                } finally {
                  if (e_3)
                    throw e_3.error;
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 9:
                _i2++;
                return [3, 1];
              case 10:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        HttpHeaders2.prototype._flatten = function() {
          var e_4, _a2;
          var flattened = [];
          try {
            for (var _b = __values6(this), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
              var pair = _c2.value;
              flattened.push(pair);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a2 = _b.return))
                _a2.call(_b);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          return flattened;
        };
        return HttpHeaders2;
      }()
    );
    exports.HttpHeaders = HttpHeaders;
    var HttpProxyOptions = (
      /** @class */
      function(_super) {
        __extends19(HttpProxyOptions2, _super);
        function HttpProxyOptions2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return HttpProxyOptions2;
      }(http_1.CommonHttpProxyOptions)
    );
    exports.HttpProxyOptions = HttpProxyOptions;
    var HttpRequest2 = (
      /** @class */
      function() {
        function HttpRequest3(method, path, headers, body) {
          if (headers === void 0) {
            headers = new HttpHeaders();
          }
          this.method = method;
          this.path = path;
          this.headers = headers;
          this.body = body;
        }
        return HttpRequest3;
      }()
    );
    exports.HttpRequest = HttpRequest2;
    var HttpClientConnection = (
      /** @class */
      function(_super) {
        __extends19(HttpClientConnection2, _super);
        function HttpClientConnection2(bootstrap, host_name, port, socketOptions, tlsOptions, proxyOptions) {
          var _this = _super.call(this) || this;
          _this.cork();
          _this.bootstrap = bootstrap;
          _this.socket_options = socketOptions;
          _this.tls_options = tlsOptions;
          _this.proxy_options = proxyOptions;
          var scheme = _this.tls_options || port === 443 ? "https" : "http";
          _this.axios_options = {
            baseURL: "".concat(scheme, "://").concat(host_name, ":").concat(port, "/")
          };
          if (_this.proxy_options) {
            _this.axios_options.proxy = {
              host: _this.proxy_options.host_name,
              port: _this.proxy_options.port
            };
            if (_this.proxy_options.auth_method == http_1.HttpProxyAuthenticationType.Basic) {
              _this.axios_options.proxy.auth = {
                username: _this.proxy_options.auth_username || "",
                password: _this.proxy_options.auth_password || ""
              };
            }
          }
          _this._axios = axios.default.create(_this.axios_options);
          setTimeout(function() {
            _this.emit("connect");
          }, 0);
          return _this;
        }
        HttpClientConnection2.prototype.on = function(event, listener) {
          var _this = this;
          _super.prototype.on.call(this, event, listener);
          if (event == "connect") {
            setTimeout(function() {
              _this.uncork();
            }, 0);
          }
          return this;
        };
        HttpClientConnection2.prototype.request = function(request) {
          return stream_request(this, request);
        };
        HttpClientConnection2.prototype.close = function() {
          this.emit("close");
          this._axios = void 0;
        };
        HttpClientConnection2.CONNECT = "connect";
        HttpClientConnection2.ERROR = "error";
        HttpClientConnection2.CLOSE = "close";
        return HttpClientConnection2;
      }(event_1.BufferedEventEmitter)
    );
    exports.HttpClientConnection = HttpClientConnection;
    function stream_request(connection, request) {
      if (request == null || request == void 0) {
        throw new error_1.CrtError("HttpClientConnection stream_request: request not defined");
      }
      var _to_object = function(headers) {
        var e_5, _a2;
        var forbidden_headers = ["host", "user-agent"];
        var obj = {};
        try {
          for (var headers_2 = __values6(headers), headers_2_1 = headers_2.next(); !headers_2_1.done; headers_2_1 = headers_2.next()) {
            var header = headers_2_1.value;
            if (forbidden_headers.indexOf(header[0].toLowerCase()) != -1) {
              continue;
            }
            obj[header[0]] = headers.get(header[0]);
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (headers_2_1 && !headers_2_1.done && (_a2 = headers_2.return))
              _a2.call(headers_2);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
        return obj;
      };
      var body = request.body ? request.body.data : void 0;
      var stream = HttpClientStream._create(connection);
      stream.connection._axios.request({
        url: request.path,
        method: request.method.toLowerCase(),
        headers: _to_object(request.headers),
        body
      }).then(function(response) {
        stream._on_response(response);
      }).catch(function(error) {
        stream._on_error(error);
      });
      return stream;
    }
    var HttpClientStream = (
      /** @class */
      function(_super) {
        __extends19(HttpClientStream2, _super);
        function HttpClientStream2(connection) {
          var _this = _super.call(this) || this;
          _this.connection = connection;
          _this.cork();
          return _this;
        }
        HttpClientStream2.prototype.status_code = function() {
          return this.response_status_code;
        };
        HttpClientStream2.prototype.activate = function() {
          var _this = this;
          setTimeout(function() {
            _this.uncork();
          }, 0);
        };
        HttpClientStream2.prototype.on = function(event, listener) {
          return _super.prototype.on.call(this, event, listener);
        };
        HttpClientStream2._create = function(connection) {
          return new HttpClientStream2(connection);
        };
        HttpClientStream2.prototype._on_response = function(response) {
          this.response_status_code = response.status;
          var headers = new HttpHeaders();
          for (var header in response.headers) {
            headers.add(header, response.headers[header]);
          }
          this.emit("response", this.response_status_code, headers);
          var data = response.data;
          if (data && !(data instanceof ArrayBuffer)) {
            data = (0, util_utf8_browser_1.fromUtf8)(data.toString());
          }
          this.emit("data", data);
          this.emit("end");
        };
        HttpClientStream2.prototype._on_error = function(error) {
          var info = "";
          if (error.response) {
            this.response_status_code = error.response.status;
            info += "status_code=".concat(error.response.status);
            if (error.response.headers) {
              info += " headers=".concat(JSON.stringify(error.response.headers));
            }
            if (error.response.data) {
              info += " data=".concat(error.response.data);
            }
          } else {
            info = "No response from server";
          }
          this.connection.close();
          this.emit("error", new Error("msg=".concat(error.message, ", connection=").concat(JSON.stringify(this.connection), ", info=").concat(info)));
        };
        HttpClientStream2.RESPONSE = "response";
        HttpClientStream2.DATA = "data";
        HttpClientStream2.ERROR = "error";
        HttpClientStream2.END = "end";
        return HttpClientStream2;
      }(event_1.BufferedEventEmitter)
    );
    exports.HttpClientStream = HttpClientStream;
    var HttpClientConnectionManager = (
      /** @class */
      function() {
        function HttpClientConnectionManager2(bootstrap, host, port, max_connections, initial_window_size, socket_options, tls_opts, proxy_options) {
          this.bootstrap = bootstrap;
          this.host = host;
          this.port = port;
          this.max_connections = max_connections;
          this.initial_window_size = initial_window_size;
          this.socket_options = socket_options;
          this.tls_opts = tls_opts;
          this.proxy_options = proxy_options;
          this.pending_connections = /* @__PURE__ */ new Set();
          this.live_connections = /* @__PURE__ */ new Set();
          this.free_connections = [];
          this.pending_requests = [];
        }
        HttpClientConnectionManager2.prototype.remove = function(connection) {
          this.pending_connections.delete(connection);
          this.live_connections.delete(connection);
          var free_idx = this.free_connections.indexOf(connection);
          if (free_idx != -1) {
            this.free_connections.splice(free_idx, 1);
          }
        };
        HttpClientConnectionManager2.prototype.resolve = function(connection) {
          var request = this.pending_requests.shift();
          if (request) {
            request.resolve(connection);
          } else {
            this.free_connections.push(connection);
          }
        };
        HttpClientConnectionManager2.prototype.reject = function(error) {
          var request = this.pending_requests.shift();
          if (request) {
            request.reject(error);
          }
        };
        HttpClientConnectionManager2.prototype.pump = function() {
          var _this = this;
          if (this.pending_requests.length == 0) {
            return;
          }
          {
            var connection_1 = this.free_connections.pop();
            if (connection_1) {
              return this.resolve(connection_1);
            }
          }
          if (this.live_connections.size + this.pending_connections.size == this.max_connections) {
            return;
          }
          var connection = new HttpClientConnection(new io_1.ClientBootstrap(), this.host, this.port, this.socket_options, this.tls_opts, this.proxy_options);
          this.pending_connections.add(connection);
          var on_connect = function() {
            _this.pending_connections.delete(connection);
            _this.live_connections.add(connection);
            _this.free_connections.push(connection);
            _this.resolve(connection);
          };
          var on_error = function(error) {
            if (_this.pending_connections.has(connection)) {
              return _this.reject(new error_1.CrtError(error));
            }
            _this.remove(connection);
            _this.pump();
          };
          var on_close = function() {
            _this.remove(connection);
            _this.pump();
          };
          connection.on("connect", on_connect);
          connection.on("error", on_error);
          connection.on("close", on_close);
        };
        HttpClientConnectionManager2.prototype.acquire = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.pending_requests.push({
              resolve,
              reject
            });
            _this.pump();
          });
        };
        HttpClientConnectionManager2.prototype.release = function(connection) {
          this.free_connections.push(connection);
          this.pump();
        };
        HttpClientConnectionManager2.prototype.close = function() {
          this.pending_requests.forEach(function(request) {
            request.reject(new error_1.CrtError("HttpClientConnectionManager shutting down"));
          });
        };
        return HttpClientConnectionManager2;
      }()
    );
    exports.HttpClientConnectionManager = HttpClientConnectionManager;
  }
});

// node_modules/aws-crt/dist.browser/browser/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/crypto.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha256 = exports.Sha256Hmac = exports.hash_sha1 = exports.Sha1Hash = exports.hash_sha256 = exports.Sha256Hash = exports.hash_md5 = exports.Md5Hash = void 0;
    var Crypto = __importStar2(require_crypto_js());
    var util_utf8_browser_1 = (init_dist_es12(), __toCommonJS(dist_es_exports));
    var Md5Hash = (
      /** @class */
      function() {
        function Md5Hash2() {
        }
        Md5Hash2.prototype.update = function(data) {
          this.hash = Crypto.MD5(data.toString(), this.hash ? this.hash.toString() : void 0);
        };
        Md5Hash2.prototype.finalize = function(truncate_to) {
          var digest = this.hash ? this.hash.toString() : "";
          var truncated = digest.substring(0, truncate_to ? truncate_to : digest.length);
          var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
          return new DataView(bytes.buffer);
        };
        return Md5Hash2;
      }()
    );
    exports.Md5Hash = Md5Hash;
    function hash_md5(data, truncate_to) {
      var md5 = new Md5Hash();
      md5.update(data);
      return md5.finalize(truncate_to);
    }
    exports.hash_md5 = hash_md5;
    var Sha256Hash = (
      /** @class */
      function() {
        function Sha256Hash2() {
        }
        Sha256Hash2.prototype.update = function(data) {
          this.hash = Crypto.SHA256(data.toString(), this.hash ? this.hash.toString() : void 0);
        };
        Sha256Hash2.prototype.finalize = function(truncate_to) {
          var digest = this.hash ? this.hash.toString() : "";
          var truncated = digest.substring(0, truncate_to ? truncate_to : digest.length);
          var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
          return new DataView(bytes.buffer);
        };
        return Sha256Hash2;
      }()
    );
    exports.Sha256Hash = Sha256Hash;
    function hash_sha256(data, truncate_to) {
      var digest = Crypto.SHA256(data.toString()).toString();
      var truncated = digest.substring(0, truncate_to ? truncate_to : digest.length);
      var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
      return new DataView(bytes.buffer);
    }
    exports.hash_sha256 = hash_sha256;
    var Sha1Hash = (
      /** @class */
      function() {
        function Sha1Hash2() {
        }
        Sha1Hash2.prototype.update = function(data) {
          this.hash = Crypto.SHA1(data.toString(), this.hash ? this.hash.toString() : void 0);
        };
        Sha1Hash2.prototype.finalize = function(truncate_to) {
          var digest = this.hash ? this.hash.toString() : "";
          var truncated = digest.substring(0, truncate_to ? truncate_to : digest.length);
          var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
          return new DataView(bytes.buffer);
        };
        return Sha1Hash2;
      }()
    );
    exports.Sha1Hash = Sha1Hash;
    function hash_sha1(data, truncate_to) {
      var digest = Crypto.SHA1(data.toString()).toString();
      var truncated = digest.substring(0, truncate_to ? truncate_to : digest.length);
      var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
      return new DataView(bytes.buffer);
    }
    exports.hash_sha1 = hash_sha1;
    var Sha256Hmac = (
      /** @class */
      function() {
        function Sha256Hmac2(secret) {
          this.hmac = Crypto.algo.HMAC.create(Crypto.algo.SHA256, secret);
        }
        Sha256Hmac2.prototype.update = function(data) {
          this.hmac.update(data.toString());
        };
        Sha256Hmac2.prototype.finalize = function(truncate_to) {
          var digest = this.hmac.finalize();
          var truncated = digest.toString().substring(0, truncate_to ? truncate_to : digest.length);
          var bytes = (0, util_utf8_browser_1.fromUtf8)(truncated);
          return new DataView(bytes.buffer);
        };
        return Sha256Hmac2;
      }()
    );
    exports.Sha256Hmac = Sha256Hmac;
    function hmac_sha256(secret, data, truncate_to) {
      var hmac = new Sha256Hmac(secret);
      hmac.update(data);
      return hmac.finalize(truncate_to);
    }
    exports.hmac_sha256 = hmac_sha256;
  }
});

// node_modules/aws-crt/dist.browser/browser/aws_iot.js
var require_aws_iot = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/aws_iot.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read6 = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2)
        return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar2.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"]))
            m2.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar2;
    };
    var __spreadArray4 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l2 = from.length, ar2; i < l2; i++) {
          if (ar2 || !(i in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i);
            ar2[i] = from[i];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsIotMqttConnectionConfigBuilder = void 0;
    var auth_1 = require_auth();
    var io_1 = require_io2();
    var platform2 = __importStar2(require_platform());
    var iot_shared = __importStar2(require_aws_iot_shared());
    var AwsIotMqttConnectionConfigBuilder = (
      /** @class */
      function() {
        function AwsIotMqttConnectionConfigBuilder2() {
          this.params = {
            client_id: "",
            host_name: "",
            socket_options: new io_1.SocketOptions(),
            port: 443,
            clean_session: false,
            keep_alive: void 0,
            will: void 0,
            username: "",
            password: void 0,
            websocket: {},
            credentials_provider: void 0
          };
        }
        AwsIotMqttConnectionConfigBuilder2.new_mtls_builder = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          return AwsIotMqttConnectionConfigBuilder2.new_builder_for_websocket();
        };
        AwsIotMqttConnectionConfigBuilder2.new_default_builder = function() {
          return AwsIotMqttConnectionConfigBuilder2.new_builder_for_websocket();
        };
        AwsIotMqttConnectionConfigBuilder2.new_websocket_builder = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          return this.new_with_websockets.apply(this, __spreadArray4([], __read6(args), false));
        };
        AwsIotMqttConnectionConfigBuilder2.new_with_websockets = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          return AwsIotMqttConnectionConfigBuilder2.new_builder_for_websocket();
        };
        AwsIotMqttConnectionConfigBuilder2.new_builder_for_websocket = function() {
          var builder = new AwsIotMqttConnectionConfigBuilder2();
          return builder;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_endpoint = function(endpoint) {
          this.params.host_name = endpoint;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_client_id = function(client_id) {
          this.params.client_id = client_id;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_port = function(port) {
          this.params.port = port;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_clean_session = function(clean_session) {
          this.params.clean_session = clean_session;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_use_websockets = function() {
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_keep_alive_seconds = function(keep_alive) {
          this.params.keep_alive = keep_alive;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_timeout_ms = function(timeout_ms) {
          this.with_ping_timeout_ms(timeout_ms);
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_ping_timeout_ms = function(ping_timeout) {
          this.params.ping_timeout = ping_timeout;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_will = function(will) {
          this.params.will = will;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_socket_options = function(socket_options) {
          this.params.socket_options = socket_options;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_websocket_headers = function(headers) {
          this.params.websocket = {
            headers
          };
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_credentials = function(aws_region, aws_access_id, aws_secret_key, aws_sts_token) {
          var provider = new auth_1.StaticCredentialProvider({
            aws_region,
            aws_access_id,
            aws_secret_key,
            aws_sts_token
          });
          this.params.credentials_provider = provider;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_credential_provider = function(customer_provider) {
          this.params.credentials_provider = customer_provider;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_custom_authorizer = function(username, authorizer_name, authorizer_signature, password, token_key_name, token_value) {
          var uri_encoded_signature = iot_shared.canonicalizeCustomAuthTokenSignature(authorizer_signature);
          var username_string = iot_shared.populate_username_string_with_custom_authorizer("", username, authorizer_name, uri_encoded_signature, this.params.username, token_key_name, token_value);
          this.params.username = username_string;
          this.params.password = password;
          if (this.params.websocket) {
            this.params.websocket.protocol = "wss-custom-auth";
          }
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_username = function(username) {
          this.params.username = username;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_password = function(password) {
          this.params.password = password;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_reconnect_max_sec = function(max_sec) {
          this.params.reconnect_max_sec = max_sec;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.with_reconnect_min_sec = function(min_sec) {
          this.params.reconnect_min_sec = min_sec;
          return this;
        };
        AwsIotMqttConnectionConfigBuilder2.prototype.build = function() {
          if (this.params.client_id === void 0 || this.params.host_name === void 0) {
            throw "client_id and endpoint are required";
          }
          if (this.params.username == void 0 || this.params.username == null || this.params.username == "") {
            this.params.username = "?SDK=NodeJSv2&Version=";
          } else {
            if (this.params.username.indexOf("?") != -1) {
              this.params.username += "&SDK=NodeJSv2&Version=";
            } else {
              this.params.username += "?SDK=NodeJSv2&Version=";
            }
          }
          this.params.username += platform2.crt_version();
          return this.params;
        };
        return AwsIotMqttConnectionConfigBuilder2;
      }()
    );
    exports.AwsIotMqttConnectionConfigBuilder = AwsIotMqttConnectionConfigBuilder;
  }
});

// node_modules/aws-crt/dist.browser/browser/aws_iot_mqtt5.js
var require_aws_iot_mqtt5 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/aws_iot_mqtt5.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsIotMqtt5ClientConfigBuilder = void 0;
    var mqtt5 = __importStar2(require_mqtt52());
    var iot_shared = __importStar2(require_aws_iot_shared());
    var error_1 = require_error();
    var AwsIotMqtt5ClientConfigBuilder = (
      /** @class */
      function() {
        function AwsIotMqtt5ClientConfigBuilder2(hostName, port, websocketConfig) {
          this.config = {
            hostName,
            port,
            connectProperties: {
              keepAliveIntervalSeconds: AwsIotMqtt5ClientConfigBuilder2.DEFAULT_KEEP_ALIVE
            },
            websocketOptions: websocketConfig
          };
        }
        AwsIotMqtt5ClientConfigBuilder2.newWebsocketMqttBuilderWithSigv4Auth = function(hostName, sigv4Config) {
          var _a2;
          if (sigv4Config == null || sigv4Config == void 0) {
            throw new error_1.CrtError("AwsIotMqtt5ClientConfigBuilder newWebsocketMqttBuilderWithSigv4Auth: sigv4Config not defined");
          }
          var region = (_a2 = sigv4Config.region) !== null && _a2 !== void 0 ? _a2 : iot_shared.extractRegionFromEndpoint(hostName);
          var websocketConfig = {
            urlFactoryOptions: {
              urlFactory: mqtt5.Mqtt5WebsocketUrlFactoryType.Sigv4,
              region,
              credentialsProvider: sigv4Config.credentialsProvider
            }
          };
          var builder = new AwsIotMqtt5ClientConfigBuilder2(hostName, AwsIotMqtt5ClientConfigBuilder2.DEFAULT_WEBSOCKET_MQTT_PORT, websocketConfig);
          return builder;
        };
        AwsIotMqtt5ClientConfigBuilder2.newWebsocketMqttBuilderWithCustomAuth = function(hostName, customAuthConfig) {
          var websocketConfig = {
            urlFactoryOptions: {
              urlFactory: mqtt5.Mqtt5WebsocketUrlFactoryType.Wss
            }
          };
          var builder = new AwsIotMqtt5ClientConfigBuilder2(hostName, AwsIotMqtt5ClientConfigBuilder2.DEFAULT_WEBSOCKET_MQTT_PORT, websocketConfig);
          builder.customAuthConfig = iot_shared.canonicalizeCustomAuthConfig(customAuthConfig);
          return builder;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withPort = function(port) {
          this.config.port = port;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withConnectProperties = function(connectPacket) {
          this.config.connectProperties = connectPacket;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withSessionBehavior = function(sessionBehavior) {
          this.config.sessionBehavior = sessionBehavior;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withRetryJitterMode = function(retryJitterMode) {
          this.config.retryJitterMode = retryJitterMode;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withMinReconnectDelayMs = function(minReconnectDelayMs) {
          this.config.minReconnectDelayMs = minReconnectDelayMs;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withMaxReconnectDelayMs = function(maxReconnectDelayMs) {
          this.config.maxReconnectDelayMs = maxReconnectDelayMs;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withMinConnectedTimeToResetReconnectDelayMs = function(minConnectedTimeToResetReconnectDelayMs) {
          this.config.minConnectedTimeToResetReconnectDelayMs = minConnectedTimeToResetReconnectDelayMs;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withConnectTimeoutMs = function(connectTimeoutMs) {
          this.config.connectTimeoutMs = connectTimeoutMs;
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.withWebsocketTransportOptions = function(options) {
          if (this.config.websocketOptions) {
            this.config.websocketOptions.wsOptions = options;
          }
          return this;
        };
        AwsIotMqtt5ClientConfigBuilder2.prototype.build = function() {
          var _a2, _b;
          if (this.config.connectProperties) {
            this.config.connectProperties.username = iot_shared.buildMqtt5FinalUsername(this.customAuthConfig);
            if ((_a2 = this.customAuthConfig) === null || _a2 === void 0 ? void 0 : _a2.password) {
              this.config.connectProperties.password = (_b = this.customAuthConfig) === null || _b === void 0 ? void 0 : _b.password;
            }
          }
          return this.config;
        };
        AwsIotMqtt5ClientConfigBuilder2.DEFAULT_WEBSOCKET_MQTT_PORT = 443;
        return AwsIotMqtt5ClientConfigBuilder2;
      }()
    );
    exports.AwsIotMqtt5ClientConfigBuilder = AwsIotMqtt5ClientConfigBuilder;
  }
});

// node_modules/aws-crt/dist.browser/browser/iot.js
var require_iot = __commonJS({
  "node_modules/aws-crt/dist.browser/browser/iot.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_aws_iot(), exports);
    __exportStar2(require_aws_iot_mqtt5(), exports);
  }
});

// node_modules/aws-crt/dist.browser/browser.js
var require_browser6 = __commonJS({
  "node_modules/aws-crt/dist.browser/browser.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrtError = exports.resource_safety = exports.promise = exports.platform = exports.mqtt5 = exports.mqtt = exports.iot = exports.io = exports.http = exports.crypto = exports.cancel = exports.auth = void 0;
    require_polyfills();
    var cancel = __importStar2(require_cancel());
    exports.cancel = cancel;
    var platform2 = __importStar2(require_platform());
    exports.platform = platform2;
    var promise = __importStar2(require_promise());
    exports.promise = promise;
    var resource_safety = __importStar2(require_resource_safety());
    exports.resource_safety = resource_safety;
    var io2 = __importStar2(require_io2());
    exports.io = io2;
    var mqtt = __importStar2(require_mqtt3());
    exports.mqtt = mqtt;
    var mqtt5 = __importStar2(require_mqtt52());
    exports.mqtt5 = mqtt5;
    var http = __importStar2(require_http2());
    exports.http = http;
    var crypto2 = __importStar2(require_crypto2());
    exports.crypto = crypto2;
    var iot = __importStar2(require_iot());
    exports.iot = iot;
    var auth = __importStar2(require_auth());
    exports.auth = auth;
    var error_1 = require_error();
    Object.defineProperty(exports, "CrtError", { enumerable: true, get: function() {
      return error_1.CrtError;
    } });
  }
});

// node_modules/@aws-sdk/signature-v4-crt/dist-es/constants.js
var AMZ_DATE_QUERY_PARAM2, SIGNATURE_QUERY_PARAM2, TOKEN_QUERY_PARAM2, AMZ_DATE_HEADER2, SIGNATURE_HEADER2, SHA256_HEADER2, TOKEN_HEADER2, MAX_PRESIGNED_TTL2;
var init_constants4 = __esm({
  "node_modules/@aws-sdk/signature-v4-crt/dist-es/constants.js"() {
    AMZ_DATE_QUERY_PARAM2 = "X-Amz-Date";
    SIGNATURE_QUERY_PARAM2 = "X-Amz-Signature";
    TOKEN_QUERY_PARAM2 = "X-Amz-Security-Token";
    AMZ_DATE_HEADER2 = AMZ_DATE_QUERY_PARAM2.toLowerCase();
    SIGNATURE_HEADER2 = SIGNATURE_QUERY_PARAM2.toLowerCase();
    SHA256_HEADER2 = "x-amz-content-sha256";
    TOKEN_HEADER2 = TOKEN_QUERY_PARAM2.toLowerCase();
    MAX_PRESIGNED_TTL2 = 60 * 60 * 24 * 7;
  }
});

// node_modules/@aws-sdk/signature-v4-crt/dist-es/headerUtil.js
function deleteHeader(soughtHeader, headers) {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      delete headers[headerName];
    }
  }
}
var init_headerUtil2 = __esm({
  "node_modules/@aws-sdk/signature-v4-crt/dist-es/headerUtil.js"() {
  }
});

// node_modules/@aws-sdk/signature-v4-crt/dist-es/CrtSignerV4.js
function sdkHttpRequest2crtHttpRequest(sdkRequest) {
  deleteHeader(SHA256_HEADER2, sdkRequest.headers);
  const headersArray = Object.entries(sdkRequest.headers);
  const crtHttpHeaders = new import_aws_crt.http.HttpHeaders(headersArray);
  const queryString = getCanonicalQuery(sdkRequest);
  return new import_aws_crt.http.HttpRequest(sdkRequest.method, sdkRequest.path + "?" + queryString, crtHttpHeaders);
}
function sdk2crtCredentialsProvider(credentials) {
  return import_aws_crt.auth.AwsCredentialsProvider.newStatic(credentials.accessKeyId, credentials.secretAccessKey, credentials.sessionToken);
}
function getHeadersUnsignable(unsignableHeaders, signableHeaders) {
  if (!unsignableHeaders) {
    return [];
  }
  if (!signableHeaders) {
    return [...unsignableHeaders];
  }
  const result = /* @__PURE__ */ new Set([...unsignableHeaders]);
  for (let it2 = signableHeaders.values(), val2 = null; val2 = it2.next().value; ) {
    if (result.has(val2)) {
      result.delete(val2);
    }
  }
  return [...result];
}
var import_aws_crt, CrtSignerV4;
var init_CrtSignerV4 = __esm({
  "node_modules/@aws-sdk/signature-v4-crt/dist-es/CrtSignerV4.js"() {
    init_dist_es25();
    init_dist_es16();
    init_dist_es14();
    import_aws_crt = __toESM(require_browser6());
    init_constants4();
    init_headerUtil2();
    CrtSignerV4 = class {
      constructor({ credentials, region, service, sha256, applyChecksum = true, uriEscapePath = true, signingAlgorithm = import_aws_crt.auth.AwsSigningAlgorithm.SigV4 }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.signingAlgorithm = signingAlgorithm;
        this.applyChecksum = applyChecksum;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
        import_aws_crt.io.enable_logging(import_aws_crt.io.LogLevel.ERROR);
      }
      async options2crtConfigure({ signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}, viaHeader, payloadHash, expiresIn, _credentials) {
        const credentials = _credentials ?? await this.credentialProvider();
        const region = signingRegion ?? await this.regionProvider();
        const service = signingService ?? this.service;
        if ((signableHeaders == null ? void 0 : signableHeaders.has("x-amzn-trace-id")) || (signableHeaders == null ? void 0 : signableHeaders.has("user-agent"))) {
          throw new Error("internal check (x-amzn-trace-id, user-agent) is not supported to be included to sign with CRT.");
        }
        const headersUnsignable = getHeadersUnsignable(unsignableHeaders, signableHeaders);
        return {
          algorithm: this.signingAlgorithm,
          signature_type: viaHeader ? import_aws_crt.auth.AwsSignatureType.HttpRequestViaHeaders : import_aws_crt.auth.AwsSignatureType.HttpRequestViaQueryParams,
          provider: sdk2crtCredentialsProvider(credentials),
          region,
          service,
          date: new Date(signingDate),
          header_blacklist: headersUnsignable,
          use_double_uri_encode: this.uriEscapePath,
          signed_body_value: payloadHash,
          signed_body_header: this.applyChecksum && viaHeader ? import_aws_crt.auth.AwsSignedBodyHeaderType.XAmzContentSha256 : import_aws_crt.auth.AwsSignedBodyHeaderType.None,
          expiration_in_seconds: expiresIn
        };
      }
      async presign(originalRequest, options = {}) {
        if (options.expiresIn && options.expiresIn > MAX_PRESIGNED_TTL2) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const request = moveHeadersToQuery(prepareRequest(originalRequest));
        const crtSignedRequest = await this.signRequest(request, await this.options2crtConfigure(options, false, await getPayloadHash(originalRequest, this.sha256), options.expiresIn ? options.expiresIn : 3600));
        request.query = this.getQueryParam(crtSignedRequest.path);
        return request;
      }
      async sign(toSign, options) {
        const request = prepareRequest(toSign);
        const crtSignedRequest = await this.signRequest(request, await this.options2crtConfigure(options, true, await getPayloadHash(toSign, this.sha256)));
        request.headers = crtSignedRequest.headers._flatten().reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
        return request;
      }
      async signWithCredentials(toSign, credentials, options) {
        const request = prepareRequest(toSign);
        const crtSignedRequest = await this.signRequest(request, await this.options2crtConfigure(options, true, await getPayloadHash(toSign, this.sha256), void 0, credentials));
        request.headers = crtSignedRequest.headers._flatten().reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
        return request;
      }
      getQueryParam(crtPath) {
        const start = crtPath.search(/\?/);
        const startHash = crtPath.search(/\#/);
        const end = startHash == -1 ? void 0 : startHash;
        const queryParam = {};
        if (start == -1) {
          return queryParam;
        }
        const queryString = crtPath.slice(start + 1, end);
        return parseQueryString(queryString);
      }
      async signRequest(requestToSign, crtConfig) {
        const request = sdkHttpRequest2crtHttpRequest(requestToSign);
        try {
          return await import_aws_crt.auth.aws_sign_request(request, crtConfig);
        } catch (error) {
          throw new Error(error);
        }
      }
      async verifySigv4aSigning(request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        const sdkRequest = prepareRequest(request);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const payloadHash = await getPayloadHash(request, this.sha256);
        const crtConfig = await this.options2crtConfigure(options, true, payloadHash);
        return import_aws_crt.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
      }
      async verifySigv4aPreSigning(request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        if (typeof signature != "string") {
          return false;
        }
        const sdkRequest = prepareRequest(request);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const crtConfig = await this.options2crtConfigure(options, false, await getPayloadHash(request, this.sha256), options.expiresIn ? options.expiresIn : 3600);
        return import_aws_crt.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
      }
    };
  }
});

// node_modules/@aws-sdk/signature-v4-crt/dist-es/index.js
var dist_es_exports2 = {};
__export(dist_es_exports2, {
  CrtSignerV4: () => CrtSignerV4
});
var init_dist_es26 = __esm({
  "node_modules/@aws-sdk/signature-v4-crt/dist-es/index.js"() {
    init_dist_es20();
    init_dist_es24();
    init_CrtSignerV4();
    init_CrtSignerV4();
    signatureV4CrtContainer.CrtSignerV4 = CrtSignerV4;
    crtAvailability.isCrtAvailable = true;
  }
});

// node_modules/@fast-crud/fast-extends/dist/uploader-s3-0c948529.mjs
var fn;
(function(e) {
  e.HEADER = "header", e.QUERY = "query";
})(fn || (fn = {}));
var wt;
(function(e) {
  e.HTTP = "http", e.HTTPS = "https";
})(wt || (wt = {}));
var hn;
(function(e) {
  e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER";
})(hn || (hn = {}));
var pn;
(function(e) {
  e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0";
})(pn || (pn = {}));
var ue = class _ue {
  constructor(t) {
    this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment;
  }
  static isInstance(t) {
    if (!t)
      return false;
    const r = t;
    return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object";
  }
  clone() {
    const t = new _ue({
      ...this,
      headers: { ...this.headers }
    });
    return t.query && (t.query = Yo(t.query)), t;
  }
};
function Yo(e) {
  return Object.keys(e).reduce((t, r) => {
    const n = e[r];
    return {
      ...t,
      [r]: Array.isArray(n) ? [...n] : n
    };
  }, {});
}
var Tt = class {
  constructor(t) {
    this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body;
  }
  static isInstance(t) {
    if (!t)
      return false;
    const r = t;
    return typeof r.statusCode == "number" && typeof r.headers == "object";
  }
};
function Qo(e) {
  return (t) => async (r) => {
    const { request: n } = r;
    return ue.isInstance(n) && n.body && e.runtime === "node" && (n.headers = {
      ...n.headers,
      Expect: "100-continue"
    }), t({
      ...r,
      request: n
    });
  };
}
var Jo = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var ea = (e) => ({
  applyToStack: (t) => {
    t.add(Qo(e), Jo);
  }
});
var ta = (e) => (t) => async (r) => {
  if (!ue.isInstance(r.request))
    return t(r);
  const { request: n } = r, { handlerProtocol: s = "" } = e.requestHandler.metadata || {};
  if (s.indexOf("h2") >= 0 && !n.headers[":authority"])
    delete n.headers.host, n.headers[":authority"] = "";
  else if (!n.headers.host) {
    let i = n.hostname;
    n.port != null && (i += `:${n.port}`), n.headers.host = i;
  }
  return t(r);
};
var ra = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var na = (e) => ({
  applyToStack: (t) => {
    t.add(ta(e), ra);
  }
});
var sa = () => (e, t) => async (r) => {
  var n, s;
  try {
    const i = await e(r), { clientName: o, commandName: a, logger: c2, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: d, overrideOutputFilterSensitiveLog: h } = u, p = d ?? t.inputFilterSensitiveLog, y = h ?? t.outputFilterSensitiveLog, { $metadata: g, ...A } = i.output;
    return (n = c2 == null ? void 0 : c2.info) == null || n.call(c2, {
      clientName: o,
      commandName: a,
      input: p(r.input),
      output: y(A),
      metadata: g
    }), i;
  } catch (i) {
    const { clientName: o, commandName: a, logger: c2, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: d } = u, h = d ?? t.inputFilterSensitiveLog;
    throw (s = c2 == null ? void 0 : c2.error) == null || s.call(c2, {
      clientName: o,
      commandName: a,
      input: h(r.input),
      error: i,
      metadata: i.$metadata
    }), i;
  }
};
var ia = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var oa = (e) => ({
  applyToStack: (t) => {
    t.add(sa(), ia);
  }
});
var gn = "X-Amzn-Trace-Id";
var aa = "AWS_LAMBDA_FUNCTION_NAME";
var ca = "_X_AMZN_TRACE_ID";
var ua = (e) => (t) => async (r) => {
  const { request: n } = r;
  if (!ue.isInstance(n) || e.runtime !== "node" || n.headers.hasOwnProperty(gn))
    return t(r);
  const s = process.env[aa], i = process.env[ca], o = (a) => typeof a == "string" && a.length > 0;
  return o(s) && o(i) && (n.headers[gn] = i), t({
    ...r,
    request: n
  });
};
var da = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var la = (e) => ({
  applyToStack: (t) => {
    t.add(ua(e), da);
  }
});
var fa = "content-length";
function ha() {
  return (e, t) => async (r) => {
    var s;
    const { request: n } = r;
    if (ue.isInstance(n) && !n.headers[fa]) {
      const i = "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
      typeof ((s = t == null ? void 0 : t.logger) == null ? void 0 : s.warn) == "function" && t.logger.warn(i);
    }
    return e({ ...r });
  };
}
var pa = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var ga = (e) => ({
  applyToStack: (t) => {
    t.add(ha(), pa);
  }
});
var ma = (e) => ({
  ...e,
  forcePathStyle: e.forcePathStyle ?? false,
  useAccelerateEndpoint: e.useAccelerateEndpoint ?? false,
  disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? false
});
var ya = (e) => typeof e == "string" && e.indexOf("arn:") === 0 && e.split(":").length >= 6;
function ba() {
  return (e) => async (t) => {
    const { input: { Bucket: r } } = t;
    if (typeof r == "string" && !ya(r) && r.indexOf("/") >= 0) {
      const n = new Error(`Bucket name shouldn't contain '/', received '${r}'`);
      throw n.name = "InvalidBucketName", n;
    }
    return e({ ...t });
  };
}
var wa = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var Aa = (e) => ({
  applyToStack: (t) => {
    t.add(ba(), wa);
  }
});
var xi = (e, t, r) => {
  let n, s, i, o = false;
  const a = async () => {
    s || (s = e());
    try {
      n = await s, i = true, o = false;
    } finally {
      s = void 0;
    }
    return n;
  };
  return t === void 0 ? async (c2) => ((!i || c2 != null && c2.forceRefresh) && (n = await a()), n) : async (c2) => ((!i || c2 != null && c2.forceRefresh) && (n = await a()), o ? n : r && !r(n) ? (o = true, n) : (t(n) && await a(), n));
};
var Ht = {};
var Pr = function(e, t) {
  return Pr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var s in n)
      n.hasOwnProperty(s) && (r[s] = n[s]);
  }, Pr(e, t);
};
function Ea(e, t) {
  Pr(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var Nr = function() {
  return Nr = Object.assign || function(t) {
    for (var r, n = 1, s = arguments.length; n < s; n++) {
      r = arguments[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }
    return t;
  }, Nr.apply(this, arguments);
};
function xa(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(e); s < n.length; s++)
      t.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[s]) && (r[n[s]] = e[n[s]]);
  return r;
}
function Sa(e, t, r, n) {
  var s = arguments.length, i = s < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(e, t, r, n);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (o = e[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(t, r, i) : o(t, r)) || i);
  return s > 3 && i && Object.defineProperty(t, r, i), i;
}
function va(e, t) {
  return function(r, n) {
    t(r, n, e);
  };
}
function Ca(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, t);
}
function Ra(e, t, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(d) {
      try {
        u(n.next(d));
      } catch (h) {
        o(h);
      }
    }
    function c2(d) {
      try {
        u(n.throw(d));
      } catch (h) {
        o(h);
      }
    }
    function u(d) {
      d.done ? i(d.value) : s(d.value).then(a, c2);
    }
    u((n = n.apply(e, t || [])).next());
  });
}
function Ba(e, t) {
  var r = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(d) {
      return c2([u, d]);
    };
  }
  function c2(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: false };
          case 5:
            r.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (i = r.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < i[1]) {
              r.label = i[1], i = u;
              break;
            }
            if (i && r.label < i[2]) {
              r.label = i[2], r.ops.push(u);
              break;
            }
            i[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = t.call(e, r);
      } catch (d) {
        u = [6, d], s = 0;
      } finally {
        n = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function _a(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}
function Ta(e, t) {
  for (var r in e)
    r !== "default" && !t.hasOwnProperty(r) && (t[r] = e[r]);
}
function Or(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0;
  if (r)
    return r.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Si(e, t) {
  var r = typeof Symbol == "function" && e[Symbol.iterator];
  if (!r)
    return e;
  var n = r.call(e), s, i = [], o;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = n.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (r = n.return) && r.call(n);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function ka() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(Si(arguments[t]));
  return e;
}
function Pa() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++)
    e += arguments[t].length;
  for (var n = Array(e), s = 0, t = 0; t < r; t++)
    for (var i = arguments[t], o = 0, a = i.length; o < a; o++, s++)
      n[s] = i[o];
  return n;
}
function At(e) {
  return this instanceof At ? (this.v = e, this) : new At(e);
}
function Na(e, t, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(e, t || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(p) {
    n[p] && (s[p] = function(y) {
      return new Promise(function(g, A) {
        i.push([p, y, g, A]) > 1 || a(p, y);
      });
    });
  }
  function a(p, y) {
    try {
      c2(n[p](y));
    } catch (g) {
      h(i[0][3], g);
    }
  }
  function c2(p) {
    p.value instanceof At ? Promise.resolve(p.value.v).then(u, d) : h(i[0][2], p);
  }
  function u(p) {
    a("next", p);
  }
  function d(p) {
    a("throw", p);
  }
  function h(p, y) {
    p(y), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Oa(e) {
  var t, r;
  return t = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function n(s, i) {
    t[s] = e[s] ? function(o) {
      return (r = !r) ? { value: At(e[s](o)), done: s === "return" } : i ? i(o) : o;
    } : i;
  }
}
function Ma(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], r;
  return t ? t.call(e) : (e = typeof Or == "function" ? Or(e) : e[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = e[i] && function(o) {
      return new Promise(function(a, c2) {
        o = e[i](o), s(a, c2, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c2) {
    Promise.resolve(c2).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function Fa(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
function Ia(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
  return t.default = e, t;
}
function Da(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ua(e, t) {
  if (!t.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(e);
}
function La(e, t, r) {
  if (!t.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, r), r;
}
var $a = Object.freeze(Object.defineProperty({
  __proto__: null,
  get __assign() {
    return Nr;
  },
  __asyncDelegator: Oa,
  __asyncGenerator: Na,
  __asyncValues: Ma,
  __await: At,
  __awaiter: Ra,
  __classPrivateFieldGet: Ua,
  __classPrivateFieldSet: La,
  __createBinding: _a,
  __decorate: Sa,
  __exportStar: Ta,
  __extends: Ea,
  __generator: Ba,
  __importDefault: Da,
  __importStar: Ia,
  __makeTemplateObject: Fa,
  __metadata: Ca,
  __param: va,
  __read: Si,
  __rest: xa,
  __spread: ka,
  __spreadArrays: Pa,
  __values: Or
}, Symbol.toStringTag, { value: "Module" }));
var ye = c($a);
var jt = {};
var We = {};
var Ha = (e) => {
  const t = [];
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e.charCodeAt(r);
    if (s < 128)
      t.push(s);
    else if (s < 2048)
      t.push(s >> 6 | 192, s & 63 | 128);
    else if (r + 1 < e.length && (s & 64512) === 55296 && (e.charCodeAt(r + 1) & 64512) === 56320) {
      const i = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++r) & 1023);
      t.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, i & 63 | 128);
    } else
      t.push(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128);
  }
  return Uint8Array.from(t);
};
var ja = (e) => {
  let t = "";
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e[r];
    if (s < 128)
      t += String.fromCharCode(s);
    else if (192 <= s && s < 224) {
      const i = e[++r];
      t += String.fromCharCode((s & 31) << 6 | i & 63);
    } else if (240 <= s && s < 365) {
      const o = "%" + [s, e[++r], e[++r], e[++r]].map((a) => a.toString(16)).join("%");
      t += decodeURIComponent(o);
    } else
      t += String.fromCharCode((s & 15) << 12 | (e[++r] & 63) << 6 | e[++r] & 63);
  }
  return t;
};
function qa(e) {
  return new TextEncoder().encode(e);
}
function za(e) {
  return new TextDecoder("utf-8").decode(e);
}
var Va = (e) => typeof TextEncoder == "function" ? qa(e) : Ha(e);
var Ga = (e) => typeof TextDecoder == "function" ? za(e) : ja(e);
var Wa = Object.freeze(Object.defineProperty({
  __proto__: null,
  fromUtf8: Va,
  toUtf8: Ga
}, Symbol.toStringTag, { value: "Module" }));
var Ft = c(Wa);
var mn;
function Ka() {
  if (mn)
    return We;
  mn = 1, Object.defineProperty(We, "__esModule", { value: true }), We.convertToBuffer = void 0;
  var e = Ft, t = typeof Buffer < "u" && Buffer.from ? function(n) {
    return Buffer.from(n, "utf8");
  } : e.fromUtf8;
  function r(n) {
    return n instanceof Uint8Array ? n : typeof n == "string" ? t(n) : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(n);
  }
  return We.convertToBuffer = r, We;
}
var Ke = {};
var yn;
function Xa() {
  if (yn)
    return Ke;
  yn = 1, Object.defineProperty(Ke, "__esModule", { value: true }), Ke.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return Ke.isEmptyData = e, Ke;
}
var Xe = {};
var bn;
function Za() {
  if (bn)
    return Xe;
  bn = 1, Object.defineProperty(Xe, "__esModule", { value: true }), Xe.numToUint8 = void 0;
  function e(t) {
    return new Uint8Array([
      (t & 4278190080) >> 24,
      (t & 16711680) >> 16,
      (t & 65280) >> 8,
      t & 255
    ]);
  }
  return Xe.numToUint8 = e, Xe;
}
var Ze = {};
var wn;
function Ya() {
  if (wn)
    return Ze;
  wn = 1, Object.defineProperty(Ze, "__esModule", { value: true }), Ze.uint32ArrayFrom = void 0;
  function e(t) {
    if (!Uint32Array.from) {
      for (var r = new Uint32Array(t.length), n = 0; n < t.length; )
        r[n] = t[n], n += 1;
      return r;
    }
    return Uint32Array.from(t);
  }
  return Ze.uint32ArrayFrom = e, Ze;
}
var An;
function Pe() {
  return An || (An = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.uint32ArrayFrom = e.numToUint8 = e.isEmptyData = e.convertToBuffer = void 0;
    var t = Ka();
    Object.defineProperty(e, "convertToBuffer", { enumerable: true, get: function() {
      return t.convertToBuffer;
    } });
    var r = Xa();
    Object.defineProperty(e, "isEmptyData", { enumerable: true, get: function() {
      return r.isEmptyData;
    } });
    var n = Za();
    Object.defineProperty(e, "numToUint8", { enumerable: true, get: function() {
      return n.numToUint8;
    } });
    var s = Ya();
    Object.defineProperty(e, "uint32ArrayFrom", { enumerable: true, get: function() {
      return s.uint32ArrayFrom;
    } });
  }(jt)), jt;
}
var Ye = {};
var En;
function Qa() {
  if (En)
    return Ye;
  En = 1, Object.defineProperty(Ye, "__esModule", { value: true }), Ye.AwsCrc32 = void 0;
  var e = ye, t = Pe(), r = vi(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32 = new r.Crc32();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32 = new r.Crc32();
      }, s;
    }()
  );
  return Ye.AwsCrc32 = n, Ye;
}
var xn;
function vi() {
  return xn || (xn = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.AwsCrc32 = e.Crc32 = e.crc32 = void 0;
    var t = ye, r = Pe();
    function n(c2) {
      return new s().update(c2).digest();
    }
    e.crc32 = n;
    var s = (
      /** @class */
      function() {
        function c2() {
          this.checksum = 4294967295;
        }
        return c2.prototype.update = function(u) {
          var d, h;
          try {
            for (var p = t.__values(u), y = p.next(); !y.done; y = p.next()) {
              var g = y.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ g) & 255];
            }
          } catch (A) {
            d = { error: A };
          } finally {
            try {
              y && !y.done && (h = p.return) && h.call(p);
            } finally {
              if (d)
                throw d.error;
            }
          }
          return this;
        }, c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c2;
      }()
    );
    e.Crc32 = s;
    var i = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ], o = (0, r.uint32ArrayFrom)(i), a = Qa();
    Object.defineProperty(e, "AwsCrc32", { enumerable: true, get: function() {
      return a.AwsCrc32;
    } });
  }(Ht)), Ht;
}
var Gr = vi();
var Ci = {};
var Mr = {};
for (let e = 0; e < 256; e++) {
  let t = e.toString(16).toLowerCase();
  t.length === 1 && (t = `0${t}`), Ci[e] = t, Mr[t] = e;
}
function Ja(e) {
  if (e.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) {
    const n = e.slice(r, r + 2).toLowerCase();
    if (n in Mr)
      t[r / 2] = Mr[n];
    else
      throw new Error(`Cannot decode unrecognized sequence ${n} as hexadecimal`);
  }
  return t;
}
function ce(e) {
  let t = "";
  for (let r = 0; r < e.byteLength; r++)
    t += Ci[e[r]];
  return t;
}
var mt = class _mt {
  constructor(t) {
    if (this.bytes = t, t.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(t) {
    if (t > 9223372036854776e3 || t < -9223372036854776e3)
      throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);
    const r = new Uint8Array(8);
    for (let n = 7, s = Math.abs(Math.round(t)); n > -1 && s > 0; n--, s /= 256)
      r[n] = s;
    return t < 0 && Sn(r), new _mt(r);
  }
  valueOf() {
    const t = this.bytes.slice(0), r = t[0] & 128;
    return r && Sn(t), parseInt(ce(t), 16) * (r ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function Sn(e) {
  for (let t = 0; t < 8; t++)
    e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--)
    ;
}
var Ri = class {
  constructor(t, r) {
    this.toUtf8 = t, this.fromUtf8 = r;
  }
  format(t) {
    const r = [];
    for (const i of Object.keys(t)) {
      const o = this.fromUtf8(i);
      r.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(t[i]));
    }
    const n = new Uint8Array(r.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of r)
      n.set(i, s), s += i.byteLength;
    return n;
  }
  formatHeaderValue(t) {
    switch (t.type) {
      case "boolean":
        return Uint8Array.from([t.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, t.value]);
      case "short":
        const r = new DataView(new ArrayBuffer(3));
        return r.setUint8(0, 3), r.setInt16(1, t.value, false), new Uint8Array(r.buffer);
      case "integer":
        const n = new DataView(new ArrayBuffer(5));
        return n.setUint8(0, 4), n.setInt32(1, t.value, false), new Uint8Array(n.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(t.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, false);
        const o = new Uint8Array(i.buffer);
        return o.set(t.value, 3), o;
      case "string":
        const a = this.fromUtf8(t.value), c2 = new DataView(new ArrayBuffer(3 + a.byteLength));
        c2.setUint8(0, 7), c2.setUint16(1, a.byteLength, false);
        const u = new Uint8Array(c2.buffer);
        return u.set(a, 3), u;
      case "timestamp":
        const d = new Uint8Array(9);
        return d[0] = 8, d.set(mt.fromNumber(t.value.valueOf()).bytes, 1), d;
      case "uuid":
        if (!cc.test(t.value))
          throw new Error(`Invalid UUID received: ${t.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(Ja(t.value.replace(/\-/g, "")), 1), h;
    }
  }
  parse(t) {
    const r = {};
    let n = 0;
    for (; n < t.byteLength; ) {
      const s = t.getUint8(n++), i = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, s));
      switch (n += s, t.getUint8(n++)) {
        case 0:
          r[i] = {
            type: Cn,
            value: true
          };
          break;
        case 1:
          r[i] = {
            type: Cn,
            value: false
          };
          break;
        case 2:
          r[i] = {
            type: ec,
            value: t.getInt8(n++)
          };
          break;
        case 3:
          r[i] = {
            type: tc,
            value: t.getInt16(n, false)
          }, n += 2;
          break;
        case 4:
          r[i] = {
            type: rc,
            value: t.getInt32(n, false)
          }, n += 4;
          break;
        case 5:
          r[i] = {
            type: nc,
            value: new mt(new Uint8Array(t.buffer, t.byteOffset + n, 8))
          }, n += 8;
          break;
        case 6:
          const o = t.getUint16(n, false);
          n += 2, r[i] = {
            type: sc,
            value: new Uint8Array(t.buffer, t.byteOffset + n, o)
          }, n += o;
          break;
        case 7:
          const a = t.getUint16(n, false);
          n += 2, r[i] = {
            type: ic,
            value: this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, a))
          }, n += a;
          break;
        case 8:
          r[i] = {
            type: oc,
            value: new Date(new mt(new Uint8Array(t.buffer, t.byteOffset + n, 8)).valueOf())
          }, n += 8;
          break;
        case 9:
          const c2 = new Uint8Array(t.buffer, t.byteOffset + n, 16);
          n += 16, r[i] = {
            type: ac,
            value: `${ce(c2.subarray(0, 4))}-${ce(c2.subarray(4, 6))}-${ce(c2.subarray(6, 8))}-${ce(c2.subarray(8, 10))}-${ce(c2.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return r;
  }
};
var vn;
(function(e) {
  e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid";
})(vn || (vn = {}));
var Cn = "boolean";
var ec = "byte";
var tc = "short";
var rc = "integer";
var nc = "long";
var sc = "binary";
var ic = "string";
var oc = "timestamp";
var ac = "uuid";
var cc = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
var Bi = 4;
var Be = Bi * 2;
var Me = 4;
var uc = Be + Me * 2;
function dc({ byteLength: e, byteOffset: t, buffer: r }) {
  if (e < uc)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const n = new DataView(r, t, e), s = n.getUint32(0, false);
  if (e !== s)
    throw new Error("Reported message length does not match received message length");
  const i = n.getUint32(Bi, false), o = n.getUint32(Be, false), a = n.getUint32(e - Me, false), c2 = new Gr.Crc32().update(new Uint8Array(r, t, Be));
  if (o !== c2.digest())
    throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${c2.digest()})`);
  if (c2.update(new Uint8Array(r, t + Be, e - (Be + Me))), a !== c2.digest())
    throw new Error(`The message checksum (${c2.digest()}) did not match the expected value of ${a}`);
  return {
    headers: new DataView(r, t + Be + Me, i),
    body: new Uint8Array(r, t + Be + Me + i, s - i - (Be + Me + Me))
  };
}
var lc = class {
  constructor(t, r) {
    this.headerMarshaller = new Ri(t, r), this.messageBuffer = [], this.isEndOfStream = false;
  }
  feed(t) {
    this.messageBuffer.push(this.decode(t));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const t = this.messageBuffer.pop(), r = this.isEndOfStream;
    return {
      getMessage() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  getAvailableMessages() {
    const t = this.messageBuffer;
    this.messageBuffer = [];
    const r = this.isEndOfStream;
    return {
      getMessages() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  encode({ headers: t, body: r }) {
    const n = this.headerMarshaller.format(t), s = n.byteLength + r.byteLength + 16, i = new Uint8Array(s), o = new DataView(i.buffer, i.byteOffset, i.byteLength), a = new Gr.Crc32();
    return o.setUint32(0, s, false), o.setUint32(4, n.byteLength, false), o.setUint32(8, a.update(i.subarray(0, 8)).digest(), false), i.set(n, 12), i.set(r, n.byteLength + 12), o.setUint32(s - 4, a.update(i.subarray(8, s - 4)).digest(), false), i;
  }
  decode(t) {
    const { headers: r, body: n } = dc(t);
    return { headers: this.headerMarshaller.parse(r), body: n };
  }
  formatHeaders(t) {
    return this.headerMarshaller.format(t);
  }
};
var fc = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.decoder.decode(t);
  }
};
var hc = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream)
      yield this.options.encoder.encode(t);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
};
var pc = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream) {
      const r = await this.options.deserializer(t);
      r !== void 0 && (yield r);
    }
  }
};
var gc = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.serializer(t);
  }
};
var me = (e) => {
  if (typeof e == "function")
    return e;
  const t = Promise.resolve(e);
  return () => t;
};
var xt = (e) => new TextEncoder().encode(e);
var He = (e) => typeof e == "string" ? xt(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e);
var It = (e) => new TextDecoder("utf-8").decode(e);
var mc = "X-Amz-Algorithm";
var yc = "X-Amz-Credential";
var _i = "X-Amz-Date";
var bc = "X-Amz-SignedHeaders";
var wc = "X-Amz-Expires";
var Ti = "X-Amz-Signature";
var ki = "X-Amz-Security-Token";
var Pi = "authorization";
var Ni = _i.toLowerCase();
var Ac = "date";
var Ec = [Pi, Ni, Ac];
var xc = Ti.toLowerCase();
var Fr = "x-amz-content-sha256";
var Sc = ki.toLowerCase();
var vc = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var Cc = /^proxy-/;
var Rc = /^sec-/;
var qt = "AWS4-HMAC-SHA256";
var Bc = "AWS4-HMAC-SHA256-PAYLOAD";
var _c = "UNSIGNED-PAYLOAD";
var Tc = 50;
var Oi = "aws4_request";
var kc = 60 * 60 * 24 * 7;
var St = {};
var zt = [];
var Vt = (e, t, r) => `${e}/${t}/${r}/${Oi}`;
var Pc = async (e, t, r, n, s) => {
  const i = await Rn(e, t.secretAccessKey, t.accessKeyId), o = `${r}:${n}:${s}:${ce(i)}:${t.sessionToken}`;
  if (o in St)
    return St[o];
  for (zt.push(o); zt.length > Tc; )
    delete St[zt.shift()];
  let a = `AWS4${t.secretAccessKey}`;
  for (const c2 of [r, n, s, Oi])
    a = await Rn(e, a, c2);
  return St[o] = a;
};
var Rn = (e, t, r) => {
  const n = new e(t);
  return n.update(He(r)), n.digest();
};
var Bn = ({ headers: e }, t, r) => {
  const n = {};
  for (const s of Object.keys(e).sort()) {
    if (e[s] == null)
      continue;
    const i = s.toLowerCase();
    (i in vc || t != null && t.has(i) || Cc.test(i) || Rc.test(i)) && (!r || r && !r.has(i)) || (n[i] = e[s].trim().replace(/\s+/g, " "));
  }
  return n;
};
var Fe = (e) => encodeURIComponent(e).replace(/[!'()*]/g, Nc);
var Nc = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`;
var Oc = ({ query: e = {} }) => {
  const t = [], r = {};
  for (const n of Object.keys(e).sort()) {
    if (n.toLowerCase() === xc)
      continue;
    t.push(n);
    const s = e[n];
    typeof s == "string" ? r[n] = `${Fe(n)}=${Fe(s)}` : Array.isArray(s) && (r[n] = s.slice(0).sort().reduce((i, o) => i.concat([`${Fe(n)}=${Fe(o)}`]), []).join("&"));
  }
  return t.map((n) => r[n]).filter((n) => n).join("&");
};
var Mi = (e) => typeof ArrayBuffer == "function" && e instanceof ArrayBuffer || Object.prototype.toString.call(e) === "[object ArrayBuffer]";
var Gt = async ({ headers: e, body: t }, r) => {
  for (const n of Object.keys(e))
    if (n.toLowerCase() === Fr)
      return e[n];
  if (t == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof t == "string" || ArrayBuffer.isView(t) || Mi(t)) {
    const n = new r();
    return n.update(He(t)), ce(await n.digest());
  }
  return _c;
};
var Mc = (e, t) => {
  e = e.toLowerCase();
  for (const r of Object.keys(t))
    if (e === r.toLowerCase())
      return true;
  return false;
};
var Fi = ({ headers: e, query: t, ...r }) => ({
  ...r,
  headers: { ...e },
  query: t ? Fc(t) : void 0
});
var Fc = (e) => Object.keys(e).reduce((t, r) => {
  const n = e[r];
  return {
    ...t,
    [r]: Array.isArray(n) ? [...n] : n
  };
}, {});
var Ic = (e, t = {}) => {
  var s;
  const { headers: r, query: n = {} } = typeof e.clone == "function" ? e.clone() : Fi(e);
  for (const i of Object.keys(r)) {
    const o = i.toLowerCase();
    o.slice(0, 6) === "x-amz-" && !((s = t.unhoistableHeaders) != null && s.has(o)) && (n[i] = r[i], delete r[i]);
  }
  return {
    ...e,
    headers: r,
    query: n
  };
};
var _n = (e) => {
  e = typeof e.clone == "function" ? e.clone() : Fi(e);
  for (const t of Object.keys(e.headers))
    Ec.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
  return e;
};
var Dc = (e) => Uc(e).toISOString().replace(/\.\d{3}Z$/, "Z");
var Uc = (e) => typeof e == "number" ? new Date(e * 1e3) : typeof e == "string" ? Number(e) ? new Date(Number(e) * 1e3) : new Date(e) : e;
var Ir = class {
  constructor({ applyChecksum: t, credentials: r, region: n, service: s, sha256: i, uriEscapePath: o = true }) {
    this.headerMarshaller = new Ri(It, xt), this.service = s, this.sha256 = i, this.uriEscapePath = o, this.applyChecksum = typeof t == "boolean" ? t : true, this.regionProvider = me(n), this.credentialProvider = me(r);
  }
  async presign(t, r = {}) {
    const { signingDate: n = /* @__PURE__ */ new Date(), expiresIn: s = 3600, unsignableHeaders: i, unhoistableHeaders: o, signableHeaders: a, signingRegion: c2, signingService: u } = r, d = await this.credentialProvider();
    this.validateResolvedCredentials(d);
    const h = c2 ?? await this.regionProvider(), { longDate: p, shortDate: y } = vt(n);
    if (s > kc)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const g = Vt(y, h, u ?? this.service), A = Ic(_n(t), { unhoistableHeaders: o });
    d.sessionToken && (A.query[ki] = d.sessionToken), A.query[mc] = qt, A.query[yc] = `${d.accessKeyId}/${g}`, A.query[_i] = p, A.query[wc] = s.toString(10);
    const B = Bn(A, i, a);
    return A.query[bc] = Tn(B), A.query[Ti] = await this.getSignature(p, g, this.getSigningKey(d, h, y, u), this.createCanonicalRequest(A, B, await Gt(t, this.sha256))), A;
  }
  async sign(t, r) {
    return typeof t == "string" ? this.signString(t, r) : t.headers && t.payload ? this.signEvent(t, r) : t.message ? this.signMessage(t, r) : this.signRequest(t, r);
  }
  async signEvent({ headers: t, payload: r }, { signingDate: n = /* @__PURE__ */ new Date(), priorSignature: s, signingRegion: i, signingService: o }) {
    const a = i ?? await this.regionProvider(), { shortDate: c2, longDate: u } = vt(n), d = Vt(c2, a, o ?? this.service), h = await Gt({ headers: {}, body: r }, this.sha256), p = new this.sha256();
    p.update(t);
    const y = ce(await p.digest()), g = [
      Bc,
      u,
      d,
      s,
      y,
      h
    ].join(`
`);
    return this.signString(g, { signingDate: n, signingRegion: a, signingService: o });
  }
  async signMessage(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s }) {
    return this.signEvent({
      headers: this.headerMarshaller.format(t.message.headers),
      payload: t.message.body
    }, {
      signingDate: r,
      signingRegion: n,
      signingService: s,
      priorSignature: t.priorSignature
    }).then((o) => ({ message: t.message, signature: o }));
  }
  async signString(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s } = {}) {
    const i = await this.credentialProvider();
    this.validateResolvedCredentials(i);
    const o = n ?? await this.regionProvider(), { shortDate: a } = vt(r), c2 = new this.sha256(await this.getSigningKey(i, o, a, s));
    return c2.update(He(t)), ce(await c2.digest());
  }
  async signRequest(t, { signingDate: r = /* @__PURE__ */ new Date(), signableHeaders: n, unsignableHeaders: s, signingRegion: i, signingService: o } = {}) {
    const a = await this.credentialProvider();
    this.validateResolvedCredentials(a);
    const c2 = i ?? await this.regionProvider(), u = _n(t), { longDate: d, shortDate: h } = vt(r), p = Vt(h, c2, o ?? this.service);
    u.headers[Ni] = d, a.sessionToken && (u.headers[Sc] = a.sessionToken);
    const y = await Gt(u, this.sha256);
    !Mc(Fr, u.headers) && this.applyChecksum && (u.headers[Fr] = y);
    const g = Bn(u, s, n), A = await this.getSignature(d, p, this.getSigningKey(a, c2, h, o), this.createCanonicalRequest(u, g, y));
    return u.headers[Pi] = `${qt} Credential=${a.accessKeyId}/${p}, SignedHeaders=${Tn(g)}, Signature=${A}`, u;
  }
  createCanonicalRequest(t, r, n) {
    const s = Object.keys(r).sort();
    return `${t.method}
${this.getCanonicalPath(t)}
${Oc(t)}
${s.map((i) => `${i}:${r[i]}`).join(`
`)}

${s.join(";")}
${n}`;
  }
  async createStringToSign(t, r, n) {
    const s = new this.sha256();
    s.update(He(n));
    const i = await s.digest();
    return `${qt}
${t}
${r}
${ce(i)}`;
  }
  getCanonicalPath({ path: t }) {
    if (this.uriEscapePath) {
      const r = [];
      for (const i of t.split("/"))
        (i == null ? void 0 : i.length) !== 0 && i !== "." && (i === ".." ? r.pop() : r.push(i));
      const n = `${t != null && t.startsWith("/") ? "/" : ""}${r.join("/")}${r.length > 0 && (t != null && t.endsWith("/")) ? "/" : ""}`;
      return encodeURIComponent(n).replace(/%2F/g, "/");
    }
    return t;
  }
  async getSignature(t, r, n, s) {
    const i = await this.createStringToSign(t, r, s), o = new this.sha256(await n);
    return o.update(He(i)), ce(await o.digest());
  }
  getSigningKey(t, r, n, s) {
    return Pc(this.sha256, t, n, r, s || this.service);
  }
  validateResolvedCredentials(t) {
    if (typeof t != "object" || typeof t.accessKeyId != "string" || typeof t.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
};
var vt = (e) => {
  const t = Dc(e).replace(/[\-:]/g, "");
  return {
    longDate: t,
    shortDate: t.slice(0, 8)
  };
};
var Tn = (e) => Object.keys(e).sort().join(";");
var Lc = 3e5;
var $c = (e) => {
  const t = e.credentials ? Hc(e.credentials) : e.credentialDefaultProvider(e), { signingEscapePath: r = true, systemClockOffset: n = e.systemClockOffset || 0, sha256: s } = e;
  let i;
  return e.signer ? i = me(e.signer) : e.regionInfoProvider ? i = () => me(e.region)().then(async (o) => [
    await e.regionInfoProvider(o, {
      useFipsEndpoint: await e.useFipsEndpoint(),
      useDualstackEndpoint: await e.useDualstackEndpoint()
    }) || {},
    o
  ]).then(([o, a]) => {
    const { signingRegion: c2, signingService: u } = o;
    e.signingRegion = e.signingRegion || c2 || a, e.signingName = e.signingName || u || e.serviceId;
    const d = {
      ...e,
      credentials: t,
      region: e.signingRegion,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, h = e.signerConstructor || Ir;
    return new h(d);
  }) : i = async (o) => {
    o = Object.assign({}, {
      name: "sigv4",
      signingName: e.signingName || e.defaultSigningName,
      signingRegion: await me(e.region)(),
      properties: {}
    }, o);
    const a = o.signingRegion, c2 = o.signingName;
    e.signingRegion = e.signingRegion || a, e.signingName = e.signingName || c2 || e.serviceId;
    const u = {
      ...e,
      credentials: t,
      region: e.signingRegion,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, d = e.signerConstructor || Ir;
    return new d(u);
  }, {
    ...e,
    systemClockOffset: n,
    signingEscapePath: r,
    credentials: t,
    signer: i
  };
};
var Hc = (e) => typeof e == "function" ? xi(e, (t) => t.expiration !== void 0 && t.expiration.getTime() - Date.now() < Lc, (t) => t.expiration !== void 0) : me(e);
var Ii = (e) => new Date(Date.now() + e);
var jc = (e, t) => Math.abs(Ii(t).getTime() - e) >= 3e5;
var kn = (e, t) => {
  const r = Date.parse(e);
  return jc(r, t) ? r - Date.now() : t;
};
var qc = (e) => (t, r) => async function(n) {
  var u, d, h, p;
  if (!ue.isInstance(n.request))
    return t(n);
  const s = (h = (d = (u = r.endpointV2) == null ? void 0 : u.properties) == null ? void 0 : d.authSchemes) == null ? void 0 : h[0], i = (s == null ? void 0 : s.name) === "sigv4a" ? (p = s == null ? void 0 : s.signingRegionSet) == null ? void 0 : p.join(",") : void 0, o = await e.signer(s), a = await t({
    ...n,
    request: await o.sign(n.request, {
      signingDate: Ii(e.systemClockOffset),
      signingRegion: i || r.signing_region,
      signingService: r.signing_service
    })
  }).catch((y) => {
    const g = y.ServerTime ?? Pn(y.$response);
    throw g && (e.systemClockOffset = kn(g, e.systemClockOffset)), y;
  }), c2 = Pn(a.response);
  return c2 && (e.systemClockOffset = kn(c2, e.systemClockOffset)), a;
};
var Pn = (e) => {
  var t, r;
  return Tt.isInstance(e) ? ((t = e.headers) == null ? void 0 : t.date) ?? ((r = e.headers) == null ? void 0 : r.Date) : void 0;
};
var zc = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var Vc = (e) => ({
  applyToStack: (t) => {
    t.addRelativeTo(qc(e), zc);
  }
});
function Gc(e) {
  return {
    ...e,
    customUserAgent: typeof e.customUserAgent == "string" ? [[e.customUserAgent]] : e.customUserAgent
  };
}
var Wc = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
];
var Kc = "1.1";
var Di = {
  partitions: Wc,
  version: Kc
};
var Ui = Di;
var Li = "";
var Xc = (e) => {
  const { partitions: t } = Ui;
  for (const n of t) {
    const { regions: s, outputs: i } = n;
    for (const [o, a] of Object.entries(s))
      if (o === e)
        return {
          ...i,
          ...a
        };
  }
  for (const n of t) {
    const { regionRegex: s, outputs: i } = n;
    if (new RegExp(s).test(e))
      return {
        ...i
      };
  }
  const r = t.find((n) => n.id === "aws");
  if (!r)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...r.outputs
  };
};
var $i = (e, t = "") => {
  Ui = e, Li = t;
};
var Zc = () => {
  $i(Di, "");
};
var Hi = () => Li;
var Yc = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$");
var ji = (e) => Yc.test(e) || e.startsWith("[") && e.endsWith("]");
var Et = "endpoints";
function Te(e) {
  return typeof e != "object" || e == null ? e : "ref" in e ? `$${Te(e.ref)}` : "fn" in e ? `${e.fn}(${(e.argv || []).map(Te).join(", ")})` : JSON.stringify(e, null, 2);
}
var de = class extends Error {
  constructor(t) {
    super(t), this.name = "EndpointError";
  }
};
var Qc = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$");
var Wr = (e, t = false) => {
  if (!t)
    return Qc.test(e);
  const r = e.split(".");
  for (const n of r)
    if (!Wr(n))
      return false;
  return true;
};
var qi = (e, t = false) => {
  if (t) {
    for (const r of e.split("."))
      if (!qi(r))
        return false;
    return true;
  }
  return !(!Wr(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || ji(e));
};
var Jc = (e) => {
  const t = e.split(":");
  if (t.length < 6)
    return null;
  const [r, n, s, i, o, ...a] = t;
  return r !== "arn" || n === "" || s === "" || a[0] === "" ? null : {
    partition: n,
    service: s,
    region: i,
    accountId: o,
    resourceId: a[0].includes("/") ? a[0].split("/") : a
  };
};
var eu = Object.freeze(Object.defineProperty({
  __proto__: null,
  getUserAgentPrefix: Hi,
  isVirtualHostableS3Bucket: qi,
  parseArn: Jc,
  partition: Xc,
  setPartitionInfo: $i,
  useDefaultPartitionInfo: Zc
}, Symbol.toStringTag, { value: "Module" }));
var tu = (e, t) => e === t;
var ru = (e) => {
  const t = e.split("."), r = [];
  for (const n of t) {
    const s = n.indexOf("[");
    if (s !== -1) {
      if (n.indexOf("]") !== n.length - 1)
        throw new de(`Path: '${e}' does not end with ']'`);
      const i = n.slice(s + 1, -1);
      if (Number.isNaN(parseInt(i)))
        throw new de(`Invalid array index: '${i}' in path: '${e}'`);
      s !== 0 && r.push(n.slice(0, s)), r.push(i);
    } else
      r.push(n);
  }
  return r;
};
var zi = (e, t) => ru(t).reduce((r, n) => {
  if (typeof r != "object")
    throw new de(`Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`);
  return Array.isArray(r) ? r[parseInt(n)] : r[n];
}, e);
var nu = (e) => e != null;
var su = (e) => !e;
var Nn;
(function(e) {
  e.AAAA = "AAAA", e.A = "A";
})(Nn || (Nn = {}));
var Wt = {
  [wt.HTTP]: 80,
  [wt.HTTPS]: 443
};
var iu = (e) => {
  const t = (() => {
    try {
      if (e instanceof URL)
        return e;
      if (typeof e == "object" && "hostname" in e) {
        const { hostname: p, port: y, protocol: g = "", path: A = "", query: B = {} } = e, fe = new URL(`${g}//${p}${y ? `:${y}` : ""}${A}`);
        return fe.search = Object.entries(B).map(([se, Le]) => `${se}=${Le}`).join("&"), fe;
      }
      return new URL(e);
    } catch {
      return null;
    }
  })();
  if (!t)
    return null;
  const r = t.href, { host: n, hostname: s, pathname: i, protocol: o, search: a } = t;
  if (a)
    return null;
  const c2 = o.slice(0, -1);
  if (!Object.values(wt).includes(c2))
    return null;
  const u = ji(s), d = r.includes(`${n}:${Wt[c2]}`) || typeof e == "string" && e.includes(`${n}:${Wt[c2]}`), h = `${n}${d ? `:${Wt[c2]}` : ""}`;
  return {
    scheme: c2,
    authority: h,
    path: i,
    normalizedPath: i.endsWith("/") ? i : `${i}/`,
    isIp: u
  };
};
var ou = (e, t) => e === t;
var au = (e, t, r, n) => t >= r || e.length < r ? null : n ? e.substring(e.length - r, e.length - t) : e.substring(t, r);
var cu = (e) => encodeURIComponent(e).replace(/[!*'()]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`);
var uu = Object.freeze(Object.defineProperty({
  __proto__: null,
  aws: eu,
  booleanEquals: tu,
  getAttr: zi,
  isSet: nu,
  isValidHostLabel: Wr,
  not: su,
  parseURL: iu,
  stringEquals: ou,
  substring: au,
  uriEncode: cu
}, Symbol.toStringTag, { value: "Module" }));
var Vi = (e, t) => {
  const r = [], n = {
    ...t.endpointParams,
    ...t.referenceRecord
  };
  let s = 0;
  for (; s < e.length; ) {
    const i = e.indexOf("{", s);
    if (i === -1) {
      r.push(e.slice(s));
      break;
    }
    r.push(e.slice(s, i));
    const o = e.indexOf("}", i);
    if (o === -1) {
      r.push(e.slice(i));
      break;
    }
    e[i + 1] === "{" && e[o + 1] === "}" && (r.push(e.slice(i + 1, o)), s = o + 2);
    const a = e.substring(i + 1, o);
    if (a.includes("#")) {
      const [c2, u] = a.split("#");
      r.push(zi(n[c2], u));
    } else
      r.push(n[a]);
    s = o + 1;
  }
  return r.join("");
};
var du = ({ ref: e }, t) => ({
  ...t.endpointParams,
  ...t.referenceRecord
})[e];
var Dt = (e, t, r) => {
  if (typeof e == "string")
    return Vi(e, r);
  if (e.fn)
    return Gi(e, r);
  if (e.ref)
    return du(e, r);
  throw new de(`'${t}': ${String(e)} is not a string, function or reference.`);
};
var Gi = ({ fn: e, argv: t }, r) => {
  const n = t.map((s) => ["boolean", "number"].includes(typeof s) ? s : Dt(s, "arg", r));
  return e.split(".").reduce((s, i) => s[i], uu)(...n);
};
var lu = ({ assign: e, ...t }, r) => {
  var s, i;
  if (e && e in r.referenceRecord)
    throw new de(`'${e}' is already defined in Reference Record.`);
  const n = Gi(t, r);
  return (i = (s = r.logger) == null ? void 0 : s.debug) == null || i.call(s, Et, `evaluateCondition: ${Te(t)} = ${Te(n)}`), {
    result: n === "" ? true : !!n,
    ...e != null && { toAssign: { name: e, value: n } }
  };
};
var Kr = (e = [], t) => {
  var n, s;
  const r = {};
  for (const i of e) {
    const { result: o, toAssign: a } = lu(i, {
      ...t,
      referenceRecord: {
        ...t.referenceRecord,
        ...r
      }
    });
    if (!o)
      return { result: o };
    a && (r[a.name] = a.value, (s = (n = t.logger) == null ? void 0 : n.debug) == null || s.call(n, Et, `assign: ${a.name} := ${Te(a.value)}`));
  }
  return { result: true, referenceRecord: r };
};
var fu = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: s.map((i) => {
    const o = Dt(i, "Header value entry", t);
    if (typeof o != "string")
      throw new de(`Header '${n}' value '${o}' is not a string`);
    return o;
  })
}), {});
var Wi = (e, t) => {
  if (Array.isArray(e))
    return e.map((r) => Wi(r, t));
  switch (typeof e) {
    case "string":
      return Vi(e, t);
    case "object":
      if (e === null)
        throw new de(`Unexpected endpoint property: ${e}`);
      return Ki(e, t);
    case "boolean":
      return e;
    default:
      throw new de(`Unexpected endpoint property type: ${typeof e}`);
  }
};
var Ki = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: Wi(s, t)
}), {});
var hu = (e, t) => {
  const r = Dt(e, "Endpoint URL", t);
  if (typeof r == "string")
    try {
      return new URL(r);
    } catch (n) {
      throw n;
    }
  throw new de(`Endpoint URL must be a string, got ${typeof r}`);
};
var pu = (e, t) => {
  var d, h;
  const { conditions: r, endpoint: n } = e, { result: s, referenceRecord: i } = Kr(r, t);
  if (!s)
    return;
  const o = {
    ...t,
    referenceRecord: { ...t.referenceRecord, ...i }
  }, { url: a, properties: c2, headers: u } = n;
  return (h = (d = t.logger) == null ? void 0 : d.debug) == null || h.call(d, Et, `Resolving endpoint from template: ${Te(n)}`), {
    ...u != null && {
      headers: fu(u, o)
    },
    ...c2 != null && {
      properties: Ki(c2, o)
    },
    url: hu(a, o)
  };
};
var gu = (e, t) => {
  const { conditions: r, error: n } = e, { result: s, referenceRecord: i } = Kr(r, t);
  if (s)
    throw new de(Dt(n, "Error", {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    }));
};
var mu = (e, t) => {
  const { conditions: r, rules: n } = e, { result: s, referenceRecord: i } = Kr(r, t);
  if (s)
    return Xi(n, {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    });
};
var Xi = (e, t) => {
  for (const r of e)
    if (r.type === "endpoint") {
      const n = pu(r, t);
      if (n)
        return n;
    } else if (r.type === "error")
      gu(r, t);
    else if (r.type === "tree") {
      const n = mu(r, t);
      if (n)
        return n;
    } else
      throw new de(`Unknown endpoint rule: ${r}`);
  throw new de("Rules evaluation failed");
};
var yu = (e, t) => {
  var u, d, h, p, y;
  const { endpointParams: r, logger: n } = t, { parameters: s, rules: i } = e;
  (d = (u = t.logger) == null ? void 0 : u.debug) == null || d.call(u, `${Et} Initial EndpointParams: ${Te(r)}`);
  const o = Object.entries(s).filter(([, g]) => g.default != null).map(([g, A]) => [g, A.default]);
  if (o.length > 0)
    for (const [g, A] of o)
      r[g] = r[g] ?? A;
  const a = Object.entries(s).filter(([, g]) => g.required).map(([g]) => g);
  for (const g of a)
    if (r[g] == null)
      throw new de(`Missing required parameter: '${g}'`);
  const c2 = Xi(i, { endpointParams: r, logger: n, referenceRecord: {} });
  if ((h = t.endpointParams) != null && h.Endpoint)
    try {
      const g = new URL(t.endpointParams.Endpoint), { protocol: A, port: B } = g;
      c2.url.protocol = A, c2.url.port = B;
    } catch {
    }
  return (y = (p = t.logger) == null ? void 0 : p.debug) == null || y.call(p, `${Et} Resolved endpoint: ${Te(c2)}`), c2;
};
var On = "user-agent";
var Kt = "x-amz-user-agent";
var Mn = " ";
var Xt = "/";
var bu = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var wu = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var Fn = "-";
var Au = (e) => (t, r) => async (n) => {
  var p, y;
  const { request: s } = n;
  if (!ue.isInstance(s))
    return t(n);
  const { headers: i } = s, o = ((p = r == null ? void 0 : r.userAgent) == null ? void 0 : p.map(Zt)) || [], a = (await e.defaultUserAgentProvider()).map(Zt), c2 = ((y = e == null ? void 0 : e.customUserAgent) == null ? void 0 : y.map(Zt)) || [], u = Hi(), d = (u ? [u] : []).concat([...a, ...o, ...c2]).join(Mn), h = [
    ...a.filter((g) => g.startsWith("aws-sdk-")),
    ...c2
  ].join(Mn);
  return e.runtime !== "browser" ? (h && (i[Kt] = i[Kt] ? `${i[On]} ${h}` : h), i[On] = d) : i[Kt] = d, t({
    ...n,
    request: s
  });
};
var Zt = (e) => {
  var o;
  const t = e[0].split(Xt).map((a) => a.replace(bu, Fn)).join(Xt), r = (o = e[1]) == null ? void 0 : o.replace(wu, Fn), n = t.indexOf(Xt), s = t.substring(0, n);
  let i = t.substring(n + 1);
  return s === "api" && (i = i.toLowerCase()), [s, i, r].filter((a) => a && a.length > 0).reduce((a, c2, u) => {
    switch (u) {
      case 0:
        return c2;
      case 1:
        return `${a}/${c2}`;
      default:
        return `${a}#${c2}`;
    }
  }, "");
};
var Eu = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var xu = (e) => ({
  applyToStack: (t) => {
    t.add(Au(e), Eu);
  }
});
var In;
(function(e) {
  e.ENV = "env", e.CONFIG = "shared config entry";
})(In || (In = {}));
var Su = false;
var vu = false;
var Zi = (e) => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
var Dn = (e) => Zi(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e;
var Cu = (e) => {
  const { region: t, useFipsEndpoint: r } = e;
  if (!t)
    throw new Error("Region is missing");
  return {
    ...e,
    region: async () => {
      if (typeof t == "string")
        return Dn(t);
      const n = await t();
      return Dn(n);
    },
    useFipsEndpoint: async () => {
      const n = typeof t == "string" ? t : await t();
      return Zi(n) ? true : typeof r != "function" ? Promise.resolve(!!r) : r();
    }
  };
};
var Ru = (e) => ({
  ...e,
  eventStreamMarshaller: e.eventStreamSerdeProvider(e)
});
var Un = "content-length";
function Bu(e) {
  return (t) => async (r) => {
    const n = r.request;
    if (ue.isInstance(n)) {
      const { body: s, headers: i } = n;
      if (s && Object.keys(i).map((o) => o.toLowerCase()).indexOf(Un) === -1)
        try {
          const o = e(s);
          n.headers = {
            ...n.headers,
            [Un]: String(o)
          };
        } catch {
        }
    }
    return t({
      ...r,
      request: n
    });
  };
}
var _u = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var Tu = (e) => ({
  applyToStack: (t) => {
    t.add(Bu(e.bodyLengthChecker), _u);
  }
});
var ku = async (e) => {
  const t = (e == null ? void 0 : e.Bucket) || "";
  if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), Fu(t)) {
    if (e.ForcePathStyle === true)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else
    (!Mu(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = true);
  return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = true, e.DisableMRAP = true), e;
};
var Pu = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var Nu = /(\d+\.){3}\d+/;
var Ou = /\.\./;
var Mu = (e) => Pu.test(e) && !Nu.test(e) && !Ou.test(e);
var Fu = (e) => {
  const [t, r, n, s, i, o] = e.split(":"), a = t === "arn" && e.split(":").length >= 6, c2 = [t, r, n, i, o].filter(Boolean).length === 5;
  if (a && !c2)
    throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
  return t === "arn" && !!r && !!n && !!i && !!o;
};
var Iu = (e, t, r) => {
  const n = async () => {
    const s = r[e] ?? r[t];
    return typeof s == "function" ? s() : s;
  };
  return e === "endpoint" || t === "endpoint" ? async () => {
    const s = await n();
    if (s && typeof s == "object") {
      if ("url" in s)
        return s.url.href;
      if ("hostname" in s) {
        const { protocol: i, hostname: o, port: a, path: c2 } = s;
        return `${i}//${o}${a ? ":" + a : ""}${c2}`;
      }
    }
    return s;
  } : n;
};
var Du = async (e, t, r, n) => {
  const s = await Uu(e, t, r);
  if (typeof r.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return r.endpointProvider(s, n);
};
var Uu = async (e, t, r) => {
  var i;
  const n = {}, s = ((i = t == null ? void 0 : t.getEndpointParameterInstructions) == null ? void 0 : i.call(t)) || {};
  for (const [o, a] of Object.entries(s))
    switch (a.type) {
      case "staticContextParams":
        n[o] = a.value;
        break;
      case "contextParams":
        n[o] = e[a.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        n[o] = await Iu(a.name, o, r)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a));
    }
  return Object.keys(s).length === 0 && Object.assign(n, r), String(r.serviceId).toLowerCase() === "s3" && await ku(n), n;
};
function Lu(e) {
  const t = {};
  if (e = e.replace(/^\?/, ""), e)
    for (const r of e.split("&")) {
      let [n, s = null] = r.split("=");
      n = decodeURIComponent(n), s && (s = decodeURIComponent(s)), n in t ? Array.isArray(t[n]) ? t[n].push(s) : t[n] = [t[n], s] : t[n] = s;
    }
  return t;
}
var kt = (e) => {
  if (typeof e == "string")
    return kt(new URL(e));
  const { hostname: t, pathname: r, port: n, protocol: s, search: i } = e;
  let o;
  return i && (o = Lu(i)), {
    hostname: t,
    port: n ? parseInt(n) : void 0,
    protocol: s,
    path: r,
    query: o
  };
};
var $u = (e) => typeof e == "object" ? "url" in e ? kt(e.url) : e : kt(e);
var Hu = ({ config: e, instructions: t }) => (r, n) => async (s) => {
  var a, c2;
  const i = await Du(s.input, {
    getEndpointParameterInstructions() {
      return t;
    }
  }, { ...e }, n);
  n.endpointV2 = i, n.authSchemes = (a = i.properties) == null ? void 0 : a.authSchemes;
  const o = (c2 = n.authSchemes) == null ? void 0 : c2[0];
  return o && (n.signing_region = o.signingRegion, n.signing_service = o.signingName), r({
    ...s
  });
};
var ju = (e, t) => (r, n) => async (s) => {
  const { response: i } = await r(s);
  try {
    const o = await t(i, e);
    return {
      response: i,
      output: o
    };
  } catch (o) {
    if (Object.defineProperty(o, "$response", {
      value: i
    }), !("$metadata" in o)) {
      const a = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      o.message += `
  ` + a;
    }
    throw o;
  }
};
var qu = (e, t) => (r, n) => async (s) => {
  var a;
  const i = (a = n.endpointV2) != null && a.url && e.urlParser ? async () => e.urlParser(n.endpointV2.url) : e.endpoint;
  if (!i)
    throw new Error("No valid endpoint provider available.");
  const o = await t(s.input, { ...e, endpoint: i });
  return r({
    ...s,
    request: o
  });
};
var zu = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var Yi = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function Vu(e, t, r) {
  return {
    applyToStack: (n) => {
      n.add(ju(e, r), zu), n.add(qu(e, t), Yi);
    }
  };
}
var Gu = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: Yi.name
};
var Wu = (e, t) => ({
  applyToStack: (r) => {
    r.addRelativeTo(Hu({
      config: e,
      instructions: t
    }), Gu);
  }
});
var Ku = (e) => {
  const t = e.tls ?? true, { endpoint: r } = e, n = r != null ? async () => $u(await me(r)()) : void 0;
  return {
    ...e,
    endpoint: n,
    tls: t,
    isCustomEndpoint: !!r,
    useDualstackEndpoint: me(e.useDualstackEndpoint ?? false),
    useFipsEndpoint: me(e.useFipsEndpoint ?? false)
  };
};
var qe;
(function(e) {
  e.STANDARD = "standard", e.ADAPTIVE = "adaptive";
})(qe || (qe = {}));
var Xr = 3;
var Xu = qe.STANDARD;
var Zu = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var Yu = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var Qu = [500, 502, 503, 504];
var Ju = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
var Qi = (e) => {
  var t, r;
  return ((t = e.$metadata) == null ? void 0 : t.httpStatusCode) === 429 || Zu.includes(e.name) || ((r = e.$retryable) == null ? void 0 : r.throttling) == true;
};
var Ji = (e) => {
  var t;
  return Yu.includes(e.name) || Ju.includes((e == null ? void 0 : e.code) || "") || Qu.includes(((t = e.$metadata) == null ? void 0 : t.httpStatusCode) || 0);
};
var ed = (e) => {
  var t;
  if (((t = e.$metadata) == null ? void 0 : t.httpStatusCode) !== void 0) {
    const r = e.$metadata.httpStatusCode;
    return 500 <= r && r <= 599 && !Ji(e);
  }
  return false;
};
var td = class {
  constructor(t) {
    this.currentCapacity = 0, this.enabled = false, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = (t == null ? void 0 : t.beta) ?? 0.7, this.minCapacity = (t == null ? void 0 : t.minCapacity) ?? 1, this.minFillRate = (t == null ? void 0 : t.minFillRate) ?? 0.5, this.scaleConstant = (t == null ? void 0 : t.scaleConstant) ?? 0.4, this.smooth = (t == null ? void 0 : t.smooth) ?? 0.8;
    const r = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(t) {
    if (this.enabled) {
      if (this.refillTokenBucket(), t > this.currentCapacity) {
        const r = (t - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((n) => setTimeout(n, r));
      }
      this.currentCapacity = this.currentCapacity - t;
    }
  }
  refillTokenBucket() {
    const t = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = t;
      return;
    }
    const r = (t - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t;
  }
  updateClientSendingRate(t) {
    let r;
    if (this.updateMeasuredRate(), Qi(t)) {
      const s = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = s, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(s), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const n = Math.min(r, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(n);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(t) {
    return this.getPrecise(t * this.beta);
  }
  cubicSuccess(t) {
    return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(t) {
    this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2;
    if (this.requestCount++, r > this.lastTxRateBucket) {
      const n = this.requestCount / (r - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(n * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r;
    }
  }
  getPrecise(t) {
    return parseFloat(t.toFixed(8));
  }
};
var Dr = 100;
var eo = 20 * 1e3;
var rd = 500;
var Ln = 500;
var nd = 5;
var sd = 10;
var id = 1;
var od = "amz-sdk-invocation-id";
var ad = "amz-sdk-request";
var cd = () => {
  let e = Dr;
  return {
    computeNextBackoffDelay: (n) => Math.floor(Math.min(eo, Math.random() * 2 ** n * e)),
    setDelayBase: (n) => {
      e = n;
    }
  };
};
var $n = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
  getRetryCount: () => t,
  getRetryDelay: () => Math.min(eo, e),
  getRetryCost: () => r
});
var to = class {
  constructor(t) {
    this.maxAttempts = t, this.mode = qe.STANDARD, this.capacity = Ln, this.retryBackoffStrategy = cd(), this.maxAttemptsProvider = typeof t == "function" ? t : async () => t;
  }
  async acquireInitialRetryToken(t) {
    return $n({
      retryDelay: Dr,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(t, r) {
    const n = await this.getMaxAttempts();
    if (this.shouldRetry(t, r, n)) {
      const s = r.errorType;
      this.retryBackoffStrategy.setDelayBase(s === "THROTTLING" ? rd : Dr);
      const i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), o = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, a = this.getCapacityCost(s);
      return this.capacity -= a, $n({
        retryDelay: o,
        retryCount: t.getRetryCount() + 1,
        retryCost: a
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(t) {
    this.capacity = Math.max(Ln, this.capacity + (t.getRetryCost() ?? id));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return Xr;
    }
  }
  shouldRetry(t, r, n) {
    return t.getRetryCount() + 1 < n && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType);
  }
  getCapacityCost(t) {
    return t === "TRANSIENT" ? sd : nd;
  }
  isRetryableError(t) {
    return t === "THROTTLING" || t === "TRANSIENT";
  }
};
var ud = class {
  constructor(t, r) {
    this.maxAttemptsProvider = t, this.mode = qe.ADAPTIVE;
    const { rateLimiter: n } = r ?? {};
    this.rateLimiter = n ?? new td(), this.standardRetryStrategy = new to(t);
  }
  async acquireInitialRetryToken(t) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t);
  }
  async refreshRetryTokenForRetry(t, r) {
    return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r);
  }
  recordSuccess(t) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t);
  }
};
var Ct;
var dd = new Uint8Array(16);
function ld() {
  if (!Ct && (Ct = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Ct))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ct(dd);
}
var fd = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function hd(e) {
  return typeof e == "string" && fd.test(e);
}
var K = [];
for (Yt = 0; Yt < 256; ++Yt)
  K.push((Yt + 256).toString(16).substr(1));
var Yt;
function pd(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = (K[e[t + 0]] + K[e[t + 1]] + K[e[t + 2]] + K[e[t + 3]] + "-" + K[e[t + 4]] + K[e[t + 5]] + "-" + K[e[t + 6]] + K[e[t + 7]] + "-" + K[e[t + 8]] + K[e[t + 9]] + "-" + K[e[t + 10]] + K[e[t + 11]] + K[e[t + 12]] + K[e[t + 13]] + K[e[t + 14]] + K[e[t + 15]]).toLowerCase();
  if (!hd(r))
    throw TypeError("Stringified UUID is invalid");
  return r;
}
function gd(e, t, r) {
  e = e || {};
  var n = e.random || (e.rng || ld)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, t) {
    r = r || 0;
    for (var s = 0; s < 16; ++s)
      t[r + s] = n[s];
    return t;
  }
  return pd(n);
}
var md = (e) => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error(), e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`);
var yd = (e) => {
  const { retryStrategy: t } = e, r = me(e.maxAttempts ?? Xr);
  return {
    ...e,
    maxAttempts: r,
    retryStrategy: async () => t || (await me(e.retryMode)() === qe.ADAPTIVE ? new ud(r) : new to(r))
  };
};
var bd = (e) => (t, r) => async (n) => {
  let s = await e.retryStrategy();
  const i = await e.maxAttempts();
  if (wd(s)) {
    s = s;
    let o = await s.acquireInitialRetryToken(r.partition_id), a = new Error(), c2 = 0, u = 0;
    const { request: d } = n;
    for (ue.isInstance(d) && (d.headers[od] = gd()); ; )
      try {
        ue.isInstance(d) && (d.headers[ad] = `attempt=${c2 + 1}; max=${i}`);
        const { response: h, output: p } = await t(n);
        return s.recordSuccess(o), p.$metadata.attempts = c2 + 1, p.$metadata.totalRetryDelay = u, { response: h, output: p };
      } catch (h) {
        const p = Ad(h);
        a = md(h);
        try {
          o = await s.refreshRetryTokenForRetry(o, p);
        } catch {
          throw a.$metadata || (a.$metadata = {}), a.$metadata.attempts = c2 + 1, a.$metadata.totalRetryDelay = u, a;
        }
        c2 = o.getRetryCount();
        const y = o.getRetryDelay();
        u += y, await new Promise((g) => setTimeout(g, y));
      }
  } else
    return s = s, s != null && s.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", s.mode]]), s.retry(t, n);
};
var wd = (e) => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u";
var Ad = (e) => {
  const t = {
    errorType: Ed(e)
  }, r = vd(e.$response);
  return r && (t.retryAfterHint = r), t;
};
var Ed = (e) => Qi(e) ? "THROTTLING" : Ji(e) ? "TRANSIENT" : ed(e) ? "SERVER_ERROR" : "CLIENT_ERROR";
var xd = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var Sd = (e) => ({
  applyToStack: (t) => {
    t.add(bd(e), xd);
  }
});
var vd = (e) => {
  if (!Tt.isInstance(e))
    return;
  const t = Object.keys(e.headers).find((i) => i.toLowerCase() === "retry-after");
  if (!t)
    return;
  const r = e.headers[t], n = Number(r);
  return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3);
};
var Cd = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};
var Pt = () => {
  let e = [], t = [];
  const r = /* @__PURE__ */ new Set(), n = (d) => d.sort((h, p) => Hn[p.step] - Hn[h.step] || jn[p.priority || "normal"] - jn[h.priority || "normal"]), s = (d) => {
    let h = false;
    const p = (y) => y.name && y.name === d ? (h = true, r.delete(d), false) : true;
    return e = e.filter(p), t = t.filter(p), h;
  }, i = (d) => {
    let h = false;
    const p = (y) => y.middleware === d ? (h = true, y.name && r.delete(y.name), false) : true;
    return e = e.filter(p), t = t.filter(p), h;
  }, o = (d) => (e.forEach((h) => {
    d.add(h.middleware, { ...h });
  }), t.forEach((h) => {
    d.addRelativeTo(h.middleware, { ...h });
  }), d), a = (d) => {
    const h = [];
    return d.before.forEach((p) => {
      p.before.length === 0 && p.after.length === 0 ? h.push(p) : h.push(...a(p));
    }), h.push(d), d.after.reverse().forEach((p) => {
      p.before.length === 0 && p.after.length === 0 ? h.push(p) : h.push(...a(p));
    }), h;
  }, c2 = (d = false) => {
    const h = [], p = [], y = {};
    return e.forEach((A) => {
      const B = {
        ...A,
        before: [],
        after: []
      };
      B.name && (y[B.name] = B), h.push(B);
    }), t.forEach((A) => {
      const B = {
        ...A,
        before: [],
        after: []
      };
      B.name && (y[B.name] = B), p.push(B);
    }), p.forEach((A) => {
      if (A.toMiddleware) {
        const B = y[A.toMiddleware];
        if (B === void 0) {
          if (d)
            return;
          throw new Error(`${A.toMiddleware} is not found when adding ${A.name || "anonymous"} middleware ${A.relation} ${A.toMiddleware}`);
        }
        A.relation === "after" && B.after.push(A), A.relation === "before" && B.before.push(A);
      }
    }), n(h).map(a).reduce((A, B) => (A.push(...B), A), []);
  }, u = {
    add: (d, h = {}) => {
      const { name: p, override: y } = h, g = {
        step: "initialize",
        priority: "normal",
        middleware: d,
        ...h
      };
      if (p) {
        if (r.has(p)) {
          if (!y)
            throw new Error(`Duplicate middleware name '${p}'`);
          const A = e.findIndex((fe) => fe.name === p), B = e[A];
          if (B.step !== g.step || B.priority !== g.priority)
            throw new Error(`"${p}" middleware with ${B.priority} priority in ${B.step} step cannot be overridden by same-name middleware with ${g.priority} priority in ${g.step} step.`);
          e.splice(A, 1);
        }
        r.add(p);
      }
      e.push(g);
    },
    addRelativeTo: (d, h) => {
      const { name: p, override: y } = h, g = {
        middleware: d,
        ...h
      };
      if (p) {
        if (r.has(p)) {
          if (!y)
            throw new Error(`Duplicate middleware name '${p}'`);
          const A = t.findIndex((fe) => fe.name === p), B = t[A];
          if (B.toMiddleware !== g.toMiddleware || B.relation !== g.relation)
            throw new Error(`"${p}" middleware ${B.relation} "${B.toMiddleware}" middleware cannot be overridden by same-name middleware ${g.relation} "${g.toMiddleware}" middleware.`);
          t.splice(A, 1);
        }
        r.add(p);
      }
      t.push(g);
    },
    clone: () => o(Pt()),
    use: (d) => {
      d.applyToStack(u);
    },
    remove: (d) => typeof d == "string" ? s(d) : i(d),
    removeByTag: (d) => {
      let h = false;
      const p = (y) => {
        const { tags: g, name: A } = y;
        return g && g.includes(d) ? (A && r.delete(A), h = true, false) : true;
      };
      return e = e.filter(p), t = t.filter(p), h;
    },
    concat: (d) => {
      const h = o(Pt());
      return h.use(d), h;
    },
    applyToStack: o,
    identify: () => c2(true).map((d) => d.name + ": " + (d.tags || []).join(",")),
    resolve: (d, h) => {
      for (const p of c2().map((y) => y.middleware).reverse())
        d = p(d, h);
      return d;
    }
  };
  return u;
};
var Hn = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var jn = {
  high: 3,
  normal: 2,
  low: 1
};
var Rd = class {
  constructor(t) {
    this.middlewareStack = Pt(), this.config = t;
  }
  send(t, r, n) {
    const s = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : n, o = t.resolveMiddleware(this.middlewareStack, this.config, s);
    if (i)
      o(t).then((a) => i(null, a.output), (a) => i(a)).catch(() => {
      });
    else
      return o(t).then((a) => a.output);
  }
  destroy() {
    this.config.requestHandler.destroy && this.config.requestHandler.destroy();
  }
};
var ke = {};
var Ve = new Array(64);
for (let e = 0, t = "A".charCodeAt(0), r = "Z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t);
  ke[n] = e, Ve[e] = n;
}
for (let e = 0, t = "a".charCodeAt(0), r = "z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t), s = e + 26;
  ke[n] = s, Ve[s] = n;
}
for (let e = 0; e < 10; e++) {
  ke[e.toString(10)] = e + 52;
  const t = e.toString(10), r = e + 52;
  ke[t] = r, Ve[r] = t;
}
ke["+"] = 62;
Ve[62] = "+";
ke["/"] = 63;
Ve[63] = "/";
var je = 6;
var yt = 8;
var Bd = 63;
var Zr = (e) => {
  let t = e.length / 4 * 3;
  e.slice(-2) === "==" ? t -= 2 : e.slice(-1) === "=" && t--;
  const r = new ArrayBuffer(t), n = new DataView(r);
  for (let s = 0; s < e.length; s += 4) {
    let i = 0, o = 0;
    for (let u = s, d = s + 3; u <= d; u++)
      if (e[u] !== "=") {
        if (!(e[u] in ke))
          throw new TypeError(`Invalid character ${e[u]} in base64 string.`);
        i |= ke[e[u]] << (d - u) * je, o += je;
      } else
        i >>= je;
    const a = s / 4 * 3;
    i >>= o % yt;
    const c2 = Math.floor(o / yt);
    for (let u = 0; u < c2; u++) {
      const d = (c2 - u - 1) * yt;
      n.setUint8(a + u, (i & 255 << d) >> d);
    }
  }
  return new Uint8Array(r);
};
function Yr(e) {
  let t = "";
  for (let r = 0; r < e.length; r += 3) {
    let n = 0, s = 0;
    for (let o = r, a = Math.min(r + 3, e.length); o < a; o++)
      n |= e[o] << (a - o - 1) * yt, s += yt;
    const i = Math.ceil(s / je);
    n <<= i * je - s;
    for (let o = 1; o <= i; o++) {
      const a = (i - o) * je;
      t += Ve[(n & Bd << a) >> a];
    }
    t += "==".slice(0, 4 - i);
  }
  return t;
}
function _d(e, t = "utf-8") {
  return t === "base64" ? Yr(e) : It(e);
}
function Td(e, t) {
  return t === "base64" ? De.mutate(Zr(e)) : De.mutate(xt(e));
}
var De = class _De extends Uint8Array {
  static fromString(t, r = "utf-8") {
    switch (typeof t) {
      case "string":
        return Td(t, r);
      default:
        throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(t) {
    return Object.setPrototypeOf(t, _De.prototype), t;
  }
  transformToString(t = "utf-8") {
    return _d(this, t);
  }
};
var kd = (e, t) => {
  const { base64Encoder: r, bodyLengthChecker: n, checksumAlgorithmFn: s, checksumLocationName: i, streamHasher: o } = t, a = r !== void 0 && n !== void 0 && s !== void 0 && i !== void 0 && o !== void 0, c2 = a ? o(s, e) : void 0, u = e.getReader();
  return new ReadableStream({
    async pull(d) {
      const { value: h, done: p } = await u.read();
      if (p) {
        if (d.enqueue(`0\r
`), a) {
          const y = r(await c2);
          d.enqueue(`${i}:${y}\r
`), d.enqueue(`\r
`);
        }
        d.close();
      } else
        d.enqueue(`${(n(h) || 0).toString(16)}\r
${h}\r
`);
    }
  });
};
function Pd(e) {
  const t = [];
  for (let r of Object.keys(e).sort()) {
    const n = e[r];
    if (r = Fe(r), Array.isArray(n))
      for (let s = 0, i = n.length; s < i; s++)
        t.push(`${r}=${Fe(n[s])}`);
    else {
      let s = r;
      (n || typeof n == "string") && (s += `=${Fe(n)}`), t.push(s);
    }
  }
  return t.join("&");
}
function Nd(e = 0) {
  return new Promise((t, r) => {
    e && setTimeout(() => {
      const n = new Error(`Request did not complete within ${e} ms`);
      n.name = "TimeoutError", r(n);
    }, e);
  });
}
var Od = class {
  constructor(t) {
    typeof t == "function" ? this.configProvider = t().then((r) => r || {}) : (this.config = t ?? {}, this.configProvider = Promise.resolve(this.config));
  }
  destroy() {
  }
  async handle(t, { abortSignal: r } = {}) {
    this.config || (this.config = await this.configProvider);
    const n = this.config.requestTimeout;
    if (r != null && r.aborted) {
      const g = new Error("Request aborted");
      return g.name = "AbortError", Promise.reject(g);
    }
    let s = t.path;
    const i = Pd(t.query || {});
    i && (s += `?${i}`), t.fragment && (s += `#${t.fragment}`);
    let o = "";
    if (t.username != null || t.password != null) {
      const g = t.username ?? "", A = t.password ?? "";
      o = `${g}:${A}@`;
    }
    const { port: a, method: c2 } = t, u = `${t.protocol}//${o}${t.hostname}${a ? `:${a}` : ""}${s}`, h = {
      body: c2 === "GET" || c2 === "HEAD" ? void 0 : t.body,
      headers: new Headers(t.headers),
      method: c2
    };
    typeof AbortController < "u" && (h.signal = r);
    const p = new Request(u, h), y = [
      fetch(p).then((g) => {
        const A = g.headers, B = {};
        for (const se of A.entries())
          B[se[0]] = se[1];
        return g.body != null ? {
          response: new Tt({
            headers: B,
            reason: g.statusText,
            statusCode: g.status,
            body: g.body
          })
        } : g.blob().then((se) => ({
          response: new Tt({
            headers: B,
            reason: g.statusText,
            statusCode: g.status,
            body: se
          })
        }));
      }),
      Nd(n)
    ];
    return r && y.push(new Promise((g, A) => {
      r.onabort = () => {
        const B = new Error("Request aborted");
        B.name = "AbortError", A(B);
      };
    })), Promise.race(y);
  }
};
var ro = (e) => typeof Blob == "function" && e instanceof Blob ? Md(e) : Fd(e);
async function Md(e) {
  const t = await Id(e), r = Zr(t);
  return new Uint8Array(r);
}
async function Fd(e) {
  let t = new Uint8Array(0);
  const r = e.getReader();
  let n = false;
  for (; !n; ) {
    const { done: s, value: i } = await r.read();
    if (i) {
      const o = t;
      t = new Uint8Array(o.length + i.length), t.set(o), t.set(i, o.length);
    }
    n = s;
  }
  return t;
}
function Id(e) {
  return new Promise((t, r) => {
    const n = new FileReader();
    n.onloadend = () => {
      if (n.readyState !== 2)
        return r(new Error("Reader aborted too early"));
      const s = n.result ?? "", i = s.indexOf(","), o = i > -1 ? i + 1 : s.length;
      t(s.substring(o));
    }, n.onabort = () => r(new Error("Read aborted")), n.onerror = () => r(n.error), n.readAsDataURL(e);
  });
}
var qn = "The stream has already been transformed.";
var Dd = (e) => {
  var s, i;
  if (!zn(e) && !Vn(e)) {
    const o = ((i = (s = e == null ? void 0 : e.__proto__) == null ? void 0 : s.constructor) == null ? void 0 : i.name) || e;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${o}`);
  }
  let t = false;
  const r = async () => {
    if (t)
      throw new Error(qn);
    return t = true, await ro(e);
  }, n = (o) => {
    if (typeof o.stream != "function")
      throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
    return o.stream();
  };
  return Object.assign(e, {
    transformToByteArray: r,
    transformToString: async (o) => {
      const a = await r();
      if (o === "base64")
        return Yr(a);
      if (o === "hex")
        return ce(a);
      if (o === void 0 || o === "utf8" || o === "utf-8")
        return It(a);
      if (typeof TextDecoder == "function")
        return new TextDecoder(o).decode(a);
      throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
    },
    transformToWebStream: () => {
      if (t)
        throw new Error(qn);
      if (t = true, zn(e))
        return n(e);
      if (Vn(e))
        return e;
      throw new Error(`Cannot transform payload to web stream, got ${e}`);
    }
  });
};
var zn = (e) => typeof Blob == "function" && e instanceof Blob;
var Vn = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream;
var no = async (e = new Uint8Array(), t) => {
  if (e instanceof Uint8Array)
    return De.mutate(e);
  if (!e)
    return De.mutate(new Uint8Array());
  const r = t.streamCollector(e);
  return De.mutate(await r);
};
var Ud = class {
  constructor() {
    this.middlewareStack = Pt();
  }
};
var bt = "***SensitiveInformation***";
var Ld = (e) => {
  switch (e) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${e}"`);
  }
};
var $d = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var Hd = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function jd(e) {
  const t = e.getUTCFullYear(), r = e.getUTCMonth(), n = e.getUTCDay(), s = e.getUTCDate(), i = e.getUTCHours(), o = e.getUTCMinutes(), a = e.getUTCSeconds(), c2 = s < 10 ? `0${s}` : `${s}`, u = i < 10 ? `0${i}` : `${i}`, d = o < 10 ? `0${o}` : `${o}`, h = a < 10 ? `0${a}` : `${a}`;
  return `${$d[n]}, ${c2} ${Hd[r]} ${t} ${u}:${d}:${h} GMT`;
}
var Qr = class _Qr extends Error {
  constructor(t) {
    super(t.message), Object.setPrototypeOf(this, _Qr.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata;
  }
};
var qd = (e, t = {}) => {
  Object.entries(t).filter(([, n]) => n !== void 0).forEach(([n, s]) => {
    (e[n] == null || e[n] === "") && (e[n] = s);
  });
  const r = e.message || e.Message || "UnknownError";
  return e.message = r, delete e.Message, e;
};
var zd = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
  const s = Gd(e), i = s.httpStatusCode ? s.httpStatusCode + "" : void 0, o = new r({
    name: (t == null ? void 0 : t.code) || (t == null ? void 0 : t.Code) || n || i || "UnknownError",
    $fault: "client",
    $metadata: s
  });
  throw qd(o, t);
};
var Vd = (e) => ({ output: t, parsedBody: r, errorCode: n }) => {
  zd({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
};
var Gd = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
});
var Wd = (e) => {
  switch (e) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};
function Gn(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function(t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var so = (e) => {
  const t = "#text";
  for (const r in e)
    e.hasOwnProperty(r) && e[r][t] !== void 0 ? e[r] = e[r][t] : typeof e[r] == "object" && e[r] !== null && (e[r] = so(e[r]));
  return e;
};
var Ur = function() {
  const e = Object.getPrototypeOf(this).constructor, t = Function.bind.apply(String, [null, ...arguments]), r = new t();
  return Object.setPrototypeOf(r, e.prototype), r;
};
Ur.prototype = Object.create(String.prototype, {
  constructor: {
    value: Ur,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(Ur, String);
function Nt(e, t, r) {
  let n, s, i;
  if (typeof t > "u" && typeof r > "u")
    n = {}, i = e;
  else {
    if (n = e, typeof t == "function")
      return s = t, i = r, Kd(n, s, i);
    i = t;
  }
  for (const o of Object.keys(i)) {
    if (!Array.isArray(i[o])) {
      n[o] = i[o];
      continue;
    }
    Xd(n, null, i, o);
  }
  return n;
}
var Kd = (e, t, r) => Nt(e, Object.entries(r).reduce((n, [s, i]) => (Array.isArray(i) ? n[s] = i : typeof i == "function" ? n[s] = [t, i()] : n[s] = [t, i], n), {}));
var Xd = (e, t, r, n) => {
  if (t !== null) {
    let o = r[n];
    typeof o == "function" && (o = [, o]);
    const [a = Zd, c2 = Yd, u = n] = o;
    (typeof a == "function" && a(t[u]) || typeof a != "function" && a) && (e[n] = c2(t[u]));
    return;
  }
  let [s, i] = r[n];
  if (typeof i == "function") {
    let o;
    const a = s === void 0 && (o = i()) != null, c2 = typeof s == "function" && !!s(void 0) || typeof s != "function" && !!s;
    a ? e[n] = o : c2 && (e[n] = i());
  } else {
    const o = s === void 0 && i != null, a = typeof s == "function" && !!s(i) || typeof s != "function" && !!s;
    (o || a) && (e[n] = i);
  }
};
var Zd = (e) => e != null;
var Yd = (e) => e;
var Wn = (e, t, r, n, s, i) => {
  if (t != null && t[r] !== void 0) {
    const o = n();
    if (o.length <= 0)
      throw new Error("Empty value provided for input HTTP label: " + r + ".");
    e = e.replace(s, i ? o.split("/").map((a) => Gn(a)).join("/") : Gn(o));
  } else
    throw new Error("No value provided for input HTTP label: " + r + ".");
  return e;
};
var Qd = (e) => ({
  ...e,
  useFipsEndpoint: e.useFipsEndpoint ?? false,
  useDualstackEndpoint: e.useDualstackEndpoint ?? false,
  forcePathStyle: e.forcePathStyle ?? false,
  useAccelerateEndpoint: e.useAccelerateEndpoint ?? false,
  useGlobalEndpoint: e.useGlobalEndpoint ?? false,
  disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? false,
  defaultSigningName: "s3"
});
var Jd = "@aws-sdk/client-s3";
var el = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native";
var tl = "3.383.0";
var rl = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "tsc -p tsconfig.cjs.json",
  "build:docs": "typedoc",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
  test: "yarn test:unit",
  "test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js",
  "test:unit": "ts-mocha test/**/*.spec.ts"
};
var nl = "./dist-cjs/index.js";
var sl = "./dist-types/index.d.ts";
var il = "./dist-es/index.js";
var ol = false;
var al = {
  "@aws-crypto/sha1-browser": "3.0.0",
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sts": "3.382.0",
  "@aws-sdk/credential-provider-node": "3.382.0",
  "@aws-sdk/middleware-bucket-endpoint": "3.378.0",
  "@aws-sdk/middleware-expect-continue": "3.378.0",
  "@aws-sdk/middleware-flexible-checksums": "3.383.0",
  "@aws-sdk/middleware-host-header": "3.379.1",
  "@aws-sdk/middleware-location-constraint": "3.379.1",
  "@aws-sdk/middleware-logger": "3.378.0",
  "@aws-sdk/middleware-recursion-detection": "3.378.0",
  "@aws-sdk/middleware-sdk-s3": "3.379.1",
  "@aws-sdk/middleware-signing": "3.379.1",
  "@aws-sdk/middleware-ssec": "3.378.0",
  "@aws-sdk/middleware-user-agent": "3.382.0",
  "@aws-sdk/signature-v4-multi-region": "3.378.0",
  "@aws-sdk/types": "3.378.0",
  "@aws-sdk/util-endpoints": "3.382.0",
  "@aws-sdk/util-user-agent-browser": "3.378.0",
  "@aws-sdk/util-user-agent-node": "3.378.0",
  "@aws-sdk/xml-builder": "3.310.0",
  "@smithy/config-resolver": "^2.0.1",
  "@smithy/eventstream-serde-browser": "^2.0.1",
  "@smithy/eventstream-serde-config-resolver": "^2.0.1",
  "@smithy/eventstream-serde-node": "^2.0.1",
  "@smithy/fetch-http-handler": "^2.0.1",
  "@smithy/hash-blob-browser": "^2.0.1",
  "@smithy/hash-node": "^2.0.1",
  "@smithy/hash-stream-node": "^2.0.1",
  "@smithy/invalid-dependency": "^2.0.1",
  "@smithy/md5-js": "^2.0.1",
  "@smithy/middleware-content-length": "^2.0.1",
  "@smithy/middleware-endpoint": "^2.0.1",
  "@smithy/middleware-retry": "^2.0.1",
  "@smithy/middleware-serde": "^2.0.1",
  "@smithy/middleware-stack": "^2.0.0",
  "@smithy/node-config-provider": "^2.0.1",
  "@smithy/node-http-handler": "^2.0.1",
  "@smithy/protocol-http": "^2.0.1",
  "@smithy/smithy-client": "^2.0.1",
  "@smithy/types": "^2.0.2",
  "@smithy/url-parser": "^2.0.1",
  "@smithy/util-base64": "^2.0.0",
  "@smithy/util-body-length-browser": "^2.0.0",
  "@smithy/util-body-length-node": "^2.0.0",
  "@smithy/util-defaults-mode-browser": "^2.0.1",
  "@smithy/util-defaults-mode-node": "^2.0.1",
  "@smithy/util-retry": "^2.0.0",
  "@smithy/util-stream": "^2.0.1",
  "@smithy/util-utf8": "^2.0.0",
  "@smithy/util-waiter": "^2.0.1",
  "fast-xml-parser": "4.2.5",
  tslib: "^2.5.0"
};
var cl = {
  "@smithy/service-client-documentation-generator": "^2.0.0",
  "@tsconfig/node14": "1.0.3",
  "@types/chai": "^4.2.11",
  "@types/mocha": "^8.0.4",
  "@types/node": "^14.14.31",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typedoc: "0.23.23",
  typescript: "~4.9.5"
};
var ul = {
  node: ">=14.0.0"
};
var dl = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
};
var ll = [
  "dist-*/**"
];
var fl = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
};
var hl = "Apache-2.0";
var pl = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var gl = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3";
var ml = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-s3"
};
var yl = {
  name: Jd,
  description: el,
  version: tl,
  scripts: rl,
  main: nl,
  types: sl,
  module: il,
  sideEffects: ol,
  dependencies: al,
  devDependencies: cl,
  engines: ul,
  typesVersions: dl,
  files: ll,
  author: fl,
  license: hl,
  browser: pl,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: gl,
  repository: ml
};
var io = {};
var Qe = {};
var Je = {};
var et = {};
var Kn;
function oo() {
  if (Kn)
    return et;
  Kn = 1, Object.defineProperty(et, "__esModule", { value: true }), et.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return et.isEmptyData = e, et;
}
var Qt = {};
var Xn;
function ao() {
  return Xn || (Xn = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.EMPTY_DATA_SHA_1 = e.SHA_1_HMAC_ALGO = e.SHA_1_HASH = void 0, e.SHA_1_HASH = { name: "SHA-1" }, e.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_1_HASH
    }, e.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }(Qt)), Qt;
}
var bl = {};
function wl() {
  return typeof window < "u" ? window : typeof self < "u" ? self : bl;
}
var Al = Object.freeze(Object.defineProperty({
  __proto__: null,
  locateWindow: wl
}, Symbol.toStringTag, { value: "Module" }));
var Ge = c(Al);
var Zn;
function co() {
  if (Zn)
    return Je;
  Zn = 1, Object.defineProperty(Je, "__esModule", { value: true }), Je.Sha1 = void 0;
  var e = oo(), t = ao(), r = Ft, n = Ge, s = (
    /** @class */
    function() {
      function a(c2) {
        this.secret = c2, this.reset();
      }
      return a.prototype.update = function(c2) {
        var u = this;
        (0, e.isEmptyData)(c2) || (this.operation = this.operation.then(function(d) {
          return d.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, d.process(o(c2)), d;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c2) {
          return new Promise(function(u, d) {
            c2.onerror = function() {
              d(new Error("Error encountered finalizing hash"));
            }, c2.oncomplete = function() {
              c2.result && u(new Uint8Array(c2.result)), d(new Error("Error encountered finalizing hash"));
            }, c2.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c2) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_1_HMAC_ALGO, c2);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-1"));
      }, a;
    }()
  );
  Je.Sha1 = s;
  function i(a) {
    return new Promise(function(c2, u) {
      var d = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_1_HMAC_ALGO, false, ["sign"]);
      d.oncomplete = function() {
        d.result && c2(d.result), u(new Error("ImportKey completed without importing key."));
      }, d.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return Je;
}
var tt = {};
var Yn;
function uo() {
  if (Yn)
    return tt;
  Yn = 1, Object.defineProperty(tt, "__esModule", { value: true }), tt.Sha1 = void 0;
  var e = Ft, t = oo(), r = ao(), n = Ge, s = (
    /** @class */
    function() {
      function o(a) {
        this.toHash = new Uint8Array(0), a !== void 0 && (this.key = new Promise(function(c2, u) {
          (0, n.locateWindow)().crypto.subtle.importKey("raw", i(a), r.SHA_1_HMAC_ALGO, false, ["sign"]).then(c2, u);
        }), this.key.catch(function() {
        }));
      }
      return o.prototype.update = function(a) {
        if (!(0, t.isEmptyData)(a)) {
          var c2 = i(a), u = new Uint8Array(this.toHash.byteLength + c2.byteLength);
          u.set(this.toHash, 0), u.set(c2, this.toHash.byteLength), this.toHash = u;
        }
      }, o.prototype.digest = function() {
        var a = this;
        return this.key ? this.key.then(function(c2) {
          return (0, n.locateWindow)().crypto.subtle.sign(r.SHA_1_HMAC_ALGO, c2, a.toHash).then(function(u) {
            return new Uint8Array(u);
          });
        }) : (0, t.isEmptyData)(this.toHash) ? Promise.resolve(r.EMPTY_DATA_SHA_1) : Promise.resolve().then(function() {
          return (0, n.locateWindow)().crypto.subtle.digest(r.SHA_1_HASH, a.toHash);
        }).then(function(c2) {
          return Promise.resolve(new Uint8Array(c2));
        });
      }, o.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      }, o;
    }()
  );
  tt.Sha1 = s;
  function i(o) {
    return typeof o == "string" ? (0, e.fromUtf8)(o) : ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(o);
  }
  return tt;
}
var Jt = {};
var he = {};
var Qn;
function El() {
  if (Qn)
    return he;
  Qn = 1, Object.defineProperty(he, "__esModule", { value: true }), he.supportsZeroByteGCM = he.supportsSubtleCrypto = he.supportsSecureRandom = he.supportsWebCrypto = void 0;
  var e = ye, t = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function r(o) {
    if (n(o) && typeof o.crypto.subtle == "object") {
      var a = o.crypto.subtle;
      return s(a);
    }
    return false;
  }
  he.supportsWebCrypto = r;
  function n(o) {
    if (typeof o == "object" && typeof o.crypto == "object") {
      var a = o.crypto.getRandomValues;
      return typeof a == "function";
    }
    return false;
  }
  he.supportsSecureRandom = n;
  function s(o) {
    return o && t.every(function(a) {
      return typeof o[a] == "function";
    });
  }
  he.supportsSubtleCrypto = s;
  function i(o) {
    return e.__awaiter(this, void 0, void 0, function() {
      var a, c2;
      return e.__generator(this, function(u) {
        switch (u.label) {
          case 0:
            if (!s(o))
              return [2, false];
            u.label = 1;
          case 1:
            return u.trys.push([1, 4, , 5]), [4, o.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
          case 2:
            return a = u.sent(), [4, o.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, a, new Uint8Array(0))];
          case 3:
            return c2 = u.sent(), [2, c2.byteLength === 16];
          case 4:
            return u.sent(), [2, false];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return he.supportsZeroByteGCM = i, he;
}
var Jn;
function lo() {
  return Jn || (Jn = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = ye;
    t.__exportStar(El(), e);
  }(Jt)), Jt;
}
var er = {};
var tr = {};
var es;
function xl() {
  return es || (es = 1, Object.defineProperty(tr, "__esModule", { value: true })), tr;
}
var rr = {};
var ts;
function Sl() {
  return ts || (ts = 1, Object.defineProperty(rr, "__esModule", { value: true })), rr;
}
var nr = {};
var rs;
function vl() {
  return rs || (rs = 1, Object.defineProperty(nr, "__esModule", { value: true })), nr;
}
var sr = {};
var ns;
function Cl() {
  return ns || (ns = 1, Object.defineProperty(sr, "__esModule", { value: true })), sr;
}
var rt = {};
var ss;
function Rl() {
  if (ss)
    return rt;
  ss = 1, Object.defineProperty(rt, "__esModule", { value: true }), rt.isMsWindow = void 0;
  var e = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function t(n) {
    return "MSInputMethodContext" in n && "msCrypto" in n;
  }
  function r(n) {
    if (t(n) && n.msCrypto.subtle !== void 0) {
      var s = n.msCrypto, i = s.getRandomValues, o = s.subtle;
      return e.map(function(a) {
        return o[a];
      }).concat(i).every(function(a) {
        return typeof a == "function";
      });
    }
    return false;
  }
  return rt.isMsWindow = r, rt;
}
var is;
function fo() {
  return is || (is = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = ye;
    t.__exportStar(xl(), e), t.__exportStar(Sl(), e), t.__exportStar(vl(), e), t.__exportStar(Cl(), e), t.__exportStar(Rl(), e);
  }(er)), er;
}
var os;
function Bl() {
  if (os)
    return Qe;
  os = 1, Object.defineProperty(Qe, "__esModule", { value: true }), Qe.Sha1 = void 0;
  var e = co(), t = uo(), r = lo(), n = fo(), s = Ge, i = Pe(), o = (
    /** @class */
    function() {
      function a(c2) {
        if ((0, r.supportsWebCrypto)((0, s.locateWindow)()))
          this.hash = new t.Sha1(c2);
        else if ((0, n.isMsWindow)((0, s.locateWindow)()))
          this.hash = new e.Sha1(c2);
        else
          throw new Error("SHA1 not supported");
      }
      return a.prototype.update = function(c2, u) {
        this.hash.update((0, i.convertToBuffer)(c2));
      }, a.prototype.digest = function() {
        return this.hash.digest();
      }, a.prototype.reset = function() {
        this.hash.reset();
      }, a;
    }()
  );
  return Qe.Sha1 = o, Qe;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.WebCryptoSha1 = e.Ie11Sha1 = void 0;
  var t = ye;
  t.__exportStar(Bl(), e);
  var r = co();
  Object.defineProperty(e, "Ie11Sha1", { enumerable: true, get: function() {
    return r.Sha1;
  } });
  var n = uo();
  Object.defineProperty(e, "WebCryptoSha1", { enumerable: true, get: function() {
    return n.Sha1;
  } });
})(io);
var ho = {};
var nt = {};
var st = {};
var it = {};
var as;
function _l() {
  if (as)
    return it;
  as = 1, Object.defineProperty(it, "__esModule", { value: true }), it.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return it.isEmptyData = e, it;
}
var ir = {};
var cs;
function po() {
  return cs || (cs = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.EMPTY_DATA_SHA_256 = e.SHA_256_HMAC_ALGO = e.SHA_256_HASH = void 0, e.SHA_256_HASH = { name: "SHA-256" }, e.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_256_HASH
    }, e.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }(ir)), ir;
}
var us;
function go() {
  if (us)
    return st;
  us = 1, Object.defineProperty(st, "__esModule", { value: true }), st.Sha256 = void 0;
  var e = _l(), t = po(), r = Ft, n = Ge, s = (
    /** @class */
    function() {
      function a(c2) {
        this.secret = c2, this.reset();
      }
      return a.prototype.update = function(c2) {
        var u = this;
        (0, e.isEmptyData)(c2) || (this.operation = this.operation.then(function(d) {
          return d.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, d.process(o(c2)), d;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c2) {
          return new Promise(function(u, d) {
            c2.onerror = function() {
              d(new Error("Error encountered finalizing hash"));
            }, c2.oncomplete = function() {
              c2.result && u(new Uint8Array(c2.result)), d(new Error("Error encountered finalizing hash"));
            }, c2.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c2) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_256_HMAC_ALGO, c2);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-256"));
      }, a;
    }()
  );
  st.Sha256 = s;
  function i(a) {
    return new Promise(function(c2, u) {
      var d = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_256_HMAC_ALGO, false, ["sign"]);
      d.oncomplete = function() {
        d.result && c2(d.result), u(new Error("ImportKey completed without importing key."));
      }, d.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return st;
}
var ot = {};
var ds;
function mo() {
  if (ds)
    return ot;
  ds = 1, Object.defineProperty(ot, "__esModule", { value: true }), ot.Sha256 = void 0;
  var e = Pe(), t = po(), r = Ge, n = (
    /** @class */
    function() {
      function s(i) {
        this.toHash = new Uint8Array(0), this.secret = i, this.reset();
      }
      return s.prototype.update = function(i) {
        if (!(0, e.isEmptyData)(i)) {
          var o = (0, e.convertToBuffer)(i), a = new Uint8Array(this.toHash.byteLength + o.byteLength);
          a.set(this.toHash, 0), a.set(o, this.toHash.byteLength), this.toHash = a;
        }
      }, s.prototype.digest = function() {
        var i = this;
        return this.key ? this.key.then(function(o) {
          return (0, r.locateWindow)().crypto.subtle.sign(t.SHA_256_HMAC_ALGO, o, i.toHash).then(function(a) {
            return new Uint8Array(a);
          });
        }) : (0, e.isEmptyData)(this.toHash) ? Promise.resolve(t.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
          return (0, r.locateWindow)().crypto.subtle.digest(t.SHA_256_HASH, i.toHash);
        }).then(function(o) {
          return Promise.resolve(new Uint8Array(o));
        });
      }, s.prototype.reset = function() {
        var i = this;
        this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(o, a) {
          (0, r.locateWindow)().crypto.subtle.importKey("raw", (0, e.convertToBuffer)(i.secret), t.SHA_256_HMAC_ALGO, false, ["sign"]).then(o, a);
        }), this.key.catch(function() {
        }));
      }, s;
    }()
  );
  return ot.Sha256 = n, ot;
}
var or = {};
var at = {};
var ae = {};
var ls;
function yo() {
  return ls || (ls = 1, Object.defineProperty(ae, "__esModule", { value: true }), ae.MAX_HASHABLE_LENGTH = ae.INIT = ae.KEY = ae.DIGEST_LENGTH = ae.BLOCK_SIZE = void 0, ae.BLOCK_SIZE = 64, ae.DIGEST_LENGTH = 32, ae.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), ae.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], ae.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1), ae;
}
var ct = {};
var fs;
function Tl() {
  if (fs)
    return ct;
  fs = 1, Object.defineProperty(ct, "__esModule", { value: true }), ct.RawSha256 = void 0;
  var e = yo(), t = (
    /** @class */
    function() {
      function r() {
        this.state = Int32Array.from(e.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = false;
      }
      return r.prototype.update = function(n) {
        if (this.finished)
          throw new Error("Attempted to update an already finished hash.");
        var s = 0, i = n.byteLength;
        if (this.bytesHashed += i, this.bytesHashed * 8 > e.MAX_HASHABLE_LENGTH)
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; i > 0; )
          this.buffer[this.bufferLength++] = n[s++], i--, this.bufferLength === e.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
      }, r.prototype.digest = function() {
        if (!this.finished) {
          var n = this.bytesHashed * 8, s = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), i = this.bufferLength;
          if (s.setUint8(this.bufferLength++, 128), i % e.BLOCK_SIZE >= e.BLOCK_SIZE - 8) {
            for (var o = this.bufferLength; o < e.BLOCK_SIZE; o++)
              s.setUint8(o, 0);
            this.hashBuffer(), this.bufferLength = 0;
          }
          for (var o = this.bufferLength; o < e.BLOCK_SIZE - 8; o++)
            s.setUint8(o, 0);
          s.setUint32(e.BLOCK_SIZE - 8, Math.floor(n / 4294967296), true), s.setUint32(e.BLOCK_SIZE - 4, n), this.hashBuffer(), this.finished = true;
        }
        for (var a = new Uint8Array(e.DIGEST_LENGTH), o = 0; o < 8; o++)
          a[o * 4] = this.state[o] >>> 24 & 255, a[o * 4 + 1] = this.state[o] >>> 16 & 255, a[o * 4 + 2] = this.state[o] >>> 8 & 255, a[o * 4 + 3] = this.state[o] >>> 0 & 255;
        return a;
      }, r.prototype.hashBuffer = function() {
        for (var n = this, s = n.buffer, i = n.state, o = i[0], a = i[1], c2 = i[2], u = i[3], d = i[4], h = i[5], p = i[6], y = i[7], g = 0; g < e.BLOCK_SIZE; g++) {
          if (g < 16)
            this.temp[g] = (s[g * 4] & 255) << 24 | (s[g * 4 + 1] & 255) << 16 | (s[g * 4 + 2] & 255) << 8 | s[g * 4 + 3] & 255;
          else {
            var A = this.temp[g - 2], B = (A >>> 17 | A << 15) ^ (A >>> 19 | A << 13) ^ A >>> 10;
            A = this.temp[g - 15];
            var fe = (A >>> 7 | A << 25) ^ (A >>> 18 | A << 14) ^ A >>> 3;
            this.temp[g] = (B + this.temp[g - 7] | 0) + (fe + this.temp[g - 16] | 0);
          }
          var se = (((d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7)) + (d & h ^ ~d & p) | 0) + (y + (e.KEY[g] + this.temp[g] | 0) | 0) | 0, Le = ((o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10)) + (o & a ^ o & c2 ^ a & c2) | 0;
          y = p, p = h, h = d, d = u + se | 0, u = c2, c2 = a, a = o, o = se + Le | 0;
        }
        i[0] += o, i[1] += a, i[2] += c2, i[3] += u, i[4] += d, i[5] += h, i[6] += p, i[7] += y;
      }, r;
    }()
  );
  return ct.RawSha256 = t, ct;
}
var hs;
function kl() {
  if (hs)
    return at;
  hs = 1, Object.defineProperty(at, "__esModule", { value: true }), at.Sha256 = void 0;
  var e = ye, t = yo(), r = Tl(), n = Pe(), s = (
    /** @class */
    function() {
      function o(a) {
        this.secret = a, this.hash = new r.RawSha256(), this.reset();
      }
      return o.prototype.update = function(a) {
        if (!((0, n.isEmptyData)(a) || this.error))
          try {
            this.hash.update((0, n.convertToBuffer)(a));
          } catch (c2) {
            this.error = c2;
          }
      }, o.prototype.digestSync = function() {
        if (this.error)
          throw this.error;
        return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
      }, o.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(a) {
            return [2, this.digestSync()];
          });
        });
      }, o.prototype.reset = function() {
        if (this.hash = new r.RawSha256(), this.secret) {
          this.outer = new r.RawSha256();
          var a = i(this.secret), c2 = new Uint8Array(t.BLOCK_SIZE);
          c2.set(a);
          for (var u = 0; u < t.BLOCK_SIZE; u++)
            a[u] ^= 54, c2[u] ^= 92;
          this.hash.update(a), this.outer.update(c2);
          for (var u = 0; u < a.byteLength; u++)
            a[u] = 0;
        }
      }, o;
    }()
  );
  at.Sha256 = s;
  function i(o) {
    var a = (0, n.convertToBuffer)(o);
    if (a.byteLength > t.BLOCK_SIZE) {
      var c2 = new r.RawSha256();
      c2.update(a), a = c2.digest();
    }
    var u = new Uint8Array(t.BLOCK_SIZE);
    return u.set(a), u;
  }
  return at;
}
var ps;
function Pl() {
  return ps || (ps = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = ye;
    t.__exportStar(kl(), e);
  }(or)), or;
}
var gs;
function Nl() {
  if (gs)
    return nt;
  gs = 1, Object.defineProperty(nt, "__esModule", { value: true }), nt.Sha256 = void 0;
  var e = go(), t = mo(), r = Pl(), n = lo(), s = fo(), i = Ge, o = Pe(), a = (
    /** @class */
    function() {
      function c2(u) {
        (0, n.supportsWebCrypto)((0, i.locateWindow)()) ? this.hash = new t.Sha256(u) : (0, s.isMsWindow)((0, i.locateWindow)()) ? this.hash = new e.Sha256(u) : this.hash = new r.Sha256(u);
      }
      return c2.prototype.update = function(u, d) {
        this.hash.update((0, o.convertToBuffer)(u));
      }, c2.prototype.digest = function() {
        return this.hash.digest();
      }, c2.prototype.reset = function() {
        this.hash.reset();
      }, c2;
    }()
  );
  return nt.Sha256 = a, nt;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.WebCryptoSha256 = e.Ie11Sha256 = void 0;
  var t = ye;
  t.__exportStar(Nl(), e);
  var r = go();
  Object.defineProperty(e, "Ie11Sha256", { enumerable: true, get: function() {
    return r.Sha256;
  } });
  var n = mo();
  Object.defineProperty(e, "WebCryptoSha256", { enumerable: true, get: function() {
    return n.Sha256;
  } });
})(ho);
var Ol = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var bo = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var U = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var re = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var _e = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
var m = class _m {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 0 && n[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 1 && n[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(t, r, n) {
    if (t.test(r))
      return n;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(t, r, n = false) {
    const s = _m.getVersionPrecision(t), i = _m.getVersionPrecision(r);
    let o = Math.max(s, i), a = 0;
    const c2 = _m.map([t, r], (u) => {
      const d = o - _m.getVersionPrecision(u), h = u + new Array(d + 1).join(".0");
      return _m.map(h.split("."), (p) => new Array(20 - p.length).join("0") + p).reverse();
    });
    for (n && (a = o - Math.min(s, i)), o -= 1; o >= a; ) {
      if (c2[0][o] > c2[1][o])
        return 1;
      if (c2[0][o] === c2[1][o]) {
        if (o === a)
          return 0;
        o -= 1;
      } else if (c2[0][o] < c2[1][o])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(t, r) {
    const n = [];
    let s;
    if (Array.prototype.map)
      return Array.prototype.map.call(t, r);
    for (s = 0; s < t.length; s += 1)
      n.push(r(t[s]));
    return n;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(t, r) {
    let n, s;
    if (Array.prototype.find)
      return Array.prototype.find.call(t, r);
    for (n = 0, s = t.length; n < s; n += 1) {
      const i = t[n];
      if (r(i, n))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(t, ...r) {
    const n = t;
    let s, i;
    if (Object.assign)
      return Object.assign(t, ...r);
    for (s = 0, i = r.length; s < i; s += 1) {
      const o = r[s];
      typeof o == "object" && o !== null && Object.keys(o).forEach((c2) => {
        n[c2] = o[c2];
      });
    }
    return t;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(t) {
    return Ol[t];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(t) {
    return bo[t] || "";
  }
};
var M = /version\/(\d+(\.?_?\d+)+)/i;
var Ml = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(e) {
      const t = {
        name: "Googlebot"
      }, r = m.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = m.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(e) {
      const t = {
        name: "Samsung Internet for Android"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Whale/i],
    describe(e) {
      const t = {
        name: "NAVER Whale Browser"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(e) {
      const t = {
        name: "MZ Browser"
      }, r = m.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/focus/i],
    describe(e) {
      const t = {
        name: "Focus"
      }, r = m.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/swing/i],
    describe(e) {
      const t = {
        name: "Swing"
      }, r = m.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/coast/i],
    describe(e) {
      const t = {
        name: "Opera Coast"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(e) {
      const t = {
        name: "Opera Touch"
      }, r = m.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/yabrowser/i],
    describe(e) {
      const t = {
        name: "Yandex Browser"
      }, r = m.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(e) {
      const t = {
        name: "UC Browser"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(e) {
      const t = {
        name: "Maxthon"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/epiphany/i],
    describe(e) {
      const t = {
        name: "Epiphany"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/puffin/i],
    describe(e) {
      const t = {
        name: "Puffin"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sleipnir/i],
    describe(e) {
      const t = {
        name: "Sleipnir"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/k-meleon/i],
    describe(e) {
      const t = {
        name: "K-Meleon"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/micromessenger/i],
    describe(e) {
      const t = {
        name: "WeChat"
      }, r = m.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(e) {
      const t = {
        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
      }, r = m.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/msie|trident/i],
    describe(e) {
      const t = {
        name: "Internet Explorer"
      }, r = m.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/\sedg\//i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = m.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = m.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/vivaldi/i],
    describe(e) {
      const t = {
        name: "Vivaldi"
      }, r = m.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/seamonkey/i],
    describe(e) {
      const t = {
        name: "SeaMonkey"
      }, r = m.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sailfish/i],
    describe(e) {
      const t = {
        name: "Sailfish"
      }, r = m.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/silk/i],
    describe(e) {
      const t = {
        name: "Amazon Silk"
      }, r = m.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/phantom/i],
    describe(e) {
      const t = {
        name: "PhantomJS"
      }, r = m.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/slimerjs/i],
    describe(e) {
      const t = {
        name: "SlimerJS"
      }, r = m.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = {
        name: "BlackBerry"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = {
        name: "WebOS Browser"
      }, r = m.getFirstMatch(M, e) || m.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/bada/i],
    describe(e) {
      const t = {
        name: "Bada"
      }, r = m.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/tizen/i],
    describe(e) {
      const t = {
        name: "Tizen"
      }, r = m.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qupzilla/i],
    describe(e) {
      const t = {
        name: "QupZilla"
      }, r = m.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(e) {
      const t = {
        name: "Firefox"
      }, r = m.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/electron/i],
    describe(e) {
      const t = {
        name: "Electron"
      }, r = m.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(e) {
      const t = {
        name: "Miui"
      }, r = m.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chromium/i],
    describe(e) {
      const t = {
        name: "Chromium"
      }, r = m.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(e) {
      const t = {
        name: "Chrome"
      }, r = m.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/GSA/i],
    describe(e) {
      const t = {
        name: "Google Search"
      }, r = m.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Android Browser */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = {
        name: "Android Browser"
      }, r = m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(e) {
      const t = {
        name: "PlayStation 4"
      }, r = m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(e) {
      const t = {
        name: "Safari"
      }, r = m.getFirstMatch(M, e);
      return r && (t.version = r), t;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(e) {
      const t = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, s = e.search("\\(") !== -1 ? r : t;
      return {
        name: m.getFirstMatch(s, e),
        version: m.getSecondMatch(s, e)
      };
    }
  }
];
var Fl = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(e) {
      const t = m.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
      return {
        name: re.Roku,
        version: t
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(e) {
      const t = m.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
      return {
        name: re.WindowsPhone,
        version: t
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(e) {
      const t = m.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), r = m.getWindowsVersionName(t);
      return {
        name: re.Windows,
        version: t,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(e) {
      const t = {
        name: re.iOS
      }, r = m.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
      return r && (t.version = r), t;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(e) {
      const t = m.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), r = m.getMacOSVersionName(t), n = {
        name: re.MacOS,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(e) {
      const t = m.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
      return {
        name: re.iOS,
        version: t
      };
    }
  },
  /* Android */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = m.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), r = m.getAndroidVersionName(t), n = {
        name: re.Android,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = m.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), r = {
        name: re.WebOS
      };
      return t && t.length && (r.version = t), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = m.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || m.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || m.getFirstMatch(/\bbb(\d+)/i, e);
      return {
        name: re.BlackBerry,
        version: t
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(e) {
      const t = m.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
      return {
        name: re.Bada,
        version: t
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(e) {
      const t = m.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: re.Tizen,
        version: t
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: re.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: re.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(e) {
      const t = m.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: re.PlayStation4,
        version: t
      };
    }
  }
];
var Il = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(e) {
      const t = m.getFirstMatch(/(can-l01)/i, e) && "Nova", r = {
        type: U.mobile,
        vendor: "Huawei"
      };
      return t && (r.model = t), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: U.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: U.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: U.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: U.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: U.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: U.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(e) {
      const t = e.test(/ipod|iphone/i), r = e.test(/like (ipod|iphone)/i);
      return t && !r;
    },
    describe(e) {
      const t = m.getFirstMatch(/(ipod|iphone)/i, e);
      return {
        type: U.mobile,
        vendor: "Apple",
        model: t
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: U.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: U.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(e) {
      return e.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: U.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(e) {
      return e.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: U.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(e) {
      return e.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: U.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(e) {
      const t = Number(String(e.getOSVersion()).split(".")[0]);
      return e.getOSName(true) === "android" && t >= 3;
    },
    describe() {
      return {
        type: U.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(e) {
      return e.getOSName(true) === "android";
    },
    describe() {
      return {
        type: U.mobile
      };
    }
  },
  /* desktop */
  {
    test(e) {
      return e.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: U.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(e) {
      return e.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: U.desktop
      };
    }
  },
  /* Linux */
  {
    test(e) {
      return e.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: U.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(e) {
      return e.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: U.tv
      };
    }
  },
  /* Roku */
  {
    test(e) {
      return e.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: U.tv
      };
    }
  }
];
var Dl = [
  /* EdgeHTML */
  {
    test(e) {
      return e.getBrowserName(true) === "microsoft edge";
    },
    describe(e) {
      if (/\sedg\//i.test(e))
        return {
          name: _e.Blink
        };
      const r = m.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
      return {
        name: _e.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(e) {
      const t = {
        name: _e.Trident
      }, r = m.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Presto */
  {
    test(e) {
      return e.test(/presto/i);
    },
    describe(e) {
      const t = {
        name: _e.Presto
      }, r = m.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Gecko */
  {
    test(e) {
      const t = e.test(/gecko/i), r = e.test(/like gecko/i);
      return t && !r;
    },
    describe(e) {
      const t = {
        name: _e.Gecko
      }, r = m.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: _e.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(e) {
      const t = {
        name: _e.WebKit
      }, r = m.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  }
];
var ms = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(t, r = false) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = t, this.parsedResult = {}, r !== true && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(t) {
    return t.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = m.find(Ml, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(t) {
    return t ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const t = m.find(Fl, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(t) {
    const { name: r } = this.getOS();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(t = false) {
    const { type: r } = this.getPlatform();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = m.find(Il, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(t) {
    return t ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const t = m.find(Dl, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return m.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(t) {
    const r = {};
    let n = 0;
    const s = {};
    let i = 0;
    if (Object.keys(t).forEach((a) => {
      const c2 = t[a];
      typeof c2 == "string" ? (s[a] = c2, i += 1) : typeof c2 == "object" && (r[a] = c2, n += 1);
    }), n > 0) {
      const a = Object.keys(r), c2 = m.find(a, (d) => this.isOS(d));
      if (c2) {
        const d = this.satisfies(r[c2]);
        if (d !== void 0)
          return d;
      }
      const u = m.find(
        a,
        (d) => this.isPlatform(d)
      );
      if (u) {
        const d = this.satisfies(r[u]);
        if (d !== void 0)
          return d;
      }
    }
    if (i > 0) {
      const a = Object.keys(s), c2 = m.find(a, (u) => this.isBrowser(u, true));
      if (c2 !== void 0)
        return this.compareVersion(s[c2]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(t, r = false) {
    const n = this.getBrowserName().toLowerCase();
    let s = t.toLowerCase();
    const i = m.getBrowserTypeByAlias(s);
    return r && i && (s = i.toLowerCase()), s === n;
  }
  compareVersion(t) {
    let r = [0], n = t, s = false;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return t[0] === ">" || t[0] === "<" ? (n = t.substr(1), t[1] === "=" ? (s = true, n = t.substr(2)) : r = [], t[0] === ">" ? r.push(1) : r.push(-1)) : t[0] === "=" ? n = t.substr(1) : t[0] === "~" && (s = true, n = t.substr(1)), r.indexOf(
        m.compareVersions(i, n, s)
      ) > -1;
  }
  isOS(t) {
    return this.getOSName(true) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(true) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(true) === String(t).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(t, r = false) {
    return this.isBrowser(t, r) || this.isOS(t) || this.isPlatform(t);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(t = []) {
    return t.some((r) => this.is(r));
  }
};
var wo = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(t, r = false) {
    if (typeof t != "string")
      throw new Error("UserAgent should be a string");
    return new ms(t, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(t) {
    return new ms(t).getResult();
  }
  static get BROWSER_MAP() {
    return bo;
  }
  static get ENGINE_MAP() {
    return _e;
  }
  static get OS_MAP() {
    return re;
  }
  static get PLATFORMS_MAP() {
    return U;
  }
};
var Ul = ({ serviceId: e, clientVersion: t }) => async () => {
  var s, i, o, a, c2;
  const r = typeof window < "u" && ((s = window == null ? void 0 : window.navigator) != null && s.userAgent) ? wo.parse(window.navigator.userAgent) : void 0, n = [
    ["aws-sdk-js", t],
    ["ua", "2.0"],
    [`os/${((i = r == null ? void 0 : r.os) == null ? void 0 : i.name) || "other"}`, (o = r == null ? void 0 : r.os) == null ? void 0 : o.version],
    ["lang/js"],
    ["md/browser", `${((a = r == null ? void 0 : r.browser) == null ? void 0 : a.name) ?? "unknown"}_${((c2 = r == null ? void 0 : r.browser) == null ? void 0 : c2.version) ?? "unknown"}`]
  ];
  return e && n.push([`api/${e}`, t]), n;
};
function Ll(e) {
  let t = 0, r = 0, n = null, s = null;
  const i = (a) => {
    if (typeof a != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + a);
    t = a, r = 4, n = new Uint8Array(a), new DataView(n.buffer).setUint32(0, a, false);
  }, o = async function* () {
    const a = e[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: c2, done: u } = await a.next();
      if (u) {
        if (t)
          if (t === r)
            yield n;
          else
            throw new Error("Truncated event message received.");
        else
          return;
        return;
      }
      const d = c2.length;
      let h = 0;
      for (; h < d; ) {
        if (!n) {
          const y = d - h;
          s || (s = new Uint8Array(4));
          const g = Math.min(4 - r, y);
          if (s.set(c2.slice(h, h + g), r), r += g, h += g, r < 4)
            break;
          i(new DataView(s.buffer).getUint32(0, false)), s = null;
        }
        const p = Math.min(t - r, d - h);
        n.set(c2.slice(h, h + p), r), r += p, h += p, t && t === r && (yield n, n = null, t = 0, r = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: o
  };
}
function $l(e, t) {
  return async function(r) {
    const { value: n } = r.headers[":message-type"];
    if (n === "error") {
      const s = new Error(r.headers[":error-message"].value || "UnknownError");
      throw s.name = r.headers[":error-code"].value, s;
    } else if (n === "exception") {
      const s = r.headers[":exception-type"].value, i = { [s]: r }, o = await e(i);
      if (o.$unknown) {
        const a = new Error(t(r.body));
        throw a.name = s, a;
      }
      throw o[s];
    } else if (n === "event") {
      const s = {
        [r.headers[":event-type"].value]: r
      }, i = await e(s);
      return i.$unknown ? void 0 : i;
    } else
      throw Error(`Unrecognizable event type: ${r.headers[":event-type"].value}`);
  };
}
var Hl = class {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.eventStreamCodec = new lc(t, r), this.utfEncoder = t;
  }
  deserialize(t, r) {
    const n = Ll(t);
    return new pc({
      messageStream: new fc({ inputStream: n, decoder: this.eventStreamCodec }),
      deserializer: $l(r, this.utfEncoder)
    });
  }
  serialize(t, r) {
    return new hc({
      messageStream: new gc({ inputStream: t, serializer: r }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
};
var jl = (e) => ({
  [Symbol.asyncIterator]: async function* () {
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: r, value: n } = await t.read();
        if (r)
          return;
        yield n;
      }
    } finally {
      t.releaseLock();
    }
  }
});
var ql = (e) => {
  const t = e[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(r) {
      const { done: n, value: s } = await t.next();
      if (n)
        return r.close();
      r.enqueue(s);
    }
  });
};
var zl = class {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.universalMarshaller = new Hl({
      utf8Decoder: r,
      utf8Encoder: t
    });
  }
  deserialize(t, r) {
    const n = Vl(t) ? jl(t) : t;
    return this.universalMarshaller.deserialize(n, r);
  }
  serialize(t, r) {
    const n = this.universalMarshaller.serialize(t, r);
    return typeof ReadableStream == "function" ? ql(n) : n;
  }
};
var Vl = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream;
var Gl = (e) => new zl(e);
function Wl(e, t, r = 1024 * 1024) {
  return new Promise((n, s) => {
    const i = new FileReader();
    i.addEventListener("error", s), i.addEventListener("abort", s);
    const o = e.size;
    let a = 0;
    function c2() {
      if (a >= o) {
        n();
        return;
      }
      i.readAsArrayBuffer(e.slice(a, Math.min(o, a + r)));
    }
    i.addEventListener("load", (u) => {
      const d = u.target.result;
      t(new Uint8Array(d)), a += d.byteLength, c2();
    }), c2();
  });
}
var Kl = async function(t, r) {
  const n = new t();
  return await Wl(r, (s) => {
    n.update(s);
  }), n.digest();
};
var Xl = (e) => () => Promise.reject(e);
var ve = 64;
var Zl = 16;
var Yl = [1732584193, 4023233417, 2562383102, 271733878];
var Ql = class {
  constructor() {
    this.reset();
  }
  update(t) {
    if (Jl(t))
      return;
    if (this.finished)
      throw new Error("Attempted to update an already finished hash.");
    const r = ef(t);
    let n = 0, { byteLength: s } = r;
    for (this.bytesHashed += s; s > 0; )
      this.buffer.setUint8(this.bufferLength++, r[n++]), s--, this.bufferLength === ve && (this.hashBuffer(), this.bufferLength = 0);
  }
  async digest() {
    if (!this.finished) {
      const { buffer: r, bufferLength: n, bytesHashed: s } = this, i = s * 8;
      if (r.setUint8(this.bufferLength++, 128), n % ve >= ve - 8) {
        for (let o = this.bufferLength; o < ve; o++)
          r.setUint8(o, 0);
        this.hashBuffer(), this.bufferLength = 0;
      }
      for (let o = this.bufferLength; o < ve - 8; o++)
        r.setUint8(o, 0);
      r.setUint32(ve - 8, i >>> 0, true), r.setUint32(ve - 4, Math.floor(i / 4294967296), true), this.hashBuffer(), this.finished = true;
    }
    const t = new DataView(new ArrayBuffer(Zl));
    for (let r = 0; r < 4; r++)
      t.setUint32(r * 4, this.state[r], true);
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  hashBuffer() {
    const { buffer: t, state: r } = this;
    let n = r[0], s = r[1], i = r[2], o = r[3];
    n = Y(n, s, i, o, t.getUint32(0, true), 7, 3614090360), o = Y(o, n, s, i, t.getUint32(4, true), 12, 3905402710), i = Y(i, o, n, s, t.getUint32(8, true), 17, 606105819), s = Y(s, i, o, n, t.getUint32(12, true), 22, 3250441966), n = Y(n, s, i, o, t.getUint32(16, true), 7, 4118548399), o = Y(o, n, s, i, t.getUint32(20, true), 12, 1200080426), i = Y(i, o, n, s, t.getUint32(24, true), 17, 2821735955), s = Y(s, i, o, n, t.getUint32(28, true), 22, 4249261313), n = Y(n, s, i, o, t.getUint32(32, true), 7, 1770035416), o = Y(o, n, s, i, t.getUint32(36, true), 12, 2336552879), i = Y(i, o, n, s, t.getUint32(40, true), 17, 4294925233), s = Y(s, i, o, n, t.getUint32(44, true), 22, 2304563134), n = Y(n, s, i, o, t.getUint32(48, true), 7, 1804603682), o = Y(o, n, s, i, t.getUint32(52, true), 12, 4254626195), i = Y(i, o, n, s, t.getUint32(56, true), 17, 2792965006), s = Y(s, i, o, n, t.getUint32(60, true), 22, 1236535329), n = Q(n, s, i, o, t.getUint32(4, true), 5, 4129170786), o = Q(o, n, s, i, t.getUint32(24, true), 9, 3225465664), i = Q(i, o, n, s, t.getUint32(44, true), 14, 643717713), s = Q(s, i, o, n, t.getUint32(0, true), 20, 3921069994), n = Q(n, s, i, o, t.getUint32(20, true), 5, 3593408605), o = Q(o, n, s, i, t.getUint32(40, true), 9, 38016083), i = Q(i, o, n, s, t.getUint32(60, true), 14, 3634488961), s = Q(s, i, o, n, t.getUint32(16, true), 20, 3889429448), n = Q(n, s, i, o, t.getUint32(36, true), 5, 568446438), o = Q(o, n, s, i, t.getUint32(56, true), 9, 3275163606), i = Q(i, o, n, s, t.getUint32(12, true), 14, 4107603335), s = Q(s, i, o, n, t.getUint32(32, true), 20, 1163531501), n = Q(n, s, i, o, t.getUint32(52, true), 5, 2850285829), o = Q(o, n, s, i, t.getUint32(8, true), 9, 4243563512), i = Q(i, o, n, s, t.getUint32(28, true), 14, 1735328473), s = Q(s, i, o, n, t.getUint32(48, true), 20, 2368359562), n = J(n, s, i, o, t.getUint32(20, true), 4, 4294588738), o = J(o, n, s, i, t.getUint32(32, true), 11, 2272392833), i = J(i, o, n, s, t.getUint32(44, true), 16, 1839030562), s = J(s, i, o, n, t.getUint32(56, true), 23, 4259657740), n = J(n, s, i, o, t.getUint32(4, true), 4, 2763975236), o = J(o, n, s, i, t.getUint32(16, true), 11, 1272893353), i = J(i, o, n, s, t.getUint32(28, true), 16, 4139469664), s = J(s, i, o, n, t.getUint32(40, true), 23, 3200236656), n = J(n, s, i, o, t.getUint32(52, true), 4, 681279174), o = J(o, n, s, i, t.getUint32(0, true), 11, 3936430074), i = J(i, o, n, s, t.getUint32(12, true), 16, 3572445317), s = J(s, i, o, n, t.getUint32(24, true), 23, 76029189), n = J(n, s, i, o, t.getUint32(36, true), 4, 3654602809), o = J(o, n, s, i, t.getUint32(48, true), 11, 3873151461), i = J(i, o, n, s, t.getUint32(60, true), 16, 530742520), s = J(s, i, o, n, t.getUint32(8, true), 23, 3299628645), n = ee(n, s, i, o, t.getUint32(0, true), 6, 4096336452), o = ee(o, n, s, i, t.getUint32(28, true), 10, 1126891415), i = ee(i, o, n, s, t.getUint32(56, true), 15, 2878612391), s = ee(s, i, o, n, t.getUint32(20, true), 21, 4237533241), n = ee(n, s, i, o, t.getUint32(48, true), 6, 1700485571), o = ee(o, n, s, i, t.getUint32(12, true), 10, 2399980690), i = ee(i, o, n, s, t.getUint32(40, true), 15, 4293915773), s = ee(s, i, o, n, t.getUint32(4, true), 21, 2240044497), n = ee(n, s, i, o, t.getUint32(32, true), 6, 1873313359), o = ee(o, n, s, i, t.getUint32(60, true), 10, 4264355552), i = ee(i, o, n, s, t.getUint32(24, true), 15, 2734768916), s = ee(s, i, o, n, t.getUint32(52, true), 21, 1309151649), n = ee(n, s, i, o, t.getUint32(16, true), 6, 4149444226), o = ee(o, n, s, i, t.getUint32(44, true), 10, 3174756917), i = ee(i, o, n, s, t.getUint32(8, true), 15, 718787259), s = ee(s, i, o, n, t.getUint32(36, true), 21, 3951481745), r[0] = n + r[0] & 4294967295, r[1] = s + r[1] & 4294967295, r[2] = i + r[2] & 4294967295, r[3] = o + r[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(Yl), this.buffer = new DataView(new ArrayBuffer(ve)), this.bufferLength = 0, this.bytesHashed = 0, this.finished = false;
  }
};
function Ut(e, t, r, n, s, i) {
  return t = (t + e & 4294967295) + (n + i & 4294967295) & 4294967295, (t << s | t >>> 32 - s) + r & 4294967295;
}
function Y(e, t, r, n, s, i, o) {
  return Ut(t & r | ~t & n, e, t, s, i, o);
}
function Q(e, t, r, n, s, i, o) {
  return Ut(t & n | r & ~n, e, t, s, i, o);
}
function J(e, t, r, n, s, i, o) {
  return Ut(t ^ r ^ n, e, t, s, i, o);
}
function ee(e, t, r, n, s, i, o) {
  return Ut(r ^ (t | ~n), e, t, s, i, o);
}
function Jl(e) {
  return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
}
function ef(e) {
  return typeof e == "string" ? xt(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e);
}
var tf = (e) => {
  if (typeof e == "string") {
    let t = e.length;
    for (let r = t - 1; r >= 0; r--) {
      const n = e.charCodeAt(r);
      n > 127 && n <= 2047 ? t++ : n > 2047 && n <= 65535 && (t += 2), n >= 56320 && n <= 57343 && r--;
    }
    return t;
  } else {
    if (typeof e.byteLength == "number")
      return e.byteLength;
    if (typeof e.size == "number")
      return e.size;
  }
  throw new Error(`Body Length computation failed for ${e}`);
};
var rf = class {
  constructor(t) {
    this.sigv4Signer = new Ir(t), this.signerOptions = t;
  }
  async sign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(t, r);
    }
    return this.sigv4Signer.sign(t, r);
  }
  async presign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(t, r);
    }
    return this.sigv4Signer.presign(t, r);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let t;
      try {
        if (t = typeof __require == "function" && (init_dist_es26(), __toCommonJS(dist_es_exports2)).CrtSignerV4, typeof t != "function")
          throw new Error();
      } catch (r) {
        throw r.message = `${r.message}
Please check if you have installed "@aws-sdk/signature-v4-crt" package explicitly. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`, r;
      }
      this.sigv4aSigner = new t({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};
var Jr = "required";
var l = "type";
var f = "conditions";
var b = "fn";
var w = "argv";
var T = "ref";
var X = "assign";
var v = "url";
var C = "properties";
var Ee = "authSchemes";
var xe = "disableDoubleEncoding";
var Se = "signingName";
var Ne = "signingRegion";
var R = "headers";
var ys = false;
var be = true;
var we = "isSet";
var E = "tree";
var te = "booleanEquals";
var S = "error";
var Ot = "aws.partition";
var D = "stringEquals";
var $ = "getAttr";
var le = "name";
var ut = "substring";
var Ao = "hardwareType";
var Eo = "regionPrefix";
var bs = "bucketAliasSuffix";
var Lr = "outpostId";
var Ue = "isValidHostLabel";
var ge = "not";
var xo = "parseURL";
var en = "s3-outposts";
var x = "endpoint";
var ws = "aws.isVirtualHostableS3Bucket";
var ze = "s3";
var So = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var vo = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var Co = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var As = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var Ro = "aws.parseArn";
var Bo = "bucketArn";
var _o = "arnType";
var Mt = "";
var tn = "s3-object-lambda";
var To = "accesspoint";
var rn = "accessPointName";
var Es = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var xs = "mrapPartition";
var Ss = "outpostType";
var vs = "arnPrefix";
var ko = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var Cs = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var $r = "{url#scheme}://{url#authority}{url#path}";
var Rs = "https://s3.{partitionResult#dnsSuffix}";
var ar = { [Jr]: false, [l]: "String" };
var $e = { [Jr]: true, default: false, [l]: "Boolean" };
var cr = { [Jr]: false, [l]: "Boolean" };
var pe = { [b]: te, [w]: [{ [T]: "Accelerate" }, true] };
var I = { [b]: te, [w]: [{ [T]: "UseFIPS" }, true] };
var F = { [b]: te, [w]: [{ [T]: "UseDualStack" }, true] };
var L = { [b]: we, [w]: [{ [T]: "Endpoint" }] };
var Po = { [b]: Ot, [w]: [{ [T]: "Region" }], [X]: "partitionResult" };
var Bs = { [b]: D, [w]: [{ [b]: $, [w]: [{ [T]: "partitionResult" }, le] }, "aws-cn"] };
var No = { [b]: we, [w]: [{ [T]: "Bucket" }] };
var Ae = { [T]: "Bucket" };
var _s = { [T]: Ao };
var Ts = { [f]: [{ [b]: ge, [w]: [L] }], [S]: "Expected a endpoint to be specified but no endpoint was found", [l]: S };
var _ = { [b]: ge, [w]: [L] };
var ne = { [b]: xo, [w]: [{ [T]: "Endpoint" }], [X]: "url" };
var Rt = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: en, [Ne]: "{Region}" }] };
var P = {};
var ur = { [b]: te, [w]: [{ [T]: "ForcePathStyle" }, false] };
var nf = { [T]: "ForcePathStyle" };
var H = { [b]: te, [w]: [{ [T]: "Accelerate" }, false] };
var z = { [b]: D, [w]: [{ [T]: "Region" }, "aws-global"] };
var V = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: ze, [Ne]: "us-east-1" }] };
var O = { [b]: ge, [w]: [z] };
var G = { [b]: te, [w]: [{ [T]: "UseGlobalEndpoint" }, true] };
var ks = { [v]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: ze, [Ne]: "{Region}" }] }, [R]: {} };
var q = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: ze, [Ne]: "{Region}" }] };
var W = { [b]: te, [w]: [{ [T]: "UseGlobalEndpoint" }, false] };
var N = { [b]: te, [w]: [{ [T]: "UseDualStack" }, false] };
var Ps = { [v]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var k = { [b]: te, [w]: [{ [T]: "UseFIPS" }, false] };
var Ns = { [v]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var Os = { [v]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var dr = { [b]: te, [w]: [{ [b]: $, [w]: [{ [T]: "url" }, "isIp"] }, true] };
var Oo = { [T]: "url" };
var lr = { [b]: te, [w]: [{ [b]: $, [w]: [Oo, "isIp"] }, false] };
var fr = { [v]: So, [C]: q, [R]: {} };
var Hr = { [v]: vo, [C]: q, [R]: {} };
var Ms = { [x]: Hr, [l]: x };
var hr = { [v]: Co, [C]: q, [R]: {} };
var Fs = { [v]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var Bt = { [S]: "Invalid region: region was not a valid DNS name.", [l]: S };
var oe = { [T]: Bo };
var Mo = { [T]: _o };
var pr = { [b]: $, [w]: [oe, "service"] };
var nn = { [T]: rn };
var Is = { [f]: [F], [S]: "S3 Object Lambda does not support Dual-stack", [l]: S };
var Ds = { [f]: [pe], [S]: "S3 Object Lambda does not support S3 Accelerate", [l]: S };
var Us = { [f]: [{ [b]: we, [w]: [{ [T]: "DisableAccessPoints" }] }, { [b]: te, [w]: [{ [T]: "DisableAccessPoints" }, true] }], [S]: "Access points are not supported for this operation", [l]: S };
var gr = { [f]: [{ [b]: we, [w]: [{ [T]: "UseArnRegion" }] }, { [b]: te, [w]: [{ [T]: "UseArnRegion" }, false] }, { [b]: ge, [w]: [{ [b]: D, [w]: [{ [b]: $, [w]: [oe, "region"] }, "{Region}"] }] }], [S]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [l]: S };
var Fo = { [b]: $, [w]: [{ [T]: "bucketPartition" }, le] };
var Io = { [b]: $, [w]: [oe, "accountId"] };
var mr = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: tn, [Ne]: "{bucketArn#region}" }] };
var Ls = { [S]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [l]: S };
var yr = { [S]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [l]: S };
var br = { [S]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [l]: S };
var wr = { [S]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [l]: S };
var $s = { [S]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [l]: S };
var Hs = { [S]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [l]: S };
var dt = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: ze, [Ne]: "{bucketArn#region}" }] };
var js = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: en, [Ne]: "{bucketArn#region}" }] };
var qs = { [b]: Ro, [w]: [Ae] };
var zs = { [v]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: q, [R]: {} };
var Vs = { [v]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: q, [R]: {} };
var Gs = { [v]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: q, [R]: {} };
var Ar = { [v]: ko, [C]: q, [R]: {} };
var Ws = { [v]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: q, [R]: {} };
var Ks = { [T]: "UseObjectLambdaEndpoint" };
var Er = { [Ee]: [{ [xe]: true, [le]: "sigv4", [Se]: tn, [Ne]: "{Region}" }] };
var Xs = { [v]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var Zs = { [v]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var Ys = { [v]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var xr = { [v]: $r, [C]: q, [R]: {} };
var Qs = { [v]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [C]: q, [R]: {} };
var Sr = [{ [T]: "Region" }];
var sf = [{ [T]: "Endpoint" }];
var Js = [Ae];
var ei = [{ [b]: Ue, [w]: [{ [T]: Lr }, false] }];
var ti = [{ [b]: D, [w]: [{ [T]: Eo }, "beta"] }];
var lt = [L, ne];
var ri = [No];
var Ce = [Po];
var ni = [{ [b]: Ue, [w]: [{ [T]: "Region" }, false] }];
var Re = [{ [b]: D, [w]: [{ [T]: "Region" }, "us-east-1"] }];
var vr = [{ [b]: D, [w]: [Mo, To] }];
var si = [{ [b]: $, [w]: [oe, "resourceId[1]"], [X]: rn }, { [b]: ge, [w]: [{ [b]: D, [w]: [nn, Mt] }] }];
var of = [oe, "resourceId[1]"];
var ii = [F];
var Cr = [pe];
var Rr = [{ [b]: ge, [w]: [{ [b]: D, [w]: [{ [b]: $, [w]: [oe, "region"] }, Mt] }] }];
var oi = [{ [b]: ge, [w]: [{ [b]: we, [w]: [{ [b]: $, [w]: [oe, "resourceId[2]"] }] }] }];
var af = [oe, "resourceId[2]"];
var Br = [{ [b]: Ot, [w]: [{ [b]: $, [w]: [oe, "region"] }], [X]: "bucketPartition" }];
var ai = [{ [b]: D, [w]: [Fo, { [b]: $, [w]: [{ [T]: "partitionResult" }, le] }] }];
var _r = [{ [b]: Ue, [w]: [{ [b]: $, [w]: [oe, "region"] }, true] }];
var Tr = [{ [b]: Ue, [w]: [Io, false] }];
var ci = [{ [b]: Ue, [w]: [nn, false] }];
var _t = [I];
var ui = [{ [b]: Ue, [w]: [{ [T]: "Region" }, true] }];
var cf = { version: "1.0", parameters: { Bucket: ar, Region: ar, UseFIPS: $e, UseDualStack: $e, Endpoint: ar, ForcePathStyle: $e, Accelerate: $e, UseGlobalEndpoint: $e, UseObjectLambdaEndpoint: cr, DisableAccessPoints: cr, DisableMultiRegionAccessPoints: $e, UseArnRegion: cr }, rules: [{ [f]: [{ [b]: we, [w]: Sr }], [l]: E, rules: [{ [f]: [pe, I], error: "Accelerate cannot be used with FIPS", [l]: S }, { [f]: [F, L], error: "Cannot set dual-stack in combination with a custom endpoint.", [l]: S }, { [f]: [L, I], error: "A custom endpoint cannot be combined with FIPS", [l]: S }, { [f]: [L, pe], error: "A custom endpoint cannot be combined with S3 Accelerate", [l]: S }, { [f]: [I, Po, Bs], error: "Partition does not support FIPS", [l]: S }, { [f]: [No, { [b]: ut, [w]: [Ae, 49, 50, be], [X]: Ao }, { [b]: ut, [w]: [Ae, 8, 12, be], [X]: Eo }, { [b]: ut, [w]: [Ae, 0, 7, be], [X]: bs }, { [b]: ut, [w]: [Ae, 32, 49, be], [X]: Lr }, { [b]: Ot, [w]: Sr, [X]: "regionPartition" }, { [b]: D, [w]: [{ [T]: bs }, "--op-s3"] }], [l]: E, rules: [{ [f]: ei, [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [_s, "e"] }], [l]: E, rules: [{ [f]: ti, [l]: E, rules: [Ts, { [f]: lt, endpoint: { [v]: "https://{Bucket}.ec2.{url#authority}", [C]: Rt, [R]: P }, [l]: x }] }, { endpoint: { [v]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: Rt, [R]: P }, [l]: x }] }, { [f]: [{ [b]: D, [w]: [_s, "o"] }], [l]: E, rules: [{ [f]: ti, [l]: E, rules: [Ts, { [f]: lt, endpoint: { [v]: "https://{Bucket}.op-{outpostId}.{url#authority}", [C]: Rt, [R]: P }, [l]: x }] }, { endpoint: { [v]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: Rt, [R]: P }, [l]: x }] }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [l]: S }] }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [l]: S }] }, { [f]: ri, [l]: E, rules: [{ [f]: [L, { [b]: ge, [w]: [{ [b]: we, [w]: [{ [b]: xo, [w]: sf }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [l]: S }, { [f]: [ur, { [b]: ws, [w]: [Ae, ys] }], [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ni, [l]: E, rules: [{ [f]: [pe, Bs], error: "S3 Accelerate cannot be used in this region", [l]: S }, { [f]: [F, I, H, _, z], endpoint: { [v]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [F, I, H, _, O, G], [l]: E, rules: [{ endpoint: ks, [l]: x }] }, { [f]: [F, I, H, _, O, W], endpoint: ks, [l]: x }, { [f]: [N, I, H, _, z], endpoint: { [v]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [N, I, H, _, O, G], [l]: E, rules: [{ endpoint: Ps, [l]: x }] }, { [f]: [N, I, H, _, O, W], endpoint: Ps, [l]: x }, { [f]: [F, k, pe, _, z], endpoint: { [v]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [F, k, pe, _, O, G], [l]: E, rules: [{ endpoint: Ns, [l]: x }] }, { [f]: [F, k, pe, _, O, W], endpoint: Ns, [l]: x }, { [f]: [F, k, H, _, z], endpoint: { [v]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [F, k, H, _, O, G], [l]: E, rules: [{ endpoint: Os, [l]: x }] }, { [f]: [F, k, H, _, O, W], endpoint: Os, [l]: x }, { [f]: [N, k, H, L, ne, dr, z], endpoint: { [v]: So, [C]: V, [R]: P }, [l]: x }, { [f]: [N, k, H, L, ne, lr, z], endpoint: { [v]: vo, [C]: V, [R]: P }, [l]: x }, { [f]: [N, k, H, L, ne, dr, O, G], [l]: E, rules: [{ [f]: Re, endpoint: fr, [l]: x }, { endpoint: fr, [l]: x }] }, { [f]: [N, k, H, L, ne, lr, O, G], [l]: E, rules: [{ [f]: Re, endpoint: Hr, [l]: x }, Ms] }, { [f]: [N, k, H, L, ne, dr, O, W], endpoint: fr, [l]: x }, { [f]: [N, k, H, L, ne, lr, O, W], endpoint: Hr, [l]: x }, { [f]: [N, k, pe, _, z], endpoint: { [v]: Co, [C]: V, [R]: P }, [l]: x }, { [f]: [N, k, pe, _, O, G], [l]: E, rules: [{ [f]: Re, endpoint: hr, [l]: x }, { endpoint: hr, [l]: x }] }, { [f]: [N, k, pe, _, O, W], endpoint: hr, [l]: x }, { [f]: [N, k, H, _, z], endpoint: { [v]: As, [C]: V, [R]: P }, [l]: x }, { [f]: [N, k, H, _, O, G], [l]: E, rules: [{ [f]: Re, endpoint: { [v]: As, [C]: q, [R]: P }, [l]: x }, { endpoint: Fs, [l]: x }] }, { [f]: [N, k, H, _, O, W], endpoint: Fs, [l]: x }] }, Bt] }] }, { [f]: [L, ne, { [b]: D, [w]: [{ [b]: $, [w]: [Oo, "scheme"] }, "http"] }, { [b]: ws, [w]: [Ae, be] }, ur, k, N, H], [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ni, [l]: E, rules: [Ms] }, Bt] }] }, { [f]: [ur, { [b]: Ro, [w]: Js, [X]: Bo }], [l]: E, rules: [{ [f]: [{ [b]: $, [w]: [oe, "resourceId[0]"], [X]: _o }, { [b]: ge, [w]: [{ [b]: D, [w]: [Mo, Mt] }] }], [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [pr, tn] }], [l]: E, rules: [{ [f]: vr, [l]: E, rules: [{ [f]: si, [l]: E, rules: [Is, Ds, { [f]: Rr, [l]: E, rules: [Us, { [f]: oi, [l]: E, rules: [gr, { [f]: Br, [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ai, [l]: E, rules: [{ [f]: _r, [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [Io, Mt] }], error: "Invalid ARN: Missing account id", [l]: S }, { [f]: Tr, [l]: E, rules: [{ [f]: ci, [l]: E, rules: [{ [f]: lt, endpoint: { [v]: Es, [C]: mr, [R]: P }, [l]: x }, { [f]: _t, endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: mr, [R]: P }, [l]: x }, { endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: mr, [R]: P }, [l]: x }] }, Ls] }, yr] }, br] }, wr] }] }] }, $s] }, { error: "Invalid ARN: bucket ARN is missing a region", [l]: S }] }, Hs] }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [l]: S }] }, { [f]: vr, [l]: E, rules: [{ [f]: si, [l]: E, rules: [{ [f]: Rr, [l]: E, rules: [{ [f]: vr, [l]: E, rules: [{ [f]: Rr, [l]: E, rules: [Us, { [f]: oi, [l]: E, rules: [gr, { [f]: Br, [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [Fo, "{partitionResult#name}"] }], [l]: E, rules: [{ [f]: _r, [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [pr, ze] }], [l]: E, rules: [{ [f]: Tr, [l]: E, rules: [{ [f]: ci, [l]: E, rules: [{ [f]: Cr, error: "Access Points do not support S3 Accelerate", [l]: S }, { [f]: [I, F], endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: dt, [R]: P }, [l]: x }, { [f]: [I, N], endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: dt, [R]: P }, [l]: x }, { [f]: [k, F], endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: dt, [R]: P }, [l]: x }, { [f]: [k, N, L, ne], endpoint: { [v]: Es, [C]: dt, [R]: P }, [l]: x }, { [f]: [k, N], endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: dt, [R]: P }, [l]: x }] }, Ls] }, yr] }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [l]: S }] }, br] }, wr] }] }] }, $s] }] }] }, { [f]: [{ [b]: Ue, [w]: [nn, be] }], [l]: E, rules: [{ [f]: ii, error: "S3 MRAP does not support dual-stack", [l]: S }, { [f]: _t, error: "S3 MRAP does not support FIPS", [l]: S }, { [f]: Cr, error: "S3 MRAP does not support S3 Accelerate", [l]: S }, { [f]: [{ [b]: te, [w]: [{ [T]: "DisableMultiRegionAccessPoints" }, be] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [l]: S }, { [f]: [{ [b]: Ot, [w]: Sr, [X]: xs }], [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [{ [b]: $, [w]: [{ [T]: xs }, le] }, { [b]: $, [w]: [oe, "partition"] }] }], [l]: E, rules: [{ endpoint: { [v]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [C]: { [Ee]: [{ [xe]: be, name: "sigv4a", [Se]: ze, signingRegionSet: ["*"] }] }, [R]: P }, [l]: x }] }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [l]: S }] }] }, { error: "Invalid Access Point Name", [l]: S }] }, Hs] }, { [f]: [{ [b]: D, [w]: [pr, en] }], [l]: E, rules: [{ [f]: ii, error: "S3 Outposts does not support Dual-stack", [l]: S }, { [f]: _t, error: "S3 Outposts does not support FIPS", [l]: S }, { [f]: Cr, error: "S3 Outposts does not support S3 Accelerate", [l]: S }, { [f]: [{ [b]: we, [w]: [{ [b]: $, [w]: [oe, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [l]: S }, { [f]: [{ [b]: $, [w]: of, [X]: Lr }], [l]: E, rules: [{ [f]: ei, [l]: E, rules: [gr, { [f]: Br, [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ai, [l]: E, rules: [{ [f]: _r, [l]: E, rules: [{ [f]: Tr, [l]: E, rules: [{ [f]: [{ [b]: $, [w]: af, [X]: Ss }], [l]: E, rules: [{ [f]: [{ [b]: $, [w]: [oe, "resourceId[3]"], [X]: rn }], [l]: E, rules: [{ [f]: [{ [b]: D, [w]: [{ [T]: Ss }, To] }], [l]: E, rules: [{ [f]: lt, endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [C]: js, [R]: P }, [l]: x }, { endpoint: { [v]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: js, [R]: P }, [l]: x }] }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [l]: S }] }, { error: "Invalid ARN: expected an access point name", [l]: S }] }, { error: "Invalid ARN: Expected a 4-component resource", [l]: S }] }, yr] }, br] }, wr] }] }] }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [l]: S }] }, { error: "Invalid ARN: The Outpost Id was not set", [l]: S }] }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [l]: S }] }, { error: "Invalid ARN: No ARN type specified", [l]: S }] }, { [f]: [{ [b]: ut, [w]: [Ae, 0, 4, ys], [X]: vs }, { [b]: D, [w]: [{ [T]: vs }, "arn:"] }, { [b]: ge, [w]: [{ [b]: we, [w]: [qs] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [l]: S }, { [f]: [{ [b]: te, [w]: [nf, be] }, qs], error: "Path-style addressing cannot be used with ARN buckets", [l]: S }, { [f]: [{ [b]: "uriEncode", [w]: Js, [X]: "uri_encoded_bucket" }], [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: [H], [l]: E, rules: [{ [f]: [F, _, I, z], endpoint: { [v]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [R]: P }, [l]: x }, { [f]: [F, _, I, O, G], [l]: E, rules: [{ endpoint: zs, [l]: x }] }, { [f]: [F, _, I, O, W], endpoint: zs, [l]: x }, { [f]: [N, _, I, z], endpoint: { [v]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [R]: P }, [l]: x }, { [f]: [N, _, I, O, G], [l]: E, rules: [{ endpoint: Vs, [l]: x }] }, { [f]: [N, _, I, O, W], endpoint: Vs, [l]: x }, { [f]: [F, _, k, z], endpoint: { [v]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [R]: P }, [l]: x }, { [f]: [F, _, k, O, G], [l]: E, rules: [{ endpoint: Gs, [l]: x }] }, { [f]: [F, _, k, O, W], endpoint: Gs, [l]: x }, { [f]: [N, L, ne, k, z], endpoint: { [v]: ko, [C]: V, [R]: P }, [l]: x }, { [f]: [N, L, ne, k, O, G], [l]: E, rules: [{ [f]: Re, endpoint: Ar, [l]: x }, { endpoint: Ar, [l]: x }] }, { [f]: [N, L, ne, k, O, W], endpoint: Ar, [l]: x }, { [f]: [N, _, k, z], endpoint: { [v]: Cs, [C]: V, [R]: P }, [l]: x }, { [f]: [N, _, k, O, G], [l]: E, rules: [{ [f]: Re, endpoint: { [v]: Cs, [C]: q, [R]: P }, [l]: x }, { endpoint: Ws, [l]: x }] }, { [f]: [N, _, k, O, W], endpoint: Ws, [l]: x }] }, { error: "Path-style addressing cannot be used with S3 Accelerate", [l]: S }] }] }] }, { [f]: [{ [b]: we, [w]: [Ks] }, { [b]: te, [w]: [Ks, be] }], [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ui, [l]: E, rules: [Is, Ds, { [f]: lt, endpoint: { [v]: $r, [C]: Er, [R]: P }, [l]: x }, { [f]: _t, endpoint: { [v]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [C]: Er, [R]: P }, [l]: x }, { endpoint: { [v]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [C]: Er, [R]: P }, [l]: x }] }, Bt] }] }, { [f]: [{ [b]: ge, [w]: ri }], [l]: E, rules: [{ [f]: Ce, [l]: E, rules: [{ [f]: ui, [l]: E, rules: [{ [f]: [I, F, _, z], endpoint: { [v]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [I, F, _, O, G], [l]: E, rules: [{ endpoint: Xs, [l]: x }] }, { [f]: [I, F, _, O, W], endpoint: Xs, [l]: x }, { [f]: [I, N, _, z], endpoint: { [v]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [I, N, _, O, G], [l]: E, rules: [{ endpoint: Zs, [l]: x }] }, { [f]: [I, N, _, O, W], endpoint: Zs, [l]: x }, { [f]: [k, F, _, z], endpoint: { [v]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: V, [R]: P }, [l]: x }, { [f]: [k, F, _, O, G], [l]: E, rules: [{ endpoint: Ys, [l]: x }] }, { [f]: [k, F, _, O, W], endpoint: Ys, [l]: x }, { [f]: [k, N, L, ne, z], endpoint: { [v]: $r, [C]: V, [R]: P }, [l]: x }, { [f]: [k, N, L, ne, O, G], [l]: E, rules: [{ [f]: Re, endpoint: xr, [l]: x }, { endpoint: xr, [l]: x }] }, { [f]: [k, N, L, ne, O, W], endpoint: xr, [l]: x }, { [f]: [k, N, _, z], endpoint: { [v]: Rs, [C]: V, [R]: P }, [l]: x }, { [f]: [k, N, _, O, G], [l]: E, rules: [{ [f]: Re, endpoint: { [v]: Rs, [C]: q, [R]: P }, [l]: x }, { endpoint: Qs, [l]: x }] }, { [f]: [k, N, _, O, W], endpoint: Qs, [l]: x }] }, Bt] }] }] }, { error: "A region must be set when sending requests to S3.", [l]: S }] };
var uf = cf;
var df = (e, t = {}) => yu(uf, {
  endpointParams: e,
  logger: t.logger
});
var lf = (e) => ({
  apiVersion: "2006-03-01",
  base64Decoder: (e == null ? void 0 : e.base64Decoder) ?? Zr,
  base64Encoder: (e == null ? void 0 : e.base64Encoder) ?? Yr,
  disableHostPrefix: (e == null ? void 0 : e.disableHostPrefix) ?? false,
  endpointProvider: (e == null ? void 0 : e.endpointProvider) ?? df,
  getAwsChunkedEncodingStream: (e == null ? void 0 : e.getAwsChunkedEncodingStream) ?? kd,
  logger: (e == null ? void 0 : e.logger) ?? new Cd(),
  sdkStreamMixin: (e == null ? void 0 : e.sdkStreamMixin) ?? Dd,
  serviceId: (e == null ? void 0 : e.serviceId) ?? "S3",
  signerConstructor: (e == null ? void 0 : e.signerConstructor) ?? rf,
  signingEscapePath: (e == null ? void 0 : e.signingEscapePath) ?? false,
  urlParser: (e == null ? void 0 : e.urlParser) ?? kt,
  useArnRegion: (e == null ? void 0 : e.useArnRegion) ?? false,
  utf8Decoder: (e == null ? void 0 : e.utf8Decoder) ?? xt,
  utf8Encoder: (e == null ? void 0 : e.utf8Encoder) ?? It
});
var ff = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var hf = ({ defaultsMode: e } = {}) => xi(async () => {
  const t = typeof e == "function" ? await e() : e;
  switch (t == null ? void 0 : t.toLowerCase()) {
    case "auto":
      return Promise.resolve(pf() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(t == null ? void 0 : t.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${ff.join(", ")}, got ${t}`);
  }
});
var pf = () => {
  var r, n;
  const e = typeof window < "u" && ((r = window == null ? void 0 : window.navigator) != null && r.userAgent) ? wo.parse(window.navigator.userAgent) : void 0, t = (n = e == null ? void 0 : e.platform) == null ? void 0 : n.type;
  return t === "tablet" || t === "mobile";
};
var gf = (e) => {
  const t = hf(e), r = () => t().then(Wd), n = lf(e);
  return {
    ...n,
    ...e,
    runtime: "browser",
    defaultsMode: t,
    bodyLengthChecker: (e == null ? void 0 : e.bodyLengthChecker) ?? tf,
    credentialDefaultProvider: (e == null ? void 0 : e.credentialDefaultProvider) ?? ((s) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (e == null ? void 0 : e.defaultUserAgentProvider) ?? Ul({ serviceId: n.serviceId, clientVersion: yl.version }),
    eventStreamSerdeProvider: (e == null ? void 0 : e.eventStreamSerdeProvider) ?? Gl,
    maxAttempts: (e == null ? void 0 : e.maxAttempts) ?? Xr,
    md5: (e == null ? void 0 : e.md5) ?? Ql,
    region: (e == null ? void 0 : e.region) ?? Xl("Region is missing"),
    requestHandler: (e == null ? void 0 : e.requestHandler) ?? new Od(r),
    retryMode: (e == null ? void 0 : e.retryMode) ?? (async () => (await r()).retryMode || Xu),
    sha1: (e == null ? void 0 : e.sha1) ?? io.Sha1,
    sha256: (e == null ? void 0 : e.sha256) ?? ho.Sha256,
    streamCollector: (e == null ? void 0 : e.streamCollector) ?? ro,
    streamHasher: (e == null ? void 0 : e.streamHasher) ?? Kl,
    useDualstackEndpoint: (e == null ? void 0 : e.useDualstackEndpoint) ?? (() => Promise.resolve(Su)),
    useFipsEndpoint: (e == null ? void 0 : e.useFipsEndpoint) ?? (() => Promise.resolve(vu))
  };
};
var mf = class extends Rd {
  constructor(t) {
    const r = gf(t), n = Qd(r), s = Cu(n), i = Ku(s), o = yd(i), a = o, c2 = $c(a), u = ma(c2), d = Gc(u), h = Ru(d);
    super(h), this.config = h, this.middlewareStack.use(Sd(this.config)), this.middlewareStack.use(Tu(this.config)), this.middlewareStack.use(na(this.config)), this.middlewareStack.use(oa(this.config)), this.middlewareStack.use(la(this.config)), this.middlewareStack.use(Vc(this.config)), this.middlewareStack.use(Aa(this.config)), this.middlewareStack.use(ea(this.config)), this.middlewareStack.use(xu(this.config));
  }
  destroy() {
    super.destroy();
  }
};
var sn = {};
var Lt = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + t + "][" + r + "]*", s = new RegExp("^" + n + "$"), i = function(a, c2) {
    const u = [];
    let d = c2.exec(a);
    for (; d; ) {
      const h = [];
      h.startIndex = c2.lastIndex - d[0].length;
      const p = d.length;
      for (let y = 0; y < p; y++)
        h.push(d[y]);
      u.push(h), d = c2.exec(a);
    }
    return u;
  }, o = function(a) {
    const c2 = s.exec(a);
    return !(c2 === null || typeof c2 > "u");
  };
  e.isExist = function(a) {
    return typeof a < "u";
  }, e.isEmptyObject = function(a) {
    return Object.keys(a).length === 0;
  }, e.merge = function(a, c2, u) {
    if (c2) {
      const d = Object.keys(c2), h = d.length;
      for (let p = 0; p < h; p++)
        u === "strict" ? a[d[p]] = [c2[d[p]]] : a[d[p]] = c2[d[p]];
    }
  }, e.getValue = function(a) {
    return e.isExist(a) ? a : "";
  }, e.isName = o, e.getAllMatches = i, e.nameRegexp = n;
})(Lt);
var on = Lt;
var yf = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
sn.validate = function(e, t) {
  t = Object.assign({}, yf, t);
  const r = [];
  let n = false, s = false;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<" && e[i + 1] === "?") {
      if (i += 2, i = li(e, i), i.err)
        return i;
    } else if (e[i] === "<") {
      let o = i;
      if (i++, e[i] === "!") {
        i = fi(e, i);
        continue;
      } else {
        let a = false;
        e[i] === "/" && (a = true, i++);
        let c2 = "";
        for (; i < e.length && e[i] !== ">" && e[i] !== " " && e[i] !== "	" && e[i] !== `
` && e[i] !== "\r"; i++)
          c2 += e[i];
        if (c2 = c2.trim(), c2[c2.length - 1] === "/" && (c2 = c2.substring(0, c2.length - 1), i--), !Cf(c2)) {
          let h;
          return c2.trim().length === 0 ? h = "Invalid space after '<'." : h = "Tag '" + c2 + "' is an invalid name.", j("InvalidTag", h, ie(e, i));
        }
        const u = Af(e, i);
        if (u === false)
          return j("InvalidAttr", "Attributes for '" + c2 + "' have open quote.", ie(e, i));
        let d = u.value;
        if (i = u.index, d[d.length - 1] === "/") {
          const h = i - d.length;
          d = d.substring(0, d.length - 1);
          const p = hi(d, t);
          if (p === true)
            n = true;
          else
            return j(p.err.code, p.err.msg, ie(e, h + p.err.line));
        } else if (a)
          if (u.tagClosed) {
            if (d.trim().length > 0)
              return j("InvalidTag", "Closing tag '" + c2 + "' can't have attributes or invalid starting.", ie(e, o));
            {
              const h = r.pop();
              if (c2 !== h.tagName) {
                let p = ie(e, h.tagStartPos);
                return j(
                  "InvalidTag",
                  "Expected closing tag '" + h.tagName + "' (opened in line " + p.line + ", col " + p.col + ") instead of closing tag '" + c2 + "'.",
                  ie(e, o)
                );
              }
              r.length == 0 && (s = true);
            }
          } else
            return j("InvalidTag", "Closing tag '" + c2 + "' doesn't have proper closing.", ie(e, i));
        else {
          const h = hi(d, t);
          if (h !== true)
            return j(h.err.code, h.err.msg, ie(e, i - d.length + h.err.line));
          if (s === true)
            return j("InvalidXml", "Multiple possible root nodes found.", ie(e, i));
          t.unpairedTags.indexOf(c2) !== -1 || r.push({ tagName: c2, tagStartPos: o }), n = true;
        }
        for (i++; i < e.length; i++)
          if (e[i] === "<")
            if (e[i + 1] === "!") {
              i++, i = fi(e, i);
              continue;
            } else if (e[i + 1] === "?") {
              if (i = li(e, ++i), i.err)
                return i;
            } else
              break;
          else if (e[i] === "&") {
            const h = Sf(e, i);
            if (h == -1)
              return j("InvalidChar", "char '&' is not expected.", ie(e, i));
            i = h;
          } else if (s === true && !di(e[i]))
            return j("InvalidXml", "Extra text at the end", ie(e, i));
        e[i] === "<" && i--;
      }
    } else {
      if (di(e[i]))
        continue;
      return j("InvalidChar", "char '" + e[i] + "' is not expected.", ie(e, i));
    }
  if (n) {
    if (r.length == 1)
      return j("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", ie(e, r[0].tagStartPos));
    if (r.length > 0)
      return j("InvalidXml", "Invalid '" + JSON.stringify(r.map((i) => i.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return j("InvalidXml", "Start tag expected.", 1);
  return true;
};
function di(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function li(e, t) {
  const r = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const n = e.substr(r, t - r);
      if (t > 5 && n === "xml")
        return j("InvalidXml", "XML declaration allowed only at the start of the document.", ie(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function fi(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let r = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        r++;
      else if (e[t] === ">" && (r--, r === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
var bf = '"';
var wf = "'";
function Af(e, t) {
  let r = "", n = "", s = false;
  for (; t < e.length; t++) {
    if (e[t] === bf || e[t] === wf)
      n === "" ? n = e[t] : n !== e[t] || (n = "");
    else if (e[t] === ">" && n === "") {
      s = true;
      break;
    }
    r += e[t];
  }
  return n !== "" ? false : {
    value: r,
    index: t,
    tagClosed: s
  };
}
var Ef = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function hi(e, t) {
  const r = on.getAllMatches(e, Ef), n = {};
  for (let s = 0; s < r.length; s++) {
    if (r[s][1].length === 0)
      return j("InvalidAttr", "Attribute '" + r[s][2] + "' has no space in starting.", ft(r[s]));
    if (r[s][3] !== void 0 && r[s][4] === void 0)
      return j("InvalidAttr", "Attribute '" + r[s][2] + "' is without value.", ft(r[s]));
    if (r[s][3] === void 0 && !t.allowBooleanAttributes)
      return j("InvalidAttr", "boolean attribute '" + r[s][2] + "' is not allowed.", ft(r[s]));
    const i = r[s][2];
    if (!vf(i))
      return j("InvalidAttr", "Attribute '" + i + "' is an invalid name.", ft(r[s]));
    if (!n.hasOwnProperty(i))
      n[i] = 1;
    else
      return j("InvalidAttr", "Attribute '" + i + "' is repeated.", ft(r[s]));
  }
  return true;
}
function xf(e, t) {
  let r = /\d/;
  for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(r))
      break;
  }
  return -1;
}
function Sf(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, xf(e, t);
  let r = 0;
  for (; t < e.length; t++, r++)
    if (!(e[t].match(/\w/) && r < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function j(e, t, r) {
  return {
    err: {
      code: e,
      msg: t,
      line: r.line || r,
      col: r.col
    }
  };
}
function vf(e) {
  return on.isName(e);
}
function Cf(e) {
  return on.isName(e);
}
function ie(e, t) {
  const r = e.substring(0, t).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function ft(e) {
  return e.startIndex + e[1].length;
}
var an = {};
var Do = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(e, t, r) {
    return e;
  }
  // skipEmptyListItem: false
};
var Rf = function(e) {
  return Object.assign({}, Do, e);
};
an.buildOptions = Rf;
an.defaultOptions = Do;
var Bf = class {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, r) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
};
var _f = Bf;
var Tf = Lt;
function kf(e, t) {
  const r = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let n = 1, s = false, i = false, o = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !i) {
        if (s && Of(e, t))
          t += 7, [entityName, val, t] = Pf(e, t + 1), val.indexOf("&") === -1 && (r[Df(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (s && Mf(e, t))
          t += 8;
        else if (s && Ff(e, t))
          t += 8;
        else if (s && If(e, t))
          t += 9;
        else if (Nf)
          i = true;
        else
          throw new Error("Invalid DOCTYPE");
        n++, o = "";
      } else if (e[t] === ">") {
        if (i ? e[t - 1] === "-" && e[t - 2] === "-" && (i = false, n--) : n--, n === 0)
          break;
      } else
        e[t] === "[" ? s = true : o += e[t];
    if (n !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: r, i: t };
}
function Pf(e, t) {
  let r = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    r += e[t];
  if (r = r.trim(), r.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const n = e[t++];
  let s = "";
  for (; t < e.length && e[t] !== n; t++)
    s += e[t];
  return [r, s, t];
}
function Nf(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function Of(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function Mf(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function Ff(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function If(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function Df(e) {
  if (Tf.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var Uf = kf;
var Lf = /^[-+]?0x[a-fA-F0-9]+$/;
var $f = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
var Hf = {
  hex: true,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function jf(e, t = {}) {
  if (t = Object.assign({}, Hf, t), !e || typeof e != "string")
    return e;
  let r = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(r))
    return e;
  if (t.hex && Lf.test(r))
    return Number.parseInt(r, 16);
  {
    const n = $f.exec(r);
    if (n) {
      const s = n[1], i = n[2];
      let o = qf(n[3]);
      const a = n[4] || n[6];
      if (!t.leadingZeros && i.length > 0 && s && r[2] !== ".")
        return e;
      if (!t.leadingZeros && i.length > 0 && !s && r[1] !== ".")
        return e;
      {
        const c2 = Number(r), u = "" + c2;
        return u.search(/[eE]/) !== -1 || a ? t.eNotation ? c2 : e : r.indexOf(".") !== -1 ? u === "0" && o === "" || u === o || s && u === "-" + o ? c2 : e : i ? o === u || s + o === u ? c2 : e : r === u || r === s + u ? c2 : e;
      }
    } else
      return e;
  }
}
function qf(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
var zf = jf;
var cn = Lt;
var ht = _f;
var Vf = Uf;
var Gf = zf;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, cn.nameRegexp);
var Wf = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "¢" },
      pound: { regex: /&(pound|#163);/g, val: "£" },
      yen: { regex: /&(yen|#165);/g, val: "¥" },
      euro: { regex: /&(euro|#8364);/g, val: "€" },
      copyright: { regex: /&(copy|#169);/g, val: "©" },
      reg: { regex: /&(reg|#174);/g, val: "®" },
      inr: { regex: /&(inr|#8377);/g, val: "₹" }
    }, this.addExternalEntities = Kf, this.parseXml = Jf, this.parseTextData = Xf, this.resolveNameSpace = Zf, this.buildAttributesMap = Qf, this.isItStopNode = nh, this.replaceEntitiesValue = th, this.readStopNodeData = ih, this.saveTextToParentTag = rh, this.addChild = eh;
  }
};
function Kf(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    this.lastEntities[n] = {
      regex: new RegExp("&" + n + ";", "g"),
      val: e[n]
    };
  }
}
function Xf(e, t, r, n, s, i, o) {
  if (e !== void 0 && (this.options.trimValues && !n && (e = e.trim()), e.length > 0)) {
    o || (e = this.replaceEntitiesValue(e));
    const a = this.options.tagValueProcessor(t, e, r, s, i);
    return a == null ? e : typeof a != typeof e || a !== e ? a : this.options.trimValues ? qr(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? qr(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function Zf(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), r = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = r + t[1]);
  }
  return e;
}
var Yf = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Qf(e, t, r) {
  if (!this.options.ignoreAttributes && typeof e == "string") {
    const n = cn.getAllMatches(e, Yf), s = n.length, i = {};
    for (let o = 0; o < s; o++) {
      const a = this.resolveNameSpace(n[o][1]);
      let c2 = n[o][4], u = this.options.attributeNamePrefix + a;
      if (a.length)
        if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)), u === "__proto__" && (u = "#__proto__"), c2 !== void 0) {
          this.options.trimValues && (c2 = c2.trim()), c2 = this.replaceEntitiesValue(c2);
          const d = this.options.attributeValueProcessor(a, c2, t);
          d == null ? i[u] = c2 : typeof d != typeof c2 || d !== c2 ? i[u] = d : i[u] = qr(
            c2,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (i[u] = true);
    }
    if (!Object.keys(i).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = i, o;
    }
    return i;
  }
}
var Jf = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new ht("!xml");
  let r = t, n = "", s = "";
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<")
      if (e[i + 1] === "/") {
        const a = Ie(e, ">", i, "Closing Tag is not closed.");
        let c2 = e.substring(i + 2, a).trim();
        if (this.options.removeNSPrefix) {
          const h = c2.indexOf(":");
          h !== -1 && (c2 = c2.substr(h + 1));
        }
        this.options.transformTagName && (c2 = this.options.transformTagName(c2)), r && (n = this.saveTextToParentTag(n, r, s));
        const u = s.substring(s.lastIndexOf(".") + 1);
        if (c2 && this.options.unpairedTags.indexOf(c2) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${c2}>`);
        let d = 0;
        u && this.options.unpairedTags.indexOf(u) !== -1 ? (d = s.lastIndexOf(".", s.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : d = s.lastIndexOf("."), s = s.substring(0, d), r = this.tagsNodeStack.pop(), n = "", i = a;
      } else if (e[i + 1] === "?") {
        let a = jr(e, i, false, "?>");
        if (!a)
          throw new Error("Pi Tag is not closed.");
        if (n = this.saveTextToParentTag(n, r, s), !(this.options.ignoreDeclaration && a.tagName === "?xml" || this.options.ignorePiTags)) {
          const c2 = new ht(a.tagName);
          c2.add(this.options.textNodeName, ""), a.tagName !== a.tagExp && a.attrExpPresent && (c2[":@"] = this.buildAttributesMap(a.tagExp, s, a.tagName)), this.addChild(r, c2, s);
        }
        i = a.closeIndex + 1;
      } else if (e.substr(i + 1, 3) === "!--") {
        const a = Ie(e, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const c2 = e.substring(i + 4, a - 2);
          n = this.saveTextToParentTag(n, r, s), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: c2 }]);
        }
        i = a;
      } else if (e.substr(i + 1, 2) === "!D") {
        const a = Vf(e, i);
        this.docTypeEntities = a.entities, i = a.i;
      } else if (e.substr(i + 1, 2) === "![") {
        const a = Ie(e, "]]>", i, "CDATA is not closed.") - 2, c2 = e.substring(i + 9, a);
        if (n = this.saveTextToParentTag(n, r, s), this.options.cdataPropName)
          r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: c2 }]);
        else {
          let u = this.parseTextData(c2, r.tagname, s, true, false, true);
          u == null && (u = ""), r.add(this.options.textNodeName, u);
        }
        i = a + 2;
      } else {
        let a = jr(e, i, this.options.removeNSPrefix), c2 = a.tagName, u = a.tagExp, d = a.attrExpPresent, h = a.closeIndex;
        this.options.transformTagName && (c2 = this.options.transformTagName(c2)), r && n && r.tagname !== "!xml" && (n = this.saveTextToParentTag(n, r, s, false));
        const p = r;
        if (p && this.options.unpairedTags.indexOf(p.tagname) !== -1 && (r = this.tagsNodeStack.pop(), s = s.substring(0, s.lastIndexOf("."))), c2 !== t.tagname && (s += s ? "." + c2 : c2), this.isItStopNode(this.options.stopNodes, s, c2)) {
          let y = "";
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1)
            i = a.closeIndex;
          else if (this.options.unpairedTags.indexOf(c2) !== -1)
            i = a.closeIndex;
          else {
            const A = this.readStopNodeData(e, c2, h + 1);
            if (!A)
              throw new Error(`Unexpected end of ${c2}`);
            i = A.i, y = A.tagContent;
          }
          const g = new ht(c2);
          c2 !== u && d && (g[":@"] = this.buildAttributesMap(u, s, c2)), y && (y = this.parseTextData(y, c2, s, true, d, true, true)), s = s.substr(0, s.lastIndexOf(".")), g.add(this.options.textNodeName, y), this.addChild(r, g, s);
        } else {
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1) {
            c2[c2.length - 1] === "/" ? (c2 = c2.substr(0, c2.length - 1), u = c2) : u = u.substr(0, u.length - 1), this.options.transformTagName && (c2 = this.options.transformTagName(c2));
            const y = new ht(c2);
            c2 !== u && d && (y[":@"] = this.buildAttributesMap(u, s, c2)), this.addChild(r, y, s), s = s.substr(0, s.lastIndexOf("."));
          } else {
            const y = new ht(c2);
            this.tagsNodeStack.push(r), c2 !== u && d && (y[":@"] = this.buildAttributesMap(u, s, c2)), this.addChild(r, y, s), r = y;
          }
          n = "", i = h;
        }
      }
    else
      n += e[i];
  return t.child;
};
function eh(e, t, r) {
  const n = this.options.updateTag(t.tagname, r, t[":@"]);
  n === false || (typeof n == "string" && (t.tagname = n), e.addChild(t));
}
var th = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const r = this.docTypeEntities[t];
      e = e.replace(r.regx, r.val);
    }
    for (let t in this.lastEntities) {
      const r = this.lastEntities[t];
      e = e.replace(r.regex, r.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const r = this.htmlEntities[t];
        e = e.replace(r.regex, r.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function rh(e, t, r, n) {
  return e && (n === void 0 && (n = Object.keys(t.child).length === 0), e = this.parseTextData(
    e,
    t.tagname,
    r,
    false,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : false,
    n
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function nh(e, t, r) {
  const n = "*." + r;
  for (const s in e) {
    const i = e[s];
    if (n === i || t === i)
      return true;
  }
  return false;
}
function sh(e, t, r = ">") {
  let n, s = "";
  for (let i = t; i < e.length; i++) {
    let o = e[i];
    if (n)
      o === n && (n = "");
    else if (o === '"' || o === "'")
      n = o;
    else if (o === r[0])
      if (r[1]) {
        if (e[i + 1] === r[1])
          return {
            data: s,
            index: i
          };
      } else
        return {
          data: s,
          index: i
        };
    else
      o === "	" && (o = " ");
    s += o;
  }
}
function Ie(e, t, r, n) {
  const s = e.indexOf(t, r);
  if (s === -1)
    throw new Error(n);
  return s + t.length - 1;
}
function jr(e, t, r, n = ">") {
  const s = sh(e, t + 1, n);
  if (!s)
    return;
  let i = s.data;
  const o = s.index, a = i.search(/\s/);
  let c2 = i, u = true;
  if (a !== -1 && (c2 = i.substr(0, a).replace(/\s\s*$/, ""), i = i.substr(a + 1)), r) {
    const d = c2.indexOf(":");
    d !== -1 && (c2 = c2.substr(d + 1), u = c2 !== s.data.substr(d + 1));
  }
  return {
    tagName: c2,
    tagExp: i,
    closeIndex: o,
    attrExpPresent: u
  };
}
function ih(e, t, r) {
  const n = r;
  let s = 1;
  for (; r < e.length; r++)
    if (e[r] === "<")
      if (e[r + 1] === "/") {
        const i = Ie(e, ">", r, `${t} is not closed`);
        if (e.substring(r + 2, i).trim() === t && (s--, s === 0))
          return {
            tagContent: e.substring(n, r),
            i
          };
        r = i;
      } else if (e[r + 1] === "?")
        r = Ie(e, "?>", r + 1, "StopNode is not closed.");
      else if (e.substr(r + 1, 3) === "!--")
        r = Ie(e, "-->", r + 3, "StopNode is not closed.");
      else if (e.substr(r + 1, 2) === "![")
        r = Ie(e, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const i = jr(e, r, ">");
        i && ((i && i.tagName) === t && i.tagExp[i.tagExp.length - 1] !== "/" && s++, r = i.closeIndex);
      }
}
function qr(e, t, r) {
  if (t && typeof e == "string") {
    const n = e.trim();
    return n === "true" ? true : n === "false" ? false : Gf(e, r);
  } else
    return cn.isExist(e) ? e : "";
}
var oh = Wf;
var Uo = {};
function ah(e, t) {
  return Lo(e, t);
}
function Lo(e, t, r) {
  let n;
  const s = {};
  for (let i = 0; i < e.length; i++) {
    const o = e[i], a = ch(o);
    let c2 = "";
    if (r === void 0 ? c2 = a : c2 = r + "." + a, a === t.textNodeName)
      n === void 0 ? n = o[a] : n += "" + o[a];
    else {
      if (a === void 0)
        continue;
      if (o[a]) {
        let u = Lo(o[a], t, c2);
        const d = dh(u, t);
        o[":@"] ? uh(u, o[":@"], c2, t) : Object.keys(u).length === 1 && u[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? u = u[t.textNodeName] : Object.keys(u).length === 0 && (t.alwaysCreateTextNode ? u[t.textNodeName] = "" : u = ""), s[a] !== void 0 && s.hasOwnProperty(a) ? (Array.isArray(s[a]) || (s[a] = [s[a]]), s[a].push(u)) : t.isArray(a, c2, d) ? s[a] = [u] : s[a] = u;
      }
    }
  }
  return typeof n == "string" ? n.length > 0 && (s[t.textNodeName] = n) : n !== void 0 && (s[t.textNodeName] = n), s;
}
function ch(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function uh(e, t, r, n) {
  if (t) {
    const s = Object.keys(t), i = s.length;
    for (let o = 0; o < i; o++) {
      const a = s[o];
      n.isArray(a, r + "." + a, true, true) ? e[a] = [t[a]] : e[a] = t[a];
    }
  }
}
function dh(e, t) {
  const { textNodeName: r } = t, n = Object.keys(e).length;
  return !!(n === 0 || n === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0));
}
Uo.prettify = ah;
var { buildOptions: lh } = an;
var fh = oh;
var { prettify: hh } = Uo;
var ph = sn;
var gh = class {
  constructor(t) {
    this.externalEntities = {}, this.options = lh(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, r) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === true && (r = {});
      const i = ph.validate(t, r);
      if (i !== true)
        throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
    }
    const n = new fh(this.options);
    n.addExternalEntities(this.externalEntities);
    const s = n.parseXml(t);
    return this.options.preserveOrder || s === void 0 ? s : hh(s, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = r;
  }
};
var mh = gh;
var yh = `
`;
function bh(e, t) {
  let r = "";
  return t.format && t.indentBy.length > 0 && (r = yh), $o(e, t, "", r);
}
function $o(e, t, r, n) {
  let s = "", i = false;
  for (let o = 0; o < e.length; o++) {
    const a = e[o], c2 = wh(a);
    let u = "";
    if (r.length === 0 ? u = c2 : u = `${r}.${c2}`, c2 === t.textNodeName) {
      let g = a[c2];
      Ah(u, t) || (g = t.tagValueProcessor(c2, g), g = Ho(g, t)), i && (s += n), s += g, i = false;
      continue;
    } else if (c2 === t.cdataPropName) {
      i && (s += n), s += `<![CDATA[${a[c2][0][t.textNodeName]}]]>`, i = false;
      continue;
    } else if (c2 === t.commentPropName) {
      s += n + `<!--${a[c2][0][t.textNodeName]}-->`, i = true;
      continue;
    } else if (c2[0] === "?") {
      const g = pi(a[":@"], t), A = c2 === "?xml" ? "" : n;
      let B = a[c2][0][t.textNodeName];
      B = B.length !== 0 ? " " + B : "", s += A + `<${c2}${B}${g}?>`, i = true;
      continue;
    }
    let d = n;
    d !== "" && (d += t.indentBy);
    const h = pi(a[":@"], t), p = n + `<${c2}${h}`, y = $o(a[c2], t, u, d);
    t.unpairedTags.indexOf(c2) !== -1 ? t.suppressUnpairedNode ? s += p + ">" : s += p + "/>" : (!y || y.length === 0) && t.suppressEmptyNode ? s += p + "/>" : y && y.endsWith(">") ? s += p + `>${y}${n}</${c2}>` : (s += p + ">", y && n !== "" && (y.includes("/>") || y.includes("</")) ? s += n + t.indentBy + y + n : s += y, s += `</${c2}>`), i = true;
  }
  return s;
}
function wh(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function pi(e, t) {
  let r = "";
  if (e && !t.ignoreAttributes)
    for (let n in e) {
      let s = t.attributeValueProcessor(n, e[n]);
      s = Ho(s, t), s === true && t.suppressBooleanAttributes ? r += ` ${n.substr(t.attributeNamePrefix.length)}` : r += ` ${n.substr(t.attributeNamePrefix.length)}="${s}"`;
    }
  return r;
}
function Ah(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let r = e.substr(e.lastIndexOf(".") + 1);
  for (let n in t.stopNodes)
    if (t.stopNodes[n] === e || t.stopNodes[n] === "*." + r)
      return true;
  return false;
}
function Ho(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let r = 0; r < t.entities.length; r++) {
      const n = t.entities[r];
      e = e.replace(n.regex, n.val);
    }
  return e;
}
var Eh = bh;
var xh = Eh;
var Sh = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Oe(e) {
  this.options = Object.assign({}, Sh, e), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return false;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Rh), this.processTextOrObjNode = vh, this.options.format ? (this.indentate = Ch, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Oe.prototype.build = function(e) {
  return this.options.preserveOrder ? xh(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0).val);
};
Oe.prototype.j2x = function(e, t) {
  let r = "", n = "";
  for (let s in e)
    if (!(typeof e[s] > "u"))
      if (e[s] === null)
        s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar;
      else if (e[s] instanceof Date)
        n += this.buildTextValNode(e[s], s, "", t);
      else if (typeof e[s] != "object") {
        const i = this.isAttribute(s);
        if (i)
          r += this.buildAttrPairStr(i, "" + e[s]);
        else if (s === this.options.textNodeName) {
          let o = this.options.tagValueProcessor(s, "" + e[s]);
          n += this.replaceEntitiesValue(o);
        } else
          n += this.buildTextValNode(e[s], s, "", t);
      } else if (Array.isArray(e[s])) {
        const i = e[s].length;
        let o = "";
        for (let a = 0; a < i; a++) {
          const c2 = e[s][a];
          typeof c2 > "u" || (c2 === null ? s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar : typeof c2 == "object" ? this.options.oneListGroup ? o += this.j2x(c2, t + 1).val : o += this.processTextOrObjNode(c2, s, t) : o += this.buildTextValNode(c2, s, "", t));
        }
        this.options.oneListGroup && (o = this.buildObjectNode(o, s, "", t)), n += o;
      } else if (this.options.attributesGroupName && s === this.options.attributesGroupName) {
        const i = Object.keys(e[s]), o = i.length;
        for (let a = 0; a < o; a++)
          r += this.buildAttrPairStr(i[a], "" + e[s][i[a]]);
      } else
        n += this.processTextOrObjNode(e[s], s, t);
  return { attrStr: r, val: n };
};
Oe.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function vh(e, t, r) {
  const n = this.j2x(e, r + 1);
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, n.attrStr, r) : this.buildObjectNode(n.val, t, n.attrStr, r);
}
Oe.prototype.buildObjectNode = function(e, t, r, n) {
  if (e === "")
    return t[0] === "?" ? this.indentate(n) + "<" + t + r + "?" + this.tagEndChar : this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
  {
    let s = "</" + t + this.tagEndChar, i = "";
    return t[0] === "?" && (i = "?", s = ""), r && e.indexOf("<") === -1 ? this.indentate(n) + "<" + t + r + i + ">" + e + s : this.options.commentPropName !== false && t === this.options.commentPropName && i.length === 0 ? this.indentate(n) + `<!--${e}-->` + this.newLine : this.indentate(n) + "<" + t + r + i + this.tagEndChar + e + this.indentate(n) + s;
  }
};
Oe.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
Oe.prototype.buildTextValNode = function(e, t, r, n) {
  if (this.options.cdataPropName !== false && t === this.options.cdataPropName)
    return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== false && t === this.options.commentPropName)
    return this.indentate(n) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(n) + "<" + t + r + "?" + this.tagEndChar;
  {
    let s = this.options.tagValueProcessor(t, e);
    return s = this.replaceEntitiesValue(s), s === "" ? this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar : this.indentate(n) + "<" + t + r + ">" + s + "</" + t + this.tagEndChar;
  }
};
Oe.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const r = this.options.entities[t];
      e = e.replace(r.regex, r.val);
    }
  return e;
};
function Ch(e) {
  return this.options.indentBy.repeat(e);
}
function Rh(e) {
  return e.startsWith(this.options.attributeNamePrefix) ? e.substr(this.attrPrefixLen) : false;
}
var Bh = Oe;
var _h = sn;
var Th = mh;
var kh = Bh;
var Ph = {
  XMLParser: Th,
  XMLValidator: _h,
  XMLBuilder: kh
};
var un = class _un extends Qr {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, _un.prototype);
  }
};
var gi;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(gi || (gi = {}));
var mi;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.ObjectSizeGreaterThan !== void 0 ? r.ObjectSizeGreaterThan(t.ObjectSizeGreaterThan) : t.ObjectSizeLessThan !== void 0 ? r.ObjectSizeLessThan(t.ObjectSizeLessThan) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(mi || (mi = {}));
var yi;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.AccessPointArn !== void 0 ? r.AccessPointArn(t.AccessPointArn) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(yi || (yi = {}));
var bi;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(bi || (bi = {}));
var Nh = (e) => ({
  ...e,
  ...e.SSEKMSKeyId && { SSEKMSKeyId: bt },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: bt }
});
var Oh = (e) => ({
  ...e,
  ...e.SSECustomerKey && { SSECustomerKey: bt },
  ...e.SSEKMSKeyId && { SSEKMSKeyId: bt },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: bt }
});
var Mh = async (e, t) => {
  const { hostname: r, protocol: n = "https", port: s, path: i } = await t.endpoint(), o = Nt({}, pt, {
    "content-type": e.ContentType || "application/octet-stream",
    "x-amz-acl": e.ACL,
    "cache-control": e.CacheControl,
    "content-disposition": e.ContentDisposition,
    "content-encoding": e.ContentEncoding,
    "content-language": e.ContentLanguage,
    "content-length": [() => pt(e.ContentLength), () => e.ContentLength.toString()],
    "content-md5": e.ContentMD5,
    "x-amz-sdk-checksum-algorithm": e.ChecksumAlgorithm,
    "x-amz-checksum-crc32": e.ChecksumCRC32,
    "x-amz-checksum-crc32c": e.ChecksumCRC32C,
    "x-amz-checksum-sha1": e.ChecksumSHA1,
    "x-amz-checksum-sha256": e.ChecksumSHA256,
    expires: [() => pt(e.Expires), () => jd(e.Expires).toString()],
    "x-amz-grant-full-control": e.GrantFullControl,
    "x-amz-grant-read": e.GrantRead,
    "x-amz-grant-read-acp": e.GrantReadACP,
    "x-amz-grant-write-acp": e.GrantWriteACP,
    "x-amz-server-side-encryption": e.ServerSideEncryption,
    "x-amz-storage-class": e.StorageClass,
    "x-amz-website-redirect-location": e.WebsiteRedirectLocation,
    "x-amz-server-side-encryption-customer-algorithm": e.SSECustomerAlgorithm,
    "x-amz-server-side-encryption-customer-key": e.SSECustomerKey,
    "x-amz-server-side-encryption-customer-key-md5": e.SSECustomerKeyMD5,
    "x-amz-server-side-encryption-aws-kms-key-id": e.SSEKMSKeyId,
    "x-amz-server-side-encryption-context": e.SSEKMSEncryptionContext,
    "x-amz-server-side-encryption-bucket-key-enabled": [
      () => pt(e.BucketKeyEnabled),
      () => e.BucketKeyEnabled.toString()
    ],
    "x-amz-request-payer": e.RequestPayer,
    "x-amz-tagging": e.Tagging,
    "x-amz-object-lock-mode": e.ObjectLockMode,
    "x-amz-object-lock-retain-until-date": [
      () => pt(e.ObjectLockRetainUntilDate),
      () => (e.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z").toString()
    ],
    "x-amz-object-lock-legal-hold": e.ObjectLockLegalHoldStatus,
    "x-amz-expected-bucket-owner": e.ExpectedBucketOwner,
    ...e.Metadata !== void 0 && Object.keys(e.Metadata).reduce((h, p) => (h[`x-amz-meta-${p.toLowerCase()}`] = e.Metadata[p], h), {})
  });
  let a = `${i != null && i.endsWith("/") ? i.slice(0, -1) : i || ""}/{Key+}`;
  a = Wn(a, e, "Bucket", () => e.Bucket, "{Bucket}", false), a = Wn(a, e, "Key", () => e.Key, "{Key+}", true);
  const c2 = Nt({
    "x-id": [, "PutObject"]
  });
  let u;
  e.Body !== void 0 && (u = e.Body);
  let d;
  return e.Body !== void 0 && (d = e.Body, u = d), new ue({
    protocol: n,
    hostname: r,
    port: s,
    method: "PUT",
    headers: o,
    path: a,
    query: c2,
    body: u
  });
};
var Fh = async (e, t) => {
  if (e.statusCode !== 200 && e.statusCode >= 300)
    return Ih(e, t);
  const r = Nt({
    $metadata: Uh(e),
    Expiration: [, e.headers["x-amz-expiration"]],
    ETag: [, e.headers.etag],
    ChecksumCRC32: [, e.headers["x-amz-checksum-crc32"]],
    ChecksumCRC32C: [, e.headers["x-amz-checksum-crc32c"]],
    ChecksumSHA1: [, e.headers["x-amz-checksum-sha1"]],
    ChecksumSHA256: [, e.headers["x-amz-checksum-sha256"]],
    ServerSideEncryption: [, e.headers["x-amz-server-side-encryption"]],
    VersionId: [, e.headers["x-amz-version-id"]],
    SSECustomerAlgorithm: [, e.headers["x-amz-server-side-encryption-customer-algorithm"]],
    SSECustomerKeyMD5: [, e.headers["x-amz-server-side-encryption-customer-key-md5"]],
    SSEKMSKeyId: [, e.headers["x-amz-server-side-encryption-aws-kms-key-id"]],
    SSEKMSEncryptionContext: [, e.headers["x-amz-server-side-encryption-context"]],
    BucketKeyEnabled: [
      () => e.headers["x-amz-server-side-encryption-bucket-key-enabled"] !== void 0,
      () => Ld(e.headers["x-amz-server-side-encryption-bucket-key-enabled"])
    ],
    RequestCharged: [, e.headers["x-amz-request-charged"]]
  });
  return await no(e.body, t), r;
};
var Ih = async (e, t) => {
  const r = {
    ...e,
    body: await Hh(e.body, t)
  }, n = jh(e, r.body), s = r.body;
  return Dh({
    output: e,
    parsedBody: s,
    errorCode: n
  });
};
var Dh = Vd(un);
var Uh = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
});
var Lh = (e, t) => no(e, t).then((r) => t.utf8Encoder(r));
var pt = (e) => e != null && e !== "" && (!Object.getOwnPropertyNames(e).includes("length") || e.length != 0) && (!Object.getOwnPropertyNames(e).includes("size") || e.size != 0);
var $h = (e, t) => Lh(e, t).then((r) => {
  if (r.length) {
    const n = new Ph.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (c2, u) => u.trim() === "" && u.includes(`
`) ? "" : void 0
    });
    n.addEntity("#xD", "\r"), n.addEntity("#10", `
`);
    const s = n.parse(r), i = "#text", o = Object.keys(s)[0], a = s[o];
    return a[i] && (a[o] = a[i], delete a[i]), so(a);
  }
  return {};
});
var Hh = async (e, t) => {
  const r = await $h(e, t);
  return r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r;
};
var jh = (e, t) => {
  if ((t == null ? void 0 : t.Code) !== void 0)
    return t.Code;
  if (e.statusCode == 404)
    return "NotFound";
};
function qh(e) {
  return (t) => async (r) => {
    let n = { ...r.input };
    const s = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const i of s) {
      const o = n[i.target];
      if (o) {
        const a = ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : typeof o == "string" ? e.utf8Decoder(o) : new Uint8Array(o), c2 = e.base64Encoder(a), u = new e.md5();
        u.update(a), n = {
          ...n,
          [i.target]: c2,
          [i.hash]: e.base64Encoder(await u.digest())
        };
      }
    }
    return t({
      ...r,
      input: n
    });
  };
}
var zh = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var Vh = (e) => ({
  applyToStack: (t) => {
    t.add(qh(e), zh);
  }
});
var Z;
(function(e) {
  e.MD5 = "MD5", e.CRC32 = "CRC32", e.CRC32C = "CRC32C", e.SHA1 = "SHA1", e.SHA256 = "SHA256";
})(Z || (Z = {}));
var wi;
(function(e) {
  e.HEADER = "header", e.TRAILER = "trailer";
})(wi || (wi = {}));
var zr = [
  Z.CRC32,
  Z.CRC32C,
  Z.SHA1,
  Z.SHA256
];
var Gh = [
  Z.CRC32,
  Z.CRC32C,
  Z.SHA1,
  Z.SHA256
];
var Wh = (e, { requestChecksumRequired: t, requestAlgorithmMember: r }) => {
  if (!r || !e[r])
    return t ? Z.MD5 : void 0;
  const n = e[r];
  if (!zr.includes(n))
    throw new Error(`The checksum algorithm "${n}" is not supported by the client. Select one of ${zr}.`);
  return n;
};
var jo = (e) => e === Z.MD5 ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}`;
var Kh = (e, t) => {
  const r = e.toLowerCase();
  for (const n of Object.keys(t))
    if (r === n.toLowerCase())
      return true;
  return false;
};
var qo = (e) => e !== void 0 && typeof e != "string" && !ArrayBuffer.isView(e) && !Mi(e);
var kr = {};
var gt = {};
var Ai;
function Xh() {
  if (Ai)
    return gt;
  Ai = 1, Object.defineProperty(gt, "__esModule", { value: true }), gt.AwsCrc32c = void 0;
  var e = ye, t = Pe(), r = zo(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32c = new r.Crc32c();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32c.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32c.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32c = new r.Crc32c();
      }, s;
    }()
  );
  return gt.AwsCrc32c = n, gt;
}
var Ei;
function zo() {
  return Ei || (Ei = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.AwsCrc32c = e.Crc32c = e.crc32c = void 0;
    var t = ye, r = Pe();
    function n(c2) {
      return new s().update(c2).digest();
    }
    e.crc32c = n;
    var s = (
      /** @class */
      function() {
        function c2() {
          this.checksum = 4294967295;
        }
        return c2.prototype.update = function(u) {
          var d, h;
          try {
            for (var p = t.__values(u), y = p.next(); !y.done; y = p.next()) {
              var g = y.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ g) & 255];
            }
          } catch (A) {
            d = { error: A };
          } finally {
            try {
              y && !y.done && (h = p.return) && h.call(p);
            } finally {
              if (d)
                throw d.error;
            }
          }
          return this;
        }, c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c2;
      }()
    );
    e.Crc32c = s;
    var i = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ], o = (0, r.uint32ArrayFrom)(i), a = Xh();
    Object.defineProperty(e, "AwsCrc32c", { enumerable: true, get: function() {
      return a.AwsCrc32c;
    } });
  }(kr)), kr;
}
var Zh = zo();
var Vo = (e, t) => ({
  [Z.MD5]: t.md5,
  [Z.CRC32]: Gr.AwsCrc32,
  [Z.CRC32C]: Zh.AwsCrc32c,
  [Z.SHA1]: t.sha1,
  [Z.SHA256]: t.sha256
})[e];
var Go = (e, t) => {
  const r = new e();
  return r.update(He(t || "")), r.digest();
};
var Yh = async (e, { streamHasher: t, checksumAlgorithmFn: r, base64Encoder: n }) => {
  const s = qo(e) ? t(r, e) : Go(r, e);
  return n(await s);
};
var Qh = (e = []) => {
  const t = [];
  for (const r of Gh)
    !e.includes(r) || !zr.includes(r) || t.push(r);
  return t;
};
var Jh = async (e, { config: t, responseAlgorithms: r }) => {
  const n = Qh(r), { body: s, headers: i } = e;
  for (const o of n) {
    const a = jo(o), c2 = i[a];
    if (c2) {
      const u = Vo(o, t), { streamHasher: d, base64Encoder: h } = t, p = await Yh(s, { streamHasher: d, checksumAlgorithmFn: u, base64Encoder: h });
      if (p === c2)
        break;
      throw new Error(`Checksum mismatch: expected "${p}" but received "${c2}" in response header "${a}".`);
    }
  }
};
var ep = (e, t) => (r) => async (n) => {
  if (!ue.isInstance(n.request))
    return r(n);
  const { request: s } = n, { body: i, headers: o } = s, { base64Encoder: a, streamHasher: c2 } = e, { input: u, requestChecksumRequired: d, requestAlgorithmMember: h } = t, p = Wh(u, {
    requestChecksumRequired: d,
    requestAlgorithmMember: h
  });
  let y = i, g = o;
  if (p) {
    const se = jo(p), Le = Vo(p, e);
    if (qo(i)) {
      const { getAwsChunkedEncodingStream: $t, bodyLengthChecker: Wo } = e;
      y = $t(i, {
        base64Encoder: a,
        bodyLengthChecker: Wo,
        checksumLocationName: se,
        checksumAlgorithmFn: Le,
        streamHasher: c2
      }), g = {
        ...o,
        "content-encoding": o["content-encoding"] ? `${o["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": o["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": se
      }, delete g["content-length"];
    } else if (!Kh(se, o)) {
      const $t = await Go(Le, i);
      g = {
        ...o,
        [se]: a($t)
      };
    }
  }
  const A = await r({
    ...n,
    request: {
      ...s,
      headers: g,
      body: y
    }
  }), { requestValidationModeMember: B, responseAlgorithms: fe } = t;
  return B && u[B] === "ENABLED" && await Jh(A.response, {
    config: e,
    responseAlgorithms: fe
  }), A;
};
var tp = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var rp = (e, t) => ({
  applyToStack: (r) => {
    r.add(ep(e, t), tp);
  }
});
var dn = class _dn extends Ud {
  static getEndpointParameterInstructions() {
    return {
      Bucket: { type: "contextParams", name: "Bucket" },
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(t) {
    super(), this.input = t;
  }
  resolveMiddleware(t, r, n) {
    this.middlewareStack.use(Vu(r, this.serialize, this.deserialize)), this.middlewareStack.use(Wu(r, _dn.getEndpointParameterInstructions())), this.middlewareStack.use(ga()), this.middlewareStack.use(Vh(r)), this.middlewareStack.use(rp(r, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: false
    }));
    const s = t.concat(this.middlewareStack), { logger: i } = r, c2 = {
      logger: i,
      clientName: "S3Client",
      commandName: "PutObjectCommand",
      inputFilterSensitiveLog: Oh,
      outputFilterSensitiveLog: Nh
    }, { requestHandler: u } = r;
    return s.resolve((d) => u.handle(d.request, n || {}), c2);
  }
  serialize(t, r) {
    return Mh(t, r);
  }
  deserialize(t, r) {
    return Fh(t, r);
  }
};
var np = axios_default.create({});
async function sp(e, t, r) {
  return e.getSignedUrl || console.error("请先配置uploader.getSignedUrl，该方法应该从后端获取签名url"), await e.getSignedUrl(e.bucket, t, e, r);
}
async function ip(e, t) {
  const { file: r, onProgress: n, options: s } = e, o = await sp(s, t, "put"), a = decodeURIComponent(o);
  return await np.put(a, r, {
    onUploadProgress: (c2) => {
      const { loaded: u, total: d } = c2;
      n({ percent: Math.round(u * 100 / d) });
    }
  });
}
async function op(e) {
  const { file: t, fileName: r, onProgress: n, options: s } = e, i = s, o = new mf({
    ...(i == null ? void 0 : i.sdkOpts) || {}
  }), a = await w9(t, r, i);
  async function c2() {
    const u = { url: i.sdkOpts.endpoint + "/" + i.bucket + "/" + a, key: a };
    return i.successHandle ? await i.successHandle(u) : u;
  }
  if (i.getSignedUrl)
    await ip(e, a);
  else {
    const u = {
      Bucket: i.bucket,
      Key: a
      // The name of the object. For example, 'sample_upload.txt'.
    };
    await o.send(new dn({ Body: t, ...u }));
  }
  return await c2();
}
async function mp(e) {
  const { getConfig: t } = _9(), r = t("s3"), n = e.options, s = lodash_default_default.merge(lodash_default_default.cloneDeep(r), n);
  return e.options = s, await op(e);
}
export {
  sp as buildSignedUrl,
  mp as upload,
  ip as uploadUsingSignedUrl
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@fast-crud/fast-extends/dist/uploader-s3-0c948529.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=uploader-s3-0c948529-HGEUQKKL.js.map
